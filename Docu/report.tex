\newcommand{\graphicPostfix}{pdf}
%%\newcommand{\code}[1]{\texttt{#1}}
%%\newcommand{\SysteMoC}{{\bf SysteMoC}}
%%\newcommand{\SysteMoCV}{\SysteMoC{} {\bf 1.0}}
\newcommand{\code}[1]{\emph{#1}}
\newcommand{\SysteMoC}{\emph{SysteMoC}}
\newcommand{\SysteMoCV}{\emph{SysteMoC 1.0}}
\newcommand{\implies}{\Longrightarrow}

\input{format.tex}

{\theoremheaderfont{\normalfont\sffamily\bfseries}
\newtheorem{sdefinition}{Definition}[section]
\newtheorem{definition}{Definition}[subsection]
\newtheorem{proof}{Proof}[subsection]
\newtheorem{characteristic}{Characteristic}[subsection]
{\theorembodyfont{\normalfont}
\newtheorem{example}{Example}[section]}}

\usepackage{multirow}
\usepackage{fancyvrb}

% Use a small font for the verbatim environment
\makeatletter  % makes '@' an ordinary character
\renewcommand{\verbatim@font}{%
  \ttfamily\small\catcode`\<=\active\catcode`\>=\active%
}
\makeatother   % makes '@' a special symbol again

% \begin{Verbatim}[fontsize=\tiny]

\hypersetup{
  pdftitle   = {Representing Models of Computation in SystemC},
  pdfsubject = {Co-Design-Report},
  pdfauthor  = {\textcopyright\ Joachim Falk, Christian Haubelt, J\"urgen Teich},
  colorlinks = true,
  linkcolor  = black,
  anchorcolor= black,
  citecolor  = black,
  filecolor  = black,
  menucolor  = black,
  pagecolor  = black,
  urlcolor   = black
}

\begin{document}
\hscdtitle{Representing Models of Computation in SystemC}
{Joachim Falk, Christian Haubelt, J\"urgen Teich}{2-2005}
\clearpage
\tableofcontents
\clearpage

\section{Introduction\label{intro}}
Due to rising design complexity it is necessary to increase
the level of abstraction at which systems are designed. In
today's embedded systems the specification is mostly mapped
into a set of interacting tasks and hardware modules, which 
interact by the use of shared variables and various ways of
message passing. To guarantee exclusive access to the shared
variables and resources, mutually exclusive devices like semaphores,
mutexes, and monitors are used. But this unstructured use
of communication types leads to hardly analyzable systems.
However, by constraining the type of communication
used between tasks and the communication behavior of the tasks,
expressiveness is traded for analyzability.

\emph{Models of computation}
\cite{embsft:2002}, in the following called \emph{MoCs}, are
predefined types of communication and strategies for scheduling
communicating tasks. Thus, MoCs are comparable to design
patterns known from the area of software design \cite{gamma:1995}.
Limiting the expressiveness of a MoC enables:

\begin{enumerate}
\item Mathematically reasoning about communication patterns

\item Code generation to produce optimized code

\item Automatic and efficient verification to check system properties
\end{enumerate}

On the other hand, modern embedded system design is still based on
specification languages which allow unstructured communication.
Even worse, nearly all specification languages allow for Turing
complete MoCs making analysis in general impossible.
To make industry benefit from the best of both worlds,
engineers must restrict themselves to use certain subsets of
specification languages allowing analyzability, identification,
and extraction of these MoCs at the source code level automatically.

This report deals with the representation of some %transformative
MoCs in SystemC. The rest of the report is structured as follows:
In Section~\ref{related-work}, we discuss related work. In
Section~\ref{aspect-overview}, we propose our framework for
representing MoCs in SystemC. In Section~\ref{revision-of-mocs},
we show how some MoCs fit into
the framework presented before. In Section~\ref{software-architecture},
a SystemC implementation of our framework called \SysteMoC{} is
presented. Finally, we will give some examples using the \SysteMoC{}
framework in Section~\ref{systemoc-examples}, and we conclude
the present report in Section~\ref{conclusions}.

\section{Related Work}\label{related-work}

SystemC \cite{glms:2002} already allows to implement
dataflow MoCs via communicating actors and \code{sc\_fifo} channels.
However, a dataflow MoC implemented in this way is unstructured
and no possibilities exist for deriving information about its
communication behavior. The facilities for implementing MoCs in
SystemC have been extended by Herrera et al.~\cite{herrerasystemc:2004}
which have implemented a custom library of channel types like rendezvous
on top of the SystemC discrete-event simulation kernel. But no
constraints have been imposed how these new channels types are used by
an actor. Consequently, no information about the communication behavior
of an actor can be derived.
Implementing these channels on top of the SystemC discrete-event
simulation kernel curtails the performance of such an implementation.
Another approach has been taken by Patel et al.~\cite{fermatmoc:2004}
which have extended SystemC itself with different simulation kernels
for Communicating Sequential Processes and Finite State Machine MoCs
to improve simulation efficiency. Moreover,
they have implemented hierarchical compositon of MoCs following
the approach of \hbox{Ptolemy II}. \hbox{Ptolemy II} \cite{ptolemyII} is a simulation
framework for MoCs implemented in Java. Its aim is the exploration of
different MoCs and the semantic of hierarchical composition of these MoC
with each other.

In contrast to the approaches discussed above, our methodology restricts
the communication behavior in such a way that the identification,
extraction, and analysis of different MoCs is permitted.

\section{The Tagged Signal Model}\label{lee-tsm}

We use Lee's \emph{tagged signal model} introduced in \cite{Lee98} to
distinguish MoCs. This model consist of concurrent \emph{processes} which
can only communicate with each other via \emph{signals}.
Before defining a signal, the notion of an event must be introduced first.
Given a set of tags $T$ and a set of values $V$:
\begin{sdefinition}
An \emph{event} $e$ is a  tag-value pair, i.e., $e \in T \times V$.
\end{sdefinition}
Tags are used to model time,
precedence relationships, synchronization points, or other key properties
of MoCs. The values are used as data to be manipulated by computations.
For some MoCs the set of values contains the special symbol bottom ($\bot$),
which denotes the absence of a value. The odering of the tags induces
a ordering of events, i.e., $e_1 = (t_1,v_1)$ and $e_2 = (t_2,v_2)$, then $e_1 < e_2 \iff t_1 < t_2$.
Two Events $e_1$, $e_2$ are \emph{synchronous} if they contain
the same tag, i.e., $e_1 = (t,v_1)$ and $e_2 = (t,v_2)$.
Events are often called \emph{tokens} which represent the basic communication units.

A \emph{signal} can be thought of as a subset of the set of all events or as
an element of the \emph{set of all signals} $S$, which is the powerset $S = 2^{T \times V}$
of the set of all events.
\begin{sdefinition}
A \emph{signal} $s$ is defined as a set of events, i.e., $s \subseteq T \times V$.
\end{sdefinition}
A \emph{functional signal} or \emph{proper signal} is a signal $s$ where each tag is unique in $s$,
i.e., $e_1 = (t,v_1) \in s$ and $e_2 = (t,v_2) \in s \implies v_1 = v_2$.
Intuitively, if tags represent time a proper signal is a signal which has
at most one value per point in time. Furthermore, $T(s) \subseteq T$ denotes
the set of tags in the signal $s$, i.e., $T(s) = \{t|(t,v) \in s\}$.
Two signals $s_1$ and $s_2$ are \emph{synchronous} if they contain
the same set of tags, i.e., $T(s_1) = T(s_2)$.
Hence, if two signals are synchronous each event in one
signal has a corresponding synchronous event in the other signal and vice versa.

A tuple of $N$ signals is denoted $\mathbf{s} = (s_1, s_2, \dots, s_N)$ and the
set of all $N$-tuples of signals will be denoted $S^N$, where $N$ is a
natural number.
% The position of a signal in its tuple is equivalent to its name. To
% achieve the equivalent of renaming or hiding signals, the position of
% signals in a tuple must be changed or the signal must be drop from the tuple.
% This is done by applying the \emph{projection} function to a tuple.
\begin{sdefinition}
A \emph{projection} $\pi{}_I: S^N \to S^M$ is a function which discards and reorders signals according
to the ordered set of indexes $I$ in a $N$-tuple of signals
to form a new $M$-tuple of signals, where $M \le N$, $\mathbf{s} = (s_1,\cdots,s_N) \in S^N$,
and $I = (i_1,\cdots,i_m) \in \{1,2, \ldots N\}^M$
, i.e., $\pi{}_I(\mathbf{s}) = (s_{i_1}, \cdots, s_{i_m})$.
A projection $\pi{}_I$ can be generalized to subsets $\mathbf{P}$ of $S^N$,
i.e., $\pi{}_I(\mathbf{P}) = \{\mathbf{s'}|\pi{}_I(s) = \mathbf{s'} \wedge \mathbf{s} \in \mathbf{P}\}$.
\end{sdefinition}
The \emph{empty signal} is denoted by $\lambda$. This
signal does not have any events, i.e., $\lambda = \emptyset$. And a \emph{tuple
of empty signals} will be denoted by $\Lambda$.

After defining signals, we are able to review the definitions of processes.
Later, we will use processes to transform signals.
Processes are described as sets of possible behaviors, where
a \emph{behavior} is a tuple of signals:
\begin{sdefinition}
A process $\mathbf{P}$ is a subset of $S^N$, i.e., $\mathbf{P} \subseteq S^N$.
\end{sdefinition}
Each element $\mathbf{s} \in \mathbf{P}$ of the process $\mathbf{P}$ is
called a \emph{behavior} of the process $\mathbf{P}$. A particular tuple
of signals $\mathbf{s} \in S^N$ is said to \emph{satisfy} the process,
if it is one of its behaviors, i.e., $\mathbf{s} \in \mathbf{P}$.
A process $\mathbf{P}$ is \emph{synchronous} if
every pair of signals in the behaviour of the process is synchronous, i.e.,
$\forall{\mathbf{s} \in \mathbf{P} \subseteq S^N, (i_1,i_2) \in \{1,2,\ldots N\}^2}:
T(\pi{}_{i_1}(\mathbf{s})) = T(\pi{}_{i_2}(\mathbf{s}))$.

Two processes $\mathbf{P_1}$ and $\mathbf{P_2}$ can be composed into
a new composite process $\mathbf{Q}$, where
each behavior of the composite process is a behavior of its
component processes. Thus, composition can be defined as set intersection of
its component processes, i.e., $\mathbf{Q} = \mathbf{P_1} \cap \mathbf{P_2}$.
However, care has to be taken before forming such an intersection.
Each process to be composed must be defined as a subset of the same
set of signals. Cross product and projection are syntactic operations
used to transform the processes to achieve this goal. They play no
semantic role in composition.

Insert Example

Many processes have a concept of \emph{inputs}. The set of behaviors
a processes can show is constraint by its inputs.
% An input are events or signals which are specified by an external
% constraint and which must therefore be contained in every behaviour
% of a process coupled with this input.
\begin{sdefinition}
An \emph{input} to a process $\mathbf{P}$ is an externally
imposed contraint $\mathbf{I} \subset S^N$ such that
$\mathbf{I} \cap \mathbf{P}$ is the set of acceptable behaviours.
\end{sdefinition}
An input can assert the presence of a certain event $e = (t,v)$ in a signal,
e.g. $\mathbf{I} = \{\mathbf{s} | e \in \pi{}_{1}(\mathbf{s}) \}$.
But generally an input defines whole signals or set of signals.
Signals which are entirely defined externally are called \emph{input signals},
e.g. $\mathbf{I} = \{\mathbf{s} | s_i = \pi{}_{1}(\mathbf{s}) \}$, where
$\mathbf{s} = (s_1, s_2)$, $s_1$ is the input signal, and
$s_i$ is the value of the input signal $s_1$.

Insert Example

Some characteristics of processes can only be determined in combination with
its set of possible inputs $\mathbf{B} \subseteq 2^{S^N}$.
One such characteristic is the \emph{determinancy} of a process.
A process $\mathbf{P}$ is called \emph{determinate} with respect
to its set of possible inputs $\mathbf{B}$, if after being
constraint by its inputs, it consists of exactly one or exactly
no behaviors for each input $\mathbf{I} \in \mathbf{B}$,
i.e., $\forall{\mathbf{I} \in \mathbf{B}}: |\mathbf{P} \cap \mathbf{I}| \le 1$.
Otherwise the process is \emph{nondeterminate} with respect
to its set of possible inputs.

So far, a process contains no information which of the signals in its behaviors are
input signals and which are output signals. A \emph{input/output partition}
divides the signals in a behavior of a process into input signals and output signals.
\begin{sdefinition}
A \emph{input/output partition} $(I,O) \in (2^{\{1,2, \ldots N\}})^2$
of a process $\mathbf{P} \subseteq S^N$ is a pair of index sets,
where $I \cap O = \emptyset$ and $|I \cup O| = N$. The signals in
a behaviour on indexes in $I$ are input signals and the
signals on indexes in $O$ are output signals.
\end{sdefinition}
A Process $\mathbf{P} \subseteq S^N$ is called \emph{functional} with
respect to a input/output partition $(I,O)$ if for every pair of
behaviors of the process where the input signals are equal it follows,
that the output signals are equal,
i.e., $\forall{\mathbf{s_1} \in \mathbf{P}, \mathbf{s_2} \in \mathbf{P}}:
\pi{}_{I}(\mathbf{s_1}) = \pi{}_{I}(\mathbf{s_2}) \implies \pi{}_{O}(\mathbf{s_1}) = \pi{}_{O}(\mathbf{s_2})$.

% Timed MoCs are characterized by tags which are totally ordered.

\section{Aspect Overview}\label{aspect-overview}

A model of computation is defined in \cite{embsft:2002} as the
interaction policy between \emph{actors} in an \emph{actor-oriented} design
\cite{agha97abstracting:1997}. Actors are objects which execute concurrently. They can only
communicate with the environment (other actors) through their \emph{actor ports}.
The actor ports are connected with each other via \emph{channels}.
This concepts are related to tagged signal model in the following way:
(i) actors are processes with a predetermined input/output partition
(ii) actor ports are used to name signals and are equivalent to the position of signals in
a behavior of a process
(iii) channels are ??? .

% The data values, which are communicated over the channels
% are abstracted. Thus, these data are called \emph{tokens} regardless
% of their type or value.

Instead of a monolithic approach for representing an executable specification,
in this report, we will separate a specification into several
independent \emph{aspects}.
This is a refinement of actor-oriented design.
In actor-oriented design, actors only
communicate with each other via channels instead of method calls as known
in object-oriented design. In our proposed methodology, the specification is more
detailed than in actor-oriented design.
In particular, four different aspects for distinguishing MoCs can be identified,
namely \emph{node functionality}, \emph{node interface}, \emph{network graph}, and
\emph{channel kind}. An aspect can be further divided into
\emph{aspect types} by different constraints imposed on an aspect.
In the following, the aspects and their further
differentiation into aspect types is discussed in depth:

\subsection{Network Graph}\label{network-graph} 

To represent an executable specification, not only information about
individual actors but also information about the communication network,
which is the only means of communication between actors,
must be provided. Moreover, information about hierarchical
composition of actors is required. This information is stored in
the \emph{network graph}.

\begin{definition}
A network graph is a directed bipartite graph $G_N=(\mathcal{A},C,E)$ containing
a set of actors $\mathcal{A}$, a set of channels $C$, and a set of
directed edges $E \subseteq (C \times \mathcal{P}_I)
\cup (\mathcal{P}_O \times C)$, where
$\mathcal{P}_I = \bigcup{}_{A \in \mathcal{A}} A.I$
is the set of actor input ports of all actors in the network graph and
$\mathcal{P}_O = \bigcup{}_{A \in \mathcal{A}} A.O$
is the set of actor output ports of all actors in the network graph.
Each actor $A \in \mathcal{A}$ can only communicate with other actors
through its dedicated actor input ports $A.I$ and
actor output ports $A.O$.
Furthermore, the set of all actor input and actor output ports of all actors in
the network graph is given by $\mathcal{P} = \mathcal{P}_I \cup \mathcal{P}_O$ and
the set of all input and output ports of an actor is given by $\mathcal{P}_{A} = A.I \cup A.O$.

% A network graph is a 5-tuple $N=(\mathcal{A},C,P_{i},P_{o},E)$ containing
% a set of actors $\mathcal{A}$, a set of channels $C$, a set of uplevel
% input ports $P_{i}$, a set of uplevel output ports $P_{o}$ and a set of
% directed edges $E \subseteq ((P_{i} \cup C) \times \mathcal{A}_{P_{i}})
% \cup (\mathcal{A}_{P_{o}} \times (P_{o} \cup C))$, where
% $\mathcal{A}_{P_{i}} = \bigcup{}_{A \in \mathcal{A}} A_{P_{i}}$
% is the set of all actor input ports of the network graph and
% $\mathcal{A}_{P_{o}} = \bigcup{}_{A \in \mathcal{A}} A_{P_{o}}$
% is the set of all actor output ports of the network graph.
% Each actor $A \in \mathcal{A}$ can only communicate with other actors
% through its dedicated actor input ports $A_{P_{i}}$ and
% actor output ports $A_{P_{o}}$.
% Furthermore, the set of all input and output ports of an actor
% is given by $A_{P} = A_{P_{i}} \cup A_{P_{o}}$ and
% the set of all actor input and actor output ports of the network graph
% is given by $\mathcal{A}_{P} = \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}}$.

\end{definition}

There are two \emph{network graph types} which are distinguished in our methodology:

\begin{definition}\label{petri-network-graph}
  A \emph{Petri network graph} is constrained such that exactly
  one edge is incident to each actor port,
  i.e., $\forall{p \in \mathcal{P}}: |((\{p\} \times C) \cup (C \times \{p\})) \cap E| = 1$.
\end{definition}

\begin{figure}
\centering
%\includegraphics[scale=1]{ng-petri.\graphicPostfix}\\
\input{ng-petri-fig.tex}
\begin{displaymath}
\begin{array}{rcl}
  G_N & = & (\mathcal{A},C,E) \\
  \mathcal{A} & = & \{A_1,A_2,A_3,A_4\} \\
      &   & A_1.I = \emptyset, A_1.O=\{o_1,o_2\}, A_2.I = \{i_1,i_2\}, A_2.O=\{o_1\},\\
      &   & A_3.I = \{i_1,i_2\}, A_3.O=\{o_1\},A_4.I = \{i_1\}, A_4.O=\{o_1\}\\
  C   & = & \{c_1,c_2,c_3,c_4\} \\
  E   & = & \{(A_1.o_1,c_1),(c_1,A_2.i_1),(A_1.o_2,c_2),(c_2,A_2.i_2),(A_2.o_1,c_3),\\
      &   &   (c_3,A_3.i_1),(A_3.o_1,c_4),(c_4,A_3.i_2),(A_4.o_1,c_4),(c_4,A_4.i_1)\}\\
\end{array}
\end{displaymath}
\caption{\label{ng-petri}In a \emph{petri network graph} exactly
  one edge is incident to an actor port. Multiple edges can
  enter and leave a channel, e.g. channel $c_4$
  which has both an indegree and outdegree of two.}
\end{figure}

  An example of a petri network graph is shown in Figure~\ref{ng-petri}.
  It demonstrates the use of a petri network graph for modeling
  a Multiply-Accumulate-Unit which accumulates in channel $c_4$ the product of
  the values generated by the source actor $A_1$.
  The controller actor $A_4$ can replace the
  accumulated value in $c_4$ by using the nondeterminism
  of the petri network graph which allows to read/write the value of channel
  $c_4$ from different actors to either accumulate additional
  data via actor $A_3$ or exchange the value via actor $A_4$.

\begin{definition}\label{dataflow-network-graph}
  A \emph{Dataflow network graph} is a petri network graph with the additional constraint
  that the indegree and outdegree of each channel in the graph is exactly one, i.e.,
  $\forall{c \in C}: |(\{c\} \times \mathcal{P}_I) \cap E| = 1 \wedge
                    |(\mathcal{P}_O \times \{c\}) \cap E| = 1$.
\end{definition}

  An example of a dataflow network graph is shown in Figure~\ref{ng-dataflow}.
  It demonstrates the use of a dataflow network graph for modeling
  a Multiply-Accumulate-Unit which accumulates in channel $c_4$ or $c_5$ the product of
  the values generated by the source actor $A_1$.
  Additionally each token received by the duplicator actor $A_4$ via actor port $A_4.i_1$
  is forwarded to both actor output ports $A_4.o_1$ and $A_4.o_2$.
  Thus, the sink actor $A_5$ receives a copy of the accumulated value at
  each update of the accumulated value.

\begin{figure}
\centering
%\includegraphics[scale=1]{ng-dataflow.\graphicPostfix}\\
\input{ng-dataflow-fig.tex}
\begin{displaymath}
\begin{array}{rcl}
  G_N & = & (\mathcal{A},C,E) \\
  \mathcal{A} & = & \{A_1,A_2,A_3,A_4,A_5\} \\
      &   & A_1.I = \emptyset, A_1.O=\{o_1,o_2\}, A_2.I = \{i_1,i_2\}, A_2.O=\{o_1\},A_3.I = \{i_1,i_2\},\\
      &   & A_3.O=\{o_1\},A_4.I = \{i_1\}, A_4.O=\{o_1,o_2\}, A_5.I = \{i_1\}, A_5.O=\emptyset \\
  C   & = & \{c_1,c_2,c_3,c_4,c_5,c_6\} \\
  E   & = & \{(A_1.o_1,c_1),(c_1,A_2.i_1),(A_1.o_2,c_2),(c_2,A_2.i_2),(A_2.o_1,c_3),\\
      &   &   (c_3,A_3.i_1),(A_3.o_1,c_4),(c_4,A_4.i_1),(A_4.o_1,c_5),(c_5,A_3.i_2),\\
      &   &   (A_4.o_2,c_6),(c_6,A_5.i_1)\} \\
\end{array}
\end{displaymath}
\caption{\label{ng-dataflow} In a \emph{dataflow network graph} exactly
  one edge is incident to an actor port and the channels are
  constraint to have an indegree and outdegree of exactly one.
  Hence, the channels can only be used for dedicated
  Point-to-Point connections.}
\end{figure}

\subsection{Channel Kind}\label{channel-kind}

The \emph{channel kind} defines the communication semantics of a channel.
Since the communication semantics are not influenced by the
data type communicated, the actual \emph{type} of a communication
channel is derived from the channel kind by parameterizing it with
the type of the communicated data. Examples for channel kinds are:

\begin{itemize}
\item \label{channel-kind-fifo} FIFO:
  An unbound FIFO channel for communication
  (nonblocking write and blocking read) implementing
  an first in first out discipline.

\item \label{channel-kind-rendezvous} Rendezvous:
  A rendezvous channel for communication % and barrier synchronisation
  (blocking write and read).

\item \label{channel-kind-register} Register:
  For expressing communication via shared variables
  (nonblocking write and nonblocking read).
\end{itemize}

\subsection{Node Functionality}\label{node-functionality}

In our methodology proposed in this report, the actor concept is still used,
but we distinguish two different aspects.
The first part called \emph{node functionality} is responsible
for transforming data values. The node functionality can be
thought of as a function $F: V^{m} \to V^{n}, F \in \mathcal{F}$  which maps a fixed
number of inputs to a fixed number of outputs. The node functionality
can be implemented by any programming language but
the user must guarantee, that the node functionality (i) terminates,
and (ii) does not communicate with other actors.
The node functionality is the only aspect which is not
further distinguished into aspect types.

\subsection{Node Interface}\label{node-interface}

The second part of an actor which determines its communication
behavior is called \emph{firing rules}. The firing rules
determine for each actor port the number of tokens to receive or send
until the associated node functionality can be invoked.

%\begin{definition}\label{firing-rules}
%A firing rules $s \in S$ is a tuple $(Q_{s}, F_{s})$ containing
%a subset of activation patterns $Q_{s} \subseteq Q$, and
%an action selection function $F_{s}: Q_{s} \to \mathcal{T}$ which
%maps each activation pattern $q \in Q_{s}$ to a corresponding
%interface action $T_{sq} \in \mathcal{T}$.
%\end{definition}

\begin{definition}\label{activation-pattern}
An \emph{activation pattern} is a function $q: A_{P} \to N_0,\ q \in Q$
which maps each actor port to a non-negative integer.
The activation pattern is enabled if for each actor input port
$a_{p} \in A_{P_{i}}$ at least $q(a_{p})$ tokens are available
and for each actor output port
$a_{p} \in A_{P_{o}}$ at least $q(a_{p})$ tokens have been
transmitted.
\end{definition}

\begin{definition}\label{interface-action}
An \emph{interface action} is a tuple $J = (F,S_{succ}),\ J \in \mathcal{J}$ containing
a node functionality $F \in \mathcal{F}$, and a set of successor states $S_{succ}$ containing at least
one state $|S_{succ}| \ge 1$.
\end{definition}

\begin{definition}\label{interface-transition}
An \emph{interface transition} is a tuple $T = (q,J), T \in \mathcal{T}$ containing
an activation pattern $q \in Q$ and an interface action $J in \mathcal{J}$.
A transition is enabled if its corresponding activation pattern $q$ is enabled.
If the associated interface action has only one successor state $|J.S_{succ}| = 1$, the
transition is called a \emph{deterministic transition}.
If more than one successor state is associated in $J.S_{succ}$, the
transition is called a \emph{conflict transition}. What state $s \in J.S_{succ}$
is actually used is a runtime decission of the node functionality $J.F$.
\end{definition}

\begin{definition}\label{firing-rules}
\emph{Firing rules} is a 5-tuple $M_{F} = (S, Q, \mathcal{J}, k, s_0)$ containing
a set of \emph{firing states} $S$, a set of activation patterns $Q$,
a set of interface actions $\mathcal{J}$, an action selection function
$k: S \times Q \to \mathcal{J} \cup \bot$,
and a initial state $s_0 \in S$. An actor is inactive until at least
one activation pattern $q$ is enabled which has a corresponding
interface action in the current firing state $s \in S$ of the actor,
i.e., $\exists{q \in Q}: k(s,q) \ne \bot \wedge q\ \mathrm{is\ enabled}$.
The set of ready activation patterns is given by $Q_{ready}$.
Exactly one activation pattern $q \in Q_{ready}$ will be
chosen nondeterministically and its corresponding interface action
$k(s,q)$ will be executed.
\end{definition}

These firing rules are constructed by use of the following operations:

\begin{itemize}
\item branch

\emph{Branch} is a operation which maps a node functionality $F$ and
a none empty set of firing state $S_{B} \ne \emptyset$ to an interface action $J$,
i.e., $\mathrm{Call}: \mathcal{F} \times 2^S \to \mathcal{J}$.
If the resulting interface action $J$ is included into a
firing state $s_{c}$ it permits to create a conflict transition
in the firing rules.
\item call

\emph{Call} is a operation which maps a node functionality $F$ and
a firing state $s$ to an interface action $J$,
i.e., $\mathrm{Call}: \mathcal{F} \times S \to \mathcal{J}$.
If the resulting interface action $J$ is included into a
firing state $s_{c}$, it corresponds to a deterministic transition
in the firing rules from the state $s_{c}$ to state $s$.
Furthermore, the call operation is clearly a subset of the
branch operation.

\item transition

\emph{Transition} is a operation which maps an activation pattern $q$ and
an interface action $J$ to an interface transition $T$,
i.e., $\mathrm{Transition}: Q \times \mathcal{J} \to \mathcal{T}$.

\item choice

\emph{Choice} is a operation which maps a set of interface transitions $\mathcal{T}$
to a firing state $s$,
i.e., $\mathrm{Choice}: 2^{\mathcal{T}} \to S$.
The firing state created by this operation can have multiple outgoing
transitions.

\item transact

\emph{Transact} is a operation which maps an interface transition $T$
to a firing state $s$,
i.e., $\mathrm{Transact}: \mathcal{T} \to S$.
The firing state created by this operation has only one outgoing
transition $T$. Furthermore, the transact operation is clearly a subset of the
choice operation.
\end{itemize}

The set of operations available to construct the firing rules constraints
the type of firing rules that can be constructed.
Our methodology distinguishes three separate \emph{node interface types}
by the set of operations available to them:

\begin{definition}\label{choice-node-interface-type}
Choice node interface provides the operations
\emph{transition}, \emph{choice}, \emph{transact}, \emph{call} and \emph{branch}.
\end{definition}

\begin{definition}\label{transact-node-interface-type}
Transact node interface provides the operations
\emph{transition}, \emph{transact}, \emph{call} and \emph{branch}.
\end{definition}

\begin{definition}\label{fixed-transact-node-interface-type}
Fixed transact node interface provides only the operations
\emph{transition} and \emph{call}.
\end{definition}

% \emph{Choice} is an operation defined on a set of actor ports $A_{P}$
% and a function $D: A_{P} \to \mathcal{F}$, which maps each actor port
% $a_{p} \in A_{P}$ to a function $F_{x} \in \mathcal{F}$.
% The choice operation postpones the process execution 
% until at least one actor port $a_{p} \in A_{P}$
% becomes ready to communicate. The set of actor ports available
% is given by $A_{P_{ready}}$.
% Exactly one actor port $a_{p} \in A_{P_{ready}}$
% will be chosen nondeterministically. After
% finishing the communication on the chosen actor port $a_{p}$
% the process execution will continue
% with function $F_{continue} = D(a_{p})$.

\section{Revision of Different MoCs}\label{revision-of-mocs}

The \emph{characteristics} of different MoCs can be separated into two distinct groups.
There are the \emph{execution characteristics} which must be provided by
the programming system otherwise the MoC cannot be implemented.
On the other hand, there are the \emph{analysis characteristics} which
permit the extraction of information needed for MoC-Specific analysis.

In the following subsections, different MoCs are considered and their
characteristics are determined. For each MoC these characteristics are
mapped onto the aspects presented in the previous Section.

\subsection{Communicating Sequential Processes (CSP)}
\emph{Communicating Sequential Processes} \cite{csphoare:1985}
is a MoC which consists of concurrently executing processes
which communicate via unidirectional \emph{rendezvous channels}.
As a difference to the CSP model of Hoare \cite{csphoare:1985}
which allows runtime creation of processes via parallel
composition and recursion, the CSP model considered in this report
is constraint to a fixed predetermined set of processes.
This constraint is required to allow hardware synthesis from this
model.

The following characteristics are the execution characteristics to
implement CSP behavior:

\begin{characteristic}\label{characteristic-csp-rendezvous}
  Rendezvous channel for communication
\end{characteristic}

\begin{characteristic}\label{characteristic-csp-general-choice}
  A communication method for Hoare's so-called \emph{general choice}
  
  General choice written $ce_{1} \to F_1 \Box ce_{2} \to F_2$
  is a operation defined on a set of \emph{channel expressions} $CE$ and
  a function $D: CE \to \mathcal{F}$, which maps each channel expression
  $ce \in CE$ to a function $F \in \mathcal{F}$. A channel
  expression can either send the content of a variable $v$ to
  a channel $c$ which is written $c!v$ or receive a value from
  a channel $c$ and store it in variable $v$ which is written
  $c?v$. A channel expression is ready to communicate when its
  associated channel is ready to communicate.
  The general choice operation postpones the process execution 
  until at least one channel expression $ce \in CE$
  becomes ready to communicate. The set of channel expressions
  ready to communicate is given by $CE_{ready}$.
  Exactly one channel expression $ce \in CE_{ready}$
  will be chosen nondeterministically. After
  finishing the communication for the chosen channel expression $ce$
  the process execution will continue
  with function $F_{continue} = D(ce)$.

\end{characteristic}

\begin{characteristic}\label{characteristic-csp-concurrent-processes}
  Fixed set of concurrently executing processes
  
  The CSP \emph{parallel composition} operation written $F_1 \| F_2$ executes the
  function $F_1$ and $F_2$ in parallel and terminates when both functions
  have terminated. By using recursion and parallel composition
  like $X = F_1 \| X$, CSP enables unlimited runtime creation of processes.
  Our CSP MoC only allows a fixed static number of processes. This
  leads to the constraint that only CSP programs can be represented which
  have a single init function which must not be called recursively. This init
  function creates all processes needed in the CSP program via parallel composition.
  Other functions in the CSP program must not use the parallel composition
  operation.
\end{characteristic}

%\item Sequential composition of functions
%  
%  Sequential composition written $F_1 \to F_2 \to F_3 \to \cdots$
%  is 
% $\to$ is sequential composition

In the following, a CSP program for the well known dining
philosophers problem is demonstrated. To reduce the complexity
of the example the number of philosophers has been reduced
to two. Each philosopher has only two goals in life, namely to think and
to eat. Food is provided by a bowl of spaghetti on the table and
two forks for eating. To eat, each philosopher has to take a seat
at the table and take two forks which he will not release until he
is no longer hungry. As anybody knows this can lead to a deadlock.
This deadlock can can be eliminated by a footman which will only
allow philosopher to take a seat at the table if there are more
forks than philosophers at the table (See Figure~\ref{fig:dining-philosophers}
for the processes and connection topology used in the example).
The implementation demonstrates the use of the general choice operator
in the $Footman$ and the $Fork_{x}$ which are used to react to the first
philosopher requesting something from footman or fork.

\begin{figure}[h]
\centering
\input{dining-philosophers-fig.tex}
\caption{Processes and connection topology used for the ``Dining philosophers'' CSP example}
\label{fig:dining-philosophers}
\end{figure}

\begin{displaymath}
\begin{array}{rcl}
Philosopher_{i}    & := & FootSit_{i}!sit \to ForkReqL_{i}!take \to ForkReqR_{i\oplus1}!take \to \\
                   &    & Eat \to \\
                   &    & ForkReqL_{i}!drop \to ForkReqR_{i\oplus1}!drop \to FootStand_{i}!stand \to \\
                   &        & Philosopher_{i} \\
Fork_{i}           & := & ForkReqR_{i}?req_{r} \to ForkReqR_{i}?req_{r} \to Fork_{i} \Box \\
                   &    & ForkReqL_{i}?req_{l} \to ForkReqL_{i}?req_{l} \to Fork_{i} \\
Footman                   & := & FootSit_{0}?req_{0} \to FootStand_{0}?req_{0} \to Footman \Box \\
                   &    & FootSit_{1}?req_{1} \to FootStand_{1}?req_{1} \to Footman \\
InitFunction       & := & Philosopher_{0} \| Fork_{0} \| \\
                   &    & Philosopher_{1} \| Fork_{1} \| \\
                   &    & Footman \\
\end{array}
\end{displaymath}

Where $\oplus$ is addition modulo 2 and $\to$ has higher precedence than $\Box$.

To facilitate analysis of the CSP MoC, additionally the following
analysis characteristics must be given:
\begin{characteristic}\label{characteristic-csp-communication}
  Parallel executing processes must only communicate over Point-to-Point rendezvous channels.
\end{characteristic}

The characteristics \ref{characteristic-csp-rendezvous} -
\ref{characteristic-csp-communication} of the CSP MoC are mapped in the following way
onto the aspects presented in Section~\ref{aspect-overview}:
(i) The rendezvous communication %(Requirement~\ref{characteristic-csp-rendezvous})
used by CSP is provided by the channel kind rendezvous. %(See~\ref{channel-kind-rendezvous})
(ii) Hoare's general choice communication operator %(Requirement~\ref{characteristic-csp-general-choice})
is provided as a operation in the choice node interface. %(See~\ref{choice-node-interface-type})
(iii) The parallel executing processes %(Requirement~\ref{characteristic-csp-concurrent-processes})
created by the init functions are mapped to the concurrently executing actors.
%% (Subsection~\ref{node-functionality} and Subsection~\ref{node-interface})
(iv) The Point-to-Point communication of CSP over rendezvous channels %(Requirement~\ref{characteristic-csp-communication})
is provided by the dataflow network graph %(See~\ref{dataflow-network-graph})
and its contained rendezvous channels, which are the only means of communication in a
actor-oriented design.

\subsection{Kahn Process Network (KPN)}
\emph{Kahn Process Network} \cite{kahn:1974} is a MoC
which consists of a fixed predetermined set of
concurrently executing processes which communicate via unidirectional
unbounded \emph{FIFO channels}. The input and output of a channel
are connected to dedicated processes. The process must implement
a continuous function $F: S^m \to S^n$ regarding a prefix order on
$S^m$ and $S^n$ \cite{kahn:1974,stark87concurrent:1987}.
Where $S^m$ is a $m$-tuple of token sequences on the process input channels
and $S^n$ is a $n$-tuple on token sequences on the process output channels.
If the communication over FIFO channels is realized with blocking
reads and nonblocking writes the previous requirement is automatically
satisfied \cite{stark87concurrent:1987}. However, the next channel
selected for a FIFO read or write operation can dependent on
the data values already read and the state of the actor.

% connected to the process of the process actor input
% port a number of tokens dependent on the port and the state
% of the actor must be available.
% Two closely related
% forms of dataflow are distinguished in the literature \cite{LeeDenotialDF:1997},
% Kahn Process Networks \cite{kahn:1974}, in the following 
% called KPN, and Dennis Dataflow \cite{}, in the following
% called DDF. DDF is an extension of KPN by the notion of
% firing. To enable firing of a DDF process each channel $c \in C$
% used as input by the process must have a certain number of
% tokens 

The following execution characteristics are required to
implement the KPN MoC:

\begin{characteristic}\label{characteristic-kpn-fifo}
  An unbound FIFO channel for communication
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-fifo-read-write}
  A communication method to read from and write to FIFOs
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-concurrent-processes}
  Fixed set of concurrently executing processes
\end{characteristic}

In the following, an example KPN program for audio coding
is demonstrated. For the audio encoding an algorithm
adapted for multimedia audio or an algorithm adapted for speech
is dynamically selected depending on the input audio stream.
The CodecSelect actor forwards the raw audio stream to the
selected audio codec and gets feedback of the codec quality
via the corresponding CodecQuality channel. If a certain
limit for the codec quality is not satisfied the CodecSelect will
switch to the other audio codec. Additionally the CodecSelect actor
signals the StreamPacketizer via the PacketizerCodecSelect channel
which EncodedAudio channel must be chosen for input data to packetize.
(See Figure~\ref{fig:media-speech-audio-coding}
for the processes and connection topology used in the example):

\begin{figure}[h]
\centering
\input{media-speech-audio-coding-fig.tex}
\caption{Processes and connection topology used for the audio encoding KPN example}
\label{fig:media-speech-audio-coding}
\end{figure}

To facilitate analysis of the KPN MoC additionally the following
characteristics must be satisfied:
\begin{characteristic}\label{characteristic-kpn-communication}
  Parallel executing processes must only communicate over Point-to-Point FIFO channels.
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-determinism}
  The process must implement a continuous function $F: S^m \to S^n$
\end{characteristic}

The characteristics \ref{characteristic-kpn-fifo} -
\ref{characteristic-kpn-determinism} of the KPN MoC are mapped in the following way
onto the aspects presented in Section~\ref{aspect-overview}:
(i) The FIFO communication
used by dataflow is provided by the FIFO channel kind.
(ii) The fixed set of concurrently executing processes
are mapped to the concurrently executing actors.
(iii) The Point-to-Point communication of dataflow over FIFO channels
is provided by the dataflow network graph
and its contained FIFO channels, which are the only means of communication in a
actor-oriented design.
(iv) Read and write operations on this FIFOs are provided by
the transact operation of the transact node interface.
(v) The requirement for a continuous function is satisfied by using the
transact operation of the transact node interface.
The transact operation consumes and produces
a determined number of tokens on the actor ports
depending on the current state of the actor.
The node functionality must be deterministic, too.
Therefore the actor implements a function regarding the
prefix order on $S^m$ and $S^n$. Because the
transact functions does not allow canceling of already
written output of actor output ports, the functions is
\emph{monotonic}. Fortunately, this means in practice
that the function is also \emph{continuous} since practical monotonic
processes are invariably continuous, at least in the context
of Kahn process networks \cite{LeeDenotialDF:1997}.

\subsection{Synchronous Dataflow (SDF)}
Synchronous Data Flow \cite{Lee87b:1987} is a more constricted form of the
KPN MoC. It has all the characteristic of the KPN MoC and additionally the
following characteristic necessary for MoC analysis.

\begin{characteristic}\label{characteristic-sdf-fixed-rates}
The consumption and production rates of the actor must be constant.
In particular they are independent from the state of the actor.
\end{characteristic}

In the following, an example of a Multiply-Accumulate-Unit for stereo signals is given
as a SDF system. The unit reads two tokens from input $in_1$,
performs a multiplication for both tokens with a value read from $in_2$,
and accumulates the results in the channels $c_2$ and
$c_3$. The accumulated values are written to $o_1$ for each
token pair received on $in_1$.
In Figure~\ref{fig:sdf-mac-unit},
the constant consumption and production rates of the SDF
MoC are annotated at the actor input and output ports
respectively.

\begin{figure}[h]
\centering
\input{sdf-mac-unit-fig.tex}
\caption{Processes and connection topology used for a stereo signal MAC
  unit implemented in the SDF MoC}
\label{fig:sdf-mac-unit}
\end{figure}

The characteristics \ref{characteristic-kpn-fifo} -
\ref{characteristic-sdf-fixed-rates} of the SDF MoC are mapped in the following way
onto the aspects presented in Section~\ref{aspect-overview}: (i) - (iii) is identical
to the KPN MoC.
(iv) Read and write operations on the FIFOs are provided by the transact
operation of the fixed transact node interface.
(v) The constant consumption and production rates of the actor are
guaranteed by the fixed transact node interface which does
not allow the alteration of these rates once set.

\section{Software Architecture}\label{software-architecture}

Due to its high abstraction level and its capabilities in both,
hardware and software refinement, we have chosen SystemC
\cite{systemc-lrm:2003,glms:2002} as our platform for system design.
SystemC is an actor-oriented C++-Based design language and
already allows to express dataflow MoCs.

In the following, we propose a SystemC framework, called \SysteMoC, which
facilitates automatic extraction of a MoC from a SystemC design.
Actors in SystemC are C++ classes which are derived from the base class \code{sc\_module}.
The \SysteMoC{} framework provides the execution requirements for each MoC while
still supporting the extraction of the information needed for analysis.
This analysis is made possible by dividing the actor into its
node functionality and its node interface.
Furthermore, the \SysteMoC{} framework provides a way for these
actors to be connected to each other. This connections
are provided by the network graph.
%Actors can have their own thread of control or be without. Actors
%with their own thread of control will be called in the following
%active actors and actors without a dedicated thread of control
%passive actors.

\subsection{Node Functionality}
The node functionality is only used for algorithmic transformations of data values.
The node functionality of an actor is defined in certain member functions,
which are called by the firing rules when their requirements for input data is fulfilled.
This member functions are not allowed to call communication operations. All required
input and output data values are read from
and written to the actor ports. All actor ports are globally accessible
by the actor member functions and can be used to get input data
and put output data for the node functionality
(See Figure~\ref{example-adder-actor} and Figure~\ref{example-multiply-actor}
 for an example of a node functionality encapsulated in the method \code{transform}).

\begin{figure}[h]
\centering
\begin{verbatim}
template <typename T>
class m_adder // Actor m_adder
  : public hscd_fixed_transact_node // Node interface
{
public:
  hscd_port_in<T>  in;
  hscd_port_out<T> out;
private:
  // Node functionality
  void transform() {
    out[0] = in[0] + in[1];
    std::cout << "Adding " << in[0] << " + " << in[1]
              << " = " << out[0] << std::endl;
  }
public:
  m_adder( sc_module_name name )
    :hscd_fixed_transact_node( name,
        (in(2) & out(1)) >> call(transform) /* Firing rules */ ) {}
};
\end{verbatim}
\caption{\label{example-adder-actor}Example of an adder in the \SysteMoC{} framework}
\end{figure}

\begin{figure}[h]
\centering
\begin{verbatim}
template <typename T>
class m_multiply // Actor m_multiply
  : public hscd_fixed_transact_node // Node interface
{
public:
  hscd_port_in<T>  in1;
  hscd_port_in<T>  in2;
  hscd_port_out<T> out;
private:
  // Node functionality
  void transform() {
    out[0] = in1[0] + in2[0];
    std::cout << "Multiplying" << in1[0] << " * " << in2[0]
              << " = " << out[0] << std::endl;
  }
public:
  m_multiply( sc_module_name name )
    :hscd_fixed_transact_node( name,
        (in1(1) & in2(1) & out(1)) >> call(transform) /* Firing rules */ ) {}
};
\end{verbatim}
\caption{\label{example-multiply-actor}Example of a multiplier in the \SysteMoC{} framework}
\end{figure}

%\begin{figure}
%\centering
%\begin{verbatim}
%template <typename T>
%class m_adder // Actor m_adder
%  : public hscd_fixed_transact_node // Node interface
%{
%public:
%  hscd_port_in<T>  in;
%  hscd_port_out<T> out;
%private:
%  // Node functionality
%  void transform() {
%    out[0] = in[0] + in[1];
%    std::cout << "Adding " << in[0] << " + " << in[1]
%              << " = " << out[0] << std::endl;
%  }
%  
%  // Firing rules
%  void process() {
%    while (true) {
%      transform();
%      transact();
%    }
%  }
%public:
%  m_adder( sc_module_name name )
%    :hscd_fixed_transact_node( name,
%        in(2) & out(1) /* Firing rules */ ) {}
%};
%\end{verbatim}
%\caption{\label{example-adder-actor}Example of an adder in the \SysteMoC{} framework}
%\end{figure}

%\begin{figure}
%\centering
%\begin{verbatim}
%template <typename T>
%class m_multiply // Actor m_multiply
%  : public hscd_fixed_transact_node // Node interface
%{
%public:
%  hscd_port_in<T>  in1;
%  hscd_port_in<T>  in2;
%  hscd_port_out<T> out;
%private:
%  // Node functionality
%  void transform() {
%    out[0] = in1[0] + in2[0];
%    std::cout << "Multiplying" << in1[0] << " * " << in2[0]
%              << " = " << out[0] << std::endl;
%  }
%  
%  // Firing rules
%  void process() {
%    while (true) {
%      transform();
%      transact();
%    }
%  }
%public:
%  m_multiply( sc_module_name name )
%    :hscd_fixed_transact_node( name,
%        in1(1) & in2(1) & out(1) /* Firing rules */ ) {}
%};
%\end{verbatim}
%\caption{\label{example-multiply-actor}Example of a multiplier in the \SysteMoC{} framework}
%\end{figure}

\subsection{Node Interface}
The problem of extracting the communication behavior of an actor is caused
by the fact, that the communication methods in SystemC are all accessible
to all SystemC modules. Moreover, execution of these methods is controlled
by the Turing complete coding possibilities in the actor. To remedy these
problems, we prohibit any method calls on \SysteMoC{} channels
by the node functionality. Moreover,
communication over other media than \SysteMoC{} channels is forbidden.
Unfortunately this cannot be strictly enforced. Hence, we require the \SysteMoC{} user
to assure that the node functionality does terminate and does not
directly communicate with other actors omitting the \SysteMoC{} channels.

After prohibiting any form of communication by the node functionality we,
instead introduce firing rules which is a state machine which determines
the communication behavior of an actor. However some MoCs, e.g. KPN, need
a Turing complete control of their communication behavior. To
accomodate this, we again allow the node functionality to indirectly
influence the communication behavior via a conflict transition
created by the branch operation. Clearly this is undesirable for more
constrainted MoCs. Therefore, we have to distinguish firing rules into
different categories which allow or disallow such possibilities. We
distinguish firing rules into these categories by the operations we
support for constucting them. These operations are provided by the
node interface which is a base class of the actor. Therefore the
type of firing rules possible for an actor is determined by the
node interface type from which the actor is derived.

%The following subset of the requirements enumerated in Section~\ref{revision-of-mocs}
%determines the node interface of the corresponding MoCs:

The set of operations available for each node interface type
build a hierarchy of decreasing execution capabilities and
correspondingly increasing analysis capabilities.
The choice node interface is the most powerful in this hierarchy.
Next is the transact node interface, and finally the last powerful is the
fixed transact node interface. This can also be clearly seen
by observing the operations available to node interface types.
Less powerful node interface types provide a strict subset of
the operations available on higher levels in the hierarchy.
How these execution and analysis capabilities map to some transformative
MoCs has been presented in Section~\ref{revision-of-mocs}.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{NodeInterfaceHierarchy.\graphicPostfix}\\
\caption{\label{node-interface-hierarchy}Node interface hierarchy as UML}
\end{figure}

The hierarchy of the node interface types is transformed into
a C++ inheritance hierarchy which can be seen in Figure~\ref{node-interface-hierarchy}.
The node interface types are mapped to C++ class types as follows:
(i) The choice node interface is represented by the \code{hscd\_choice\_node} class.
(ii) The transact node interface is represented by the \code{hscd\_transact\_node} class.
(iii) The fixed transact node interface is represented by the \code{hscd\_fixed\_transact\_node} class.
Operations which are no longer available for node interface types
at lower levels inthe hierarchy are disabled by declaring them to be private.

%\begin{enumerate}
%\item Choice Node
%  \begin{itemize}
%  \item  A communication method which implements Hoare's 'general choice' operator \cite{csphoare:1985}.
%  \end  {itemize}
%\item Transact Node
%  \begin{itemize}
%  \item A communication method to read from and write to ports.
%  \item Assurance that the arrival sequence of tokens at
%        their ports cannot be determined.
%  \end  {itemize}
%\item Fixed Transact Node
%  \begin{itemize}
%  \item A communication method to read from and write to ports.
%  \item Assurance that the arrival sequence of tokens at
%        their ports cannot be determined.
%  \item Assurance that consumption and production rates cannot
%        be altered once set
%  \end  {itemize}
%\end{enumerate}
%
%\begin{enumerate}
%\item CSP
%  \begin{itemize}
%  \item  \code{choice( a(1) $\arrowvert$ b(2) )}
%
%    This communication operation gets a list of actor ports (e.g. $a$, $b$) which
%    are parameterized with the number of tokens that must be communicated
%    over the port. The operations communicates over that actor port which is first ready
%    for communication. If no port is ready for communication the operation blocks until
%    at least one port is ready. Should more than one actor port be ready for
%    communication at the same instance one of them is chosen nondeterministically.
%  \end  {itemize}
%\item KPN
%  \begin{itemize}
%  \item \code{transact( a(1) \& b(2) )}
%
%    This communication operation gets a list of actor ports (e.g. $a$, $b$) which
%    are parameterized with the number of tokens that must be communicated
%    over the port. The operations blocks until all requested tokens on the ports
%    have been communicated.
%  \end  {itemize}
%\item SDF
%  \begin{itemize}
%  \item \code{transact(), hscd\_fixed\_transact\_node( ..., a(1) \& b(2) )}
%
%    Actors are C++ classes which are derived of their node interface class.
%    The consumption and production rates for SDF Actors must be fixed, therefore
%    the node interface of a SDF-Actor is parameterized with the consumption and production
%    rates of the SDF-Actor (See actor constructor in Figure~\ref{example-multiply-actor} for an
%    example of fixed consumption and production rates). The communication operation \code{transact} is
%    therefore missing the port list which is available to KPN nodes.
%  \end  {itemize}
%\end{enumerate}

%(See Table~\ref{node-interface-c++} for mapping of the node interface types to their
%corresponding C++ class types).
%To partially remedy these problems we introduced the node interface aspect
%which determines what communication methods are available to an actor.

%\begin{table}
%\centering
%\begin{tabular}{|l|l|}
%\hline
% Node interface & \SysteMoC{} node interface type \\
%\hline \hline
% Choice Node          & \code{hscd\_choice\_node} \\
% Transact Node        & \code{hscd\_transact\_node} \\
% Fixed Transact Node  & \code{hscd\_fixed\_transact\_node} \\
%\hline
%\end{tabular}
%\caption{\label{node-interface-c++}Node interfaces represented as \SysteMoC{} classes}
%\end{table}

\subsection{Network Graph Type}

To complete an executable specification in \SysteMoC{}, beside
the information about the actors, additionally information about the connections
of the actors with each other is needed. This information is stored
in the network graph of the executable specification, which can
be categorized into two different network graph types as defined in
Subsection~\ref{network-graph}.

The network graph is represented by a user provided C++ class, in the following called
network graph class. This class is derived from a \SysteMoC{} graph type class which
provides the methods needed to assemble the network graph in the constructor
of the network graph class. Once the constructor has finished the network graph must
be fully assembled. No alteration at a later date is allowed.
The methods provided by the \SysteMoC{} graph type class together with runtime checks
in these methods constrain the constructed network graph to conform to the corresponding
network graph type.
Therefore, the network graph type of a network graph can be determined by looking
at the base class of the network graph class.
The network graph types are mapped to C++ class types as follows:
(i) The petri network graph is represented by the \code{hscd\_graph\_petri} class.
(ii) And the dataflow network graph is represented by the \code{hscd\_graph\_dataflow} class.
Of the two network graph types the dataflow network graph is the more constraint
one. Therefore, it is implemented by deriving from the petri network graph
and disabling by declaring private the \code{registerChan} and \code{connectChanPort}
methods which allow the creation of channels with multiple indegree and outdegree.
This hierarchy is shown in Figure~\ref{network-graph-hierarchy}.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{NetworkGraphHierarchy.\graphicPostfix}\\
\caption{\label{network-graph-hierarchy}UML inheritance hierarchy of the network graph types}
\end{figure}

To construct the network graph the following methods are available for
composition of a network graph of the desired type:

\begin{enumerate}
\item Petri network graph

  \begin{itemize}
  \item registerNode:
    This method is used to add one actor $A$ to the set of actors $\mathcal{A}$
    of the network graph.

  \item registerChan:
    This method is used to add one channel $c$ to the set of channels $C$
    of the network graph. This functions takes an optional parameter which can
    be used to specify the initial state of the new channel, which is
    for example used for the count of initial tokens of a FIFO channel.

  \item connectChanPort:
    This method adds one edge $e \in C \times \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}} \times C$
    between channels and actor ports to the network graph.

  \item connectInterfacePorts
    This method adds one edge $e \in P_{i} \times \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}} \times P_{o}$
    between actor ports and uplevel ports to the network graph.

  \end{itemize}

\item Dataflow network graph

  \begin{itemize}
  \item registerNode: Same method as defined for petri network graphs.
  
  \item connectInterfacePorts: Same method as defined for petri network graphs.
  
  \item connectNodePorts:
    This method is a shorthand for adding one channel and
    connecting two actor ports via this channel. Only channels
    which are connected to a dedicated output actor port and
    a dedicated input actor port can be realized with it.
    This method takes an optional parameter which fulfils
    the same function as the parameter for method registerChan.
  
  \end{itemize}

\end{enumerate}

%\begin{table}[h]
%\centering
%\begin{tabular}{|l|l|}
%\hline
% Network graph type   & \SysteMoC{} graph type class \\
%\hline \hline
% Petri Choice Node    & \code{hscd\_graph\_petri} \\
% Transact Node        & \code{hscd\_graph\_sdf} \\
%\hline
%\end{tabular}
%\caption{\label{network-graph-c++}Network graph types represented as \SysteMoC{} classes}
%\end{table}

\subsection{Channel Kind}

SystemC is an actor-oriented design language, i.e., it supports the concept
of actors and channels. The channel kind aspect of the \SysteMoC{}
framework can cleanly be implemented as a base class of a channel in SystemC.
The channel kind determines the communication semantics of a channel but
makes no assumptions about the data type of the tokens.
The channel type is a template parameterized
with the data type for the tokens and derived from the channel kind.
Identifying the channel kind with a base class instead of a template enables
easier type signature checks of C++ for the enforcement of a particular
channel kind of a channel instance.

Further differences between \SysteMoC{} channels and SystemC channels are the
absence of user callable methods for communicating on the \SysteMoC{} channels.
Providing those communication methods on the channels would contradict the separation
of node interface and channel kind. The mapping of channel kind to corresponding C++
class types is as follows:
(i) The fifo channel kind is represented by the \code{hscd\_fifo\_kind} class.
(ii) And rendezvous channel kind is represented by the \code{hscd\_rendezvous\_kind} class.

%\begin{table}
%\centering
%\begin{tabular}{|l|l|}
%\hline
% Channel kind & \SysteMoC{} type \\
%\hline \hline
% FIFO         & \code{hscd\_fifo\_kind} \\
% Rendezvous   & \code{hscd\_rendezvous\_kind} \\
%\hline
%\end{tabular}
%\caption{\label{channel-kind-c++}Channel kinds represented as \SysteMoC{} classes}
%\end{table}

\subsection{Constraint Set Composition for MoCs}

In Section~\ref{revision-of-mocs} we have demonstrated how
to map the requirements of some MoCs to the aspects presented
in Section~\ref{aspect-overview}. Furthermore, the analysis
requirement of these MoCs translate into certain constraints
on the aspects presented before. These constraints are
used to distinguish an aspect into aspect types. Therefore
for each MoC presented in Section~\ref{revision-of-mocs}
we have a set of aspect types, called \emph{constraint set}.
Predefined constraint sets supported by \SysteMoC{} are
shown in Table~\ref{constraintset-composition}.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
 Channel kind & Node interface & Network graph type & Constraint set \\
\hline \hline
 Fifo         & Fixed Transact node & Dataflow network graph & SDF constraint set \\
 Fifo         & Transact node       & Dataflow network graph & Dataflow constraint set \\
%% Fifo         & Choice node         & Dataflow network graph & FIFO CSP constraint set \\
 Rendezvous   & Choice node         & Dataflow network graph & CSP constraint set \\
\hline
\end{tabular}
\caption{\label{constraintset-composition}
  Composition of constraint set out of channel kind type, node interface type
  and network graph type}
\end{table}

The aspect types in the constraint set are node interface,
channel kind and network graph. The node interface and
and channel kind are represented as \SysteMoC{} classes in
SystemC, the network graph is represented as
a C++ template in \SysteMoC{}. Parameterizing this template
with the channel kind and node interface (As shown in
table~\ref{constraintset-c++}) leads to a C++
type which represents the constraint set in \SysteMoC{}.

\begin{table}[h]
\centering
\begin{tabular}{|l|p{6cm}|l|}
\hline
 Constraint set & Composition in C++ & \SysteMoC{} constraint set type \\
\hline \hline
 SDF constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_fixed\_transact\_node, hscd\_fifo\_kind$>$} &
  \code{hscd\_sdf\_constraintset} \\
\hline
 Dataflow constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_transact\_node, hscd\_fifo\_kind$>$} &
  \code{hscd\_df\_constraintset} \\
\hline
 CSP constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_choice\_node, hscd\_rendezvous\_kind$>$} &
  \code{hscd\_csp\_constraintset} \\
\hline
\end{tabular}
\caption{\label{constraintset-c++}Constraint sets represented as \SysteMoC{}
  classes and their composition in C++}
\end{table}

The executable specification with a certain constraint set is
represented by a user provided C++ class. An example
is shown in Figure~\ref{example-sdf-constraintset}, which is
derived from the selected \SysteMoC{} constraint set type and by
user provided C++ classes representing the actors of the specification.
These actors are derived from a \SysteMoC{} node interface type which
meet the requirements of the selected constraint set. The network graph
is assembled in the constructor of the top class by using the
operators provided by the \SysteMoC{} network graph type.
Each actor registered with the \code{registerNode} method must implement
the parameterized node interface type of the constraint set or an even
less capable node interface type, which is enforced by the type signature
of the registerNode method and the node interface hierarchy.
Each registered channel must be of the parameterized channel kind,
enforcement is obtained by the type signature of the
the registerChan and connectNodePorts methods.

\begin{figure}[h]
\centering
\begin{verbatim}
class m_top2: public hscd_sdf_constraintset {
  public:
    hscd_port_in<int>  in1;
    hscd_port_in<int>  in2;
    hscd_port_out<int> out;
    
    m_top2()
      : hscd_sdf_constraintset()
    {
      m_adder<int>    &adder =
        registerNode(new m_adder<int>("adder"));
      m_multiply<int> &mult  =
        registerNode(new m_multiply<int>("multiply"));
      
      connectInterfacePorts( in1, adder.in1 );
      connectInterfacePorts( in2, mult.in1 );
      connectNodePorts( adder.out, mult.in2 );
      connectNodePorts( mult.out2, adder.in2,
        hscd_fifo<int>() << 13 /* Start marking */ );
      connectInterfacePorts( out, mult.out1 );
    }
};
\end{verbatim}
\caption{\label{example-sdf-constraintset}Example of a network graph for the SDF-Actor in the \SysteMoC{} framework}
\end{figure}

%determine the MoC of a SystemC model additionally to the information
%required about the actors of the model information is required about the
%type of the network graph (See Subsection~\ref{network-graph} for defined graph types).

%The MoC is represented as an actor which is derived from the \code{hscd\_structure}
%template parameterized with the node interface and the channel kind. This actor can only
%instantiate sub actors of a predetermined kind and connect their ports with a  predetermined
%kind of channel.

%%The MoC is now determined by the composition of the two aspects node interface
%%and channel kind as following:
%%
%%\begin{tabular}{|c||c|c|c|}
%%\hline
%% Channel kind & \multicolumn{3}{c|}{ Node interface } \\
%%\hline
%%              & Choice Node         & Transact Node      & Fixed Transact Node \\
%%\hline \hline
%% Fifo         & No well known name  & KPN                & SDF \\
%%\hline
%% Rendezvous   & CSP                 & No well known name & No well known name \\
%%\hline
%%\end{tabular}

\section{Examples of MoC in SystemC with SysteMoC}\label{systemoc-examples}

\subsection{The dining philosophers problem}

\begin{figure}
\centering
\begin{verbatim}
enum dp_forkreq_ty { FORK_TAKE, FORK_DROP };

class dp_fork
  : public hscd_choice_node {
public:
  hscd_port_in<dp_forkreq_ty> l_forkreq;
  hscd_port_in<dp_forkreq_ty> r_forkreq;
private:
  void l_forkreq_take() { assert(l_forkreq[0] == FORK_TAKE);
    std::cout << "Fork " << name() << " taken by left philosopher !" << std::endl; }
  void l_forkreq_drop() { assert(l_forkreq[0] == FORK_DROP);
    std::cout << "Fork " << name() << " droped by left philosopher !" << std::endl; }
  void r_forkreq_take() { assert(r_forkreq[0] == FORK_TAKE);
    std::cout << "Fork " << name() << " taken by right philosopher !" << std::endl; }
  void r_forkreq_drop() { assert(r_forkreq[0] == FORK_DROP);
    std::cout << "Fork " << name() << " droped by right philosopher !" << std::endl; }
  
  static
  hscd_firing_state fireRules() const {
    hscd_firing_state start =
      choice( l_forkreq >> call(l_forkreq_take,
                choice( l_forkreq >> call(l_forkreq_drop, &start) ) ) |
              r_forkreq >> call(r_forkreq_take,
                choice( r_forkreq >> call(r_forkreq_drop, &start) ) )
            );
    return start;
  }
public:
  dp_fork( sc_module_name name )
    : hscd_choice_node(name, fireRules() ) {}
};
\end{verbatim}
\caption{\label{dining-philosophers-fork-systemoc}
  Example of the fork implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}


\begin{figure}
\centering
\begin{verbatim}
class dp_footman
  : public hscd_choice_node {
public:
  hscd_port_in<void> sitreq_0;
  hscd_port_in<void> sitreq_1;
  hscd_port_in<void> standreq_0;
  hscd_port_in<void> standreq_1;
private:
  void philosopher0_sitdown() {
    std::cout << "Seat " << name() << " taken by philosopher 0 !" << std::endl; }
  void philosopher0_standup() {
    std::cout << "Seat " << name() << " vacated by philosopher 0 !" << std::endl; }
  void philosopher1_sitdown() {
    std::cout << "Seat " << name() << " taken by philosopher 1 !" << std::endl; }
  void philosopher1_standup() {
    std::cout << "Seat " << name() << " vacated by philosopher 1 !" << std::endl; }
  
  static
  hscd_firing_state fireRules() const {
    hscd_firing_state start =
      choice( sitreq_0 >> call(philosopher0_sitdown,
                choice( standreq_0 >> call(philosopher0_standup, &start ) ) ) |
              sitreq_1 >> call(philosopher1_sitdown,
                choice( standreq_1 >> call(philosopher1_standup, &start ) ) )
            );
    return start;
  }
public:
  dp_footman( sc_module_name name )
    : hscd_choice_node(name, fireRules() ) {}
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example of the footman implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}


\begin{figure}
\centering
\begin{verbatim}
class dp_philosopher
  : public hscd_choice_node {
public:
  hscd_port_out<dp_forkreq_ty> l_forkreq;
  hscd_port_out<dp_forkreq_ty> r_forkreq;
  hscd_port_out<void>          sitreq;
  hscd_port_out<void>          standreq;
private:
  void nothing() {}
  
  void eat() {
    std::cout << "Philosopher " << name() << " eating !" << std::endl;
    wait( sc_time(3,SC_NS) );
    l_forkreq[0] = r_forkreq[0] = FORK_DROP;
  }
  
  void think() {
    std::cout << "Philosopher " << name() << " thinking !" << std::endl;
    wait( sc_time(100,SC_NS) );
    l_forkreq[0] = r_forkreq[0] = FORK_TAKE; 
  }
  
  static
  hscd_firing_state fireRules() const {
    hscd_firing_state start =
      choice( sitreq >> call(nothing,
        choice( l_forkreq >> call(nothing,
          choice( r_forkreq >> call(eat,
            choice( r_forkreq >> call(nothing,
              choice( l_forkreq >> call(nothing,
                choice( standreq >> call(think, &start ) )
              ) )
            ) )
          ) )
        ) )
      ) );
    return start;
  }
public:
  dp_philosopher( sc_module_name name )
    : hscd_choice_node(name, fireRules() ) {
    l_forkreq[0] = r_forkreq[0] = FORK_TAKE; 
  }
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example of the philosopher implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}

\begin{figure}
\centering
\begin{verbatim}
class m_top
: public hscd_csp_constraintset {
  public:
    m_top( sc_module_name name )
      : hscd_csp_constraintset(name) {
      dp_fork        &m_fork0        = registerNode(new dp_fork("m_fork0"));
      dp_fork        &m_fork1        = registerNode(new dp_fork("m_fork1"));
      dp_philosopher &m_philosopher0 = registerNode(new dp_philosopher("m_philosopher0"));
      dp_philosopher &m_philosopher1 = registerNode(new dp_philosopher("m_philosopher1"));
      dp_footman     &m_footman      = registerNode(new dp_footman("m_footman"));
      
      connectNodePorts( m_philosopher0.l_forkreq, m_fork0.r_forkreq );
      connectNodePorts( m_philosopher1.r_forkreq, m_fork0.l_forkreq );
      
      connectNodePorts( m_philosopher1.l_forkreq, m_fork1.r_forkreq );
      connectNodePorts( m_philosopher0.r_forkreq, m_fork1.l_forkreq );
      
      connectNodePorts( m_philosopher0.sitreq,   m_footman.sitreq_0   );
      connectNodePorts( m_philosopher0.standreq, m_footman.standreq_0 );

      connectNodePorts( m_philosopher1.sitreq,   m_footman.sitreq_1   );
      connectNodePorts( m_philosopher1.standreq, m_footman.standreq_1 );
    }
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example representation of the init function for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}

\section{Conclusions}\label{conclusions}

We have implemented a framework which restricts
the communication behavior of actor-oriented MoCs in such a way that the identification,
extraction, and analysis of these MoCs is permitted.
In actor-oriented design, actors only
communicate with each other via channels instead of method calls as known
in object-oriented design. In our proposed methodology, the specification is
distinguished in four different aspects,
namely \emph{node functionality}, \emph{node interface}, \emph{network graph}, and
\emph{channel kind}. Our result is a SystemC library named \SysteMoC{}.

\clearpage
\appendix
\bibliographystyle{alpha}
\bibliography{literature}

\end{document}
