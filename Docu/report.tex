\newcommand{\graphicPostfix}{pdf}
\newcommand{\resdir}{../../../HscdTeXRes/}
%%\newcommand{\code}[1]{\texttt{#1}}
%%\newcommand{\SysteMoC}{{\bf SysteMoC}}
%%\newcommand{\SysteMoCV}{\SysteMoC{} {\bf 1.0}}
\newcommand{\code}[1]{\emph{#1}}
\newcommand{\SysteMoC}{\emph{SysteMoC}}
\newcommand{\SysteMoCV}{\emph{SysteMoC 1.0}}

\input{\resdir format.tex}

\usepackage{multirow}
\usepackage{fancyvrb}

% Use a small font for the verbatim environment
\makeatletter  % makes '@' an ordinary character
\renewcommand{\verbatim@font}{%
  \ttfamily\small\catcode`\<=\active\catcode`\>=\active%
}
\makeatother   % makes '@' a special symbol again

% \begin{Verbatim}[fontsize=\tiny]

\hypersetup{
  pdftitle   = {Representing Models of Computation in SystemC},
  pdfsubject = {Co-Design-Report},
  pdfauthor  = {\textcopyright\ Joachim Falk, Christian Haubelt, J\"urgen Teich},
  colorlinks = true,
  linkcolor  = black,
  anchorcolor= black,
  citecolor  = black,
  filecolor  = black,
  menucolor  = black,
  pagecolor  = black,
  urlcolor   = black
}

\begin{document}
\hscdtitle{Representing Models of Computation in SystemC}
{Joachim Falk, Christian Haubelt, J\"urgen Teich}{\today}
\clearpage
\tableofcontents
\clearpage

\section{Introduction\label{intro}}
Due to rising design complexity it is necessary to increase
the level of abstraction at which systems are designed. In
today's embedded systems the specification is mostly mapped
into a set of interacting tasks and hardware modules, which 
interact by the use of shared variables and various ways of
message passing. To guarantee exclusive access to the shared
variables and resources, mutually exclusive devices like semaphores,
mutexes, and monitors are used. But this unstructured use
of communication types lead to hardly analyzable systems.
However, by constraining the type of communication
used between tasks and the communication behavior of the tasks,
expressiveness is traded for analyzability.

\emph{Models of computation}
\cite{embsft:2002}, in the following called \emph{MoCs}, are
predefined types of communication and strategies for scheduling
communicating tasks. Thus, MoCs are comparable to design
patterns known from the area of software design \cite{gamma:1995}.
Limiting the expressiveness of an MoC enables:

\begin{enumerate}
\item Mathematically reasoning about communication patterns

\item Code generators to produce optimized code

\item Verification tools to check system properties automatically
\end{enumerate}

On the other hand, modern embedded system design is still based on
specification languages which allow unstructured communication.
Even worse, nearly all specification languages allow for Turing
complete MoCs making analysis in general impossible.
To make industry benefit from the best of both worlds,
engineers must restrict themselves to use certain subsets of
specification languages allowing for analyzability, identification,
and extraction of these MoCs from the source code automatically.

This report deals with the representation of some transformative
MoCs in SystemC. The rest of the report is structured as follows:
In Section~\ref{related-work}, we discuss related work. In
Section~\ref{aspect-overview}, we propose our framework for
representing MoCs in SystemC. In Section~\ref{revision-of-mocs},
we show how some MoCs fit into
the framework presented before. In Section~\ref{software-architecture}
an implementation of our framework in SystemC called \SysteMoC{} is
presented. Finally, we will give some examples using the \SysteMoC{}
framework in Section~\ref{systemoc-examples}, and we conclude
the present report in Section~\ref{conclusion}.

\section{Related Work}\label{related-work}

\section{Aspect Overview}\label{aspect-overview}

A model of computation \cite{embsft:2002} is defined as the 
interaction policy between \emph{actors} in an \emph{actor-oriented} design
\cite{agha97abstracting:1997}.
Actors are objects which execute concurrently. They can only
communicate with the environment (other actors) through their \emph{actor ports}.
The actor ports are connected with each other via a \emph{channel network}.
The data values, which are communicated over the channels
are abstracted. The values are called \emph{tokens} regardless
of their type or value.

Instead of a monolithic approach for representing an executable specification,
in this report, we will separate a specification into several
independent \emph{aspects}.
This is a refinement of actor-oriented design.
In actor-oriented design, actors only
communicate with each other via channels instead of method calls as known
in object-oriented design. In our proposed methodology, the specification is more
detailed than in actor-oriented design.
Four different aspects for distinguishing MoCs can be identified,
namely node functionality, node interface, network graph, and
channel kind. An aspect can be further divided into
\emph{aspect types} by different constraints placed on the aspect.
In the following, the aspects and their further
differentiation into aspect types is discussed in depth:

\subsection{Node Functionality}\label{node-functionality}

In our methodology proposed in this report, the actor concept is still used,
but we distinguish two different aspects.
The first part called \emph{node functionality} is responsible
for transforming data values. The node functionality can be
thought of as a function $F: V^{m} \to V^{n}$  which maps a fixed set
of parameters to a fixed set of results. The node functionality
can be implemented by a Turing-complete programming language but
the user must guarantee, that the node functionality terminates
and does not communicate with other actors.
The node functionality is the only aspect which is not further distinguished
into aspect types.

\subsection{Node Interface}\label{node-interface}

The second part of an actor which determines its communication
behavior is called \emph{firing rules}. The firing rules
determine for each actor port the number of tokens to receive or send
until the associated node functionality can be invoked. These firing rules are
constructed by the use of communication operations which are
provided by the \emph{node interface}. Furthermore, we
distinguish three separate \emph{node interface types} by the set
operations available to them:

\begin{definition}\label{choice-node-interface-type}
  Choice node interface type

  \emph{Choice} is an operation defined on a set of actor ports $A_{P}$
  and a function $D: A_{P} \to \mathcal{F}$, which maps each actor port
  $a_{p} \in A_{P}$ to a function $F_{x} \in \mathcal{F}$.
  The choice operation postpones the process execution 
  until at least one actor port $a_{p} \in A_{P}$
  becomes ready to communicate. The set of actor ports available
  is given by $A_{P_{ready}}$.
  Exactly one actor port $a_{p} \in A_{P_{ready}}$
  will be chosen nondeterministically. After
  finishing the communication on the chosen actor port $a_{p}$
  the process execution will contiune
  with function $F_{continue} = D(a_{p})$.
\end{definition}

\begin{definition}\label{transact-node-interface-type}
  Transact node interface type
\end{definition}

\begin{definition}\label{fixed-transact-node-interface-type}
  Fixed transact node interface type
\end{definition}

\subsection{Network Graph}\label{network-graph} 

To represent an executable specification, not only information about
individual actors but also information about the communication network,
which is the only means of communication between actors,
must be provided. Moreover, information about hierarchical
composition of actors is required. This information is stored in
the \emph{network graph}.

\begin{definition}
A network graph is a 5-tuple $N=(\mathcal{A},C,P_{i},P_{o},E)$ containing
a set of actors $\mathcal{A}$, a set of channels $C$, a set of uplevel
input ports $P_{i}$, a set of uplevel output ports $P_{o}$ and a set of
directed edges $E \subseteq ((P_{i} \cup C) \times \mathcal{A}_{P_{i}})
\cup (\mathcal{A}_{P_{o}} \times (P_{o} \cup C))$.
Each actor $A \in \mathcal{A}$ can only communicate with other actors
through its dedicated actor input ports $A_{P_{i}}$ and
actor output ports $A_{P_{o}}$.
% $\forall{(X,Y)\in \mathcal{A^2}}: X \ne Y \Rightarrow X_{P} \cap Y_{P} = \emptyset$
Furthermore, we define the set of all
actor input ports as $\mathcal{A}_{P_{i}} = \bigcup{}_{A \in \mathcal{A}} A_{P_{i}}$ and
the set of all actor output ports as
$\mathcal{A}_{P_{o}} = \bigcup{}_{A \in \mathcal{A}} A_{P_{o}}$.
\end{definition}

There are two network graph types which are distinguished by our methodology:

\begin{definition}\label{petri-network-graph}
  A Petri network graph is constrained such that exactly
  one edge is incident to each actor port
  $\forall{p \in \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}}}: |(C \times \{p\}) \cap E| = 1$.
\end{definition}

\begin{figure}
\centering
%\includegraphics[scale=1]{ng-petri.\graphicPostfix}\\
\input{ng-petri-fig.tex}
\caption{\label{ng-petri}
  In a \emph{petri network graph} exactly
  one edge enters an actor input port.}
\end{figure}

  In other words, an example of a petri network graph is shown in Figure~\ref{ng-petri}.

\begin{definition}\label{dataflow-network-graph}
  A Dataflow network graph is a petri network graph with the additional constraint
  that the indegree and outdegree of each channel in the graph is exactly one
  $\forall{c \in C}: |(\{c\} \times \mathcal{A}_{P_{i}}) \cap E| = 1 \wedge
                    |(\mathcal{A}_{P_{o}} \times \{c\}) \cap E| = 1$.
\end{definition}

  In other words, an example of a dataflow network graph is shown in Figure~\ref{ng-dataflow}.

\begin{figure}
\centering
%\includegraphics[scale=1]{ng-dataflow.\graphicPostfix}\\
\input{ng-dataflow-fig.tex}
\caption{\label{ng-dataflow}
  In a \emph{dataflow network graph} exactly
  one edge enters an actor input port and
  the channels can only be used for dedicated
  Point-to-Point connections.}
\end{figure}

\subsection{Channel Kind}\label{channel-kind}

The \emph{channel kind} defines the communication semantic of the channel.
Because the communication semantic is not influenced by the
type of the values communicated, the actual \emph{type} of a communication
channel is derived from the channel kind by parameterizing it with
the type of the communicated values. Examples for channel kinds are:

\begin{itemize}
\item \label{channel-kind-fifo} FIFO:
  An unbound FIFO channel for communication
  (nonblocking write and blocking read) implementing
  an first in first out discipline.

\item \label{channel-kind-rendezvous} Rendezvous:
  A rendezvous channel for communication % and barrier synchronisation
  (blocking write and read).

\item \label{channel-kind-register} Register:
  For expressing communication via shared variables
  (nonblocking write and nonblocking read).
\end{itemize}

\section{Revision of Different MoCs}\label{revision-of-mocs}

The requirements of MoCs can be separated into two distinct groups.
There are the execution requirements which must be fulfilled by
the programming system otherwise the MoC cannot be implemented in
this particular system.
On the other hand, there are the analysis requirements which
permit the extraction of information needed for the MoC specific analysis.

In the following Subsections, different MoCs are considered and their
requirements determined. For each MoC these requirements are than
mapped onto the aspects presented in the previous Section.

\subsection{Communicating Sequential Processes (CSP)}
\emph{Communicating Sequential Processes} \cite{csphoare:1985}
is a MoC which consist of concurrently executing processes
which communicate via unidirectional \emph{rendezvous channels}.
As a difference to the CSP model of Hoare \cite{csphoare:1985}
which allows runtime creation of processes via parallel
composition and recursion, the CSP model presented in this report
is constraint to a fixed predetermined number of processes.
This constraint was set to allow hardware synthesis from this
model.

The following requirements are the execution requirements to
implement CSP behavior:

\begin{requirement}\label{requirement-csp-rendezvous}
  Rendezvous channel for communication
\end{requirement}

\begin{requirement}\label{requirement-csp-general-choice}
  A communication method for Hoare's so-called \emph{general choice}
  
  General choice written $ce_{1} \to F_1 \Box ce_{2} \to F_2$
  is a operation defined on a set of channel expressions $CE$ and
  a function $D: CE \to \mathcal{F}$, which maps a channel expression
  $ce \in CE$ to a function $F_{x} \in \mathcal{F}$. A channel
  expression can either send the contents of a variable $v$ into
  the channel $c$ which is written $c!v$ or receive a value from
  the channel $c$ and write it into variable $v$ which is written
  $c?v$. A channel expression is ready to communicate when its
  associated channel is ready to communicate.
  Let $CE_{rt} \subseteq CE$ be the subset of channel expressions
  ready to communicate at time $t$. The general choice operation
  blocks the process until time $t$ where at least one channel expression
  is ready to communicate $|CE_{rt}| \ge 1$. One channel expression
  $ce \in CE_{rt}$ will be chosen nondeterministically and the
  execution will contiune with function $F_{continue} = D(ce)$.
\end{requirement}

\begin{requirement}\label{requirement-csp-concurrent-processes}
  Parallel executing processes
  
  The CSP \emph{parallel composition} operation written $F_1 \| F_2$ executes the
  function $F_1$ and $F_2$ in parallel and terminates when both functions
  have terminated. Through the use of recursion and parallel composition
  like $X = F_1 \| X$ CSP enables unlimited runtime creation of processes.
  Our CSP MoC only allows a fixed static number of processes. This
  leads to the constraint that only CSP programs can be represented which
  have a single init function which can not be called recursivly. This init
  function creates all processes needed in the CSP program via parallel composition.
  Other functions in the CSP program must not use the parallel composition
  operation.
\end{requirement}

%\item Sequential composition of functions
%  
%  Sequential composition written $F_1 \to F_2 \to F_3 \to \cdots$
%  is 
% $\to$ is sequential composition

In the following, a CSP program for the classical dining
philosophers problem is demonstrated (See Figure~\ref{fig:dining-philosophers}
for the processes and connection topology used in the example):

\begin{figure}[h]
\centering
\input{dining-philosophers-fig.tex}
\caption{Processes and connection topology used for the ``Dining philosophers'' CSP example}
\label{fig:dining-philosophers}
\end{figure}

\begin{displaymath}
\begin{array}{rcl}
Philosopher_{i}    & := & FootSit_{i}!sit \to ForkReqL_{i}!take \to ForkReqR_{i\oplus1}!take \to \\
		   &    & Eat \to \\
		   &    & ForkReqL_{i}!drop \to ForkReqR_{i\oplus1}!drop \to FootStand_{i}!stand \to \\
		   &	& Philosopher_{i} \\
Fork_{i}	   & := & ForkReqR_{i}?req_{r} \to ForkReqR_{i}?req_{r} \to Fork_{i} \Box \\
		   &    & ForkReqL_{i\oplus1}?req_{l} \to ForkReqL_{i\oplus1}?req_{l} \to Fork_{i} \\
Footman		   & := & FootMan_{0} \\
Footman_{0}	   & := & FootSit_{x}?req_{x} \to Footman_{1} \\
Footman_{3}	   & := & FootStand_{x}?req_{x} \to Footman_{2} \\
Footman_{j}	   & := & FootSit_{x}?req_{x} \to Footman_{j+1} \Box \\
		   &    & FootStand_{x}?req_{x} \to Footman_{j-1} \\
InitFunction       & := & Philosopher_{0} \| Fork_{0} \| \\
		   &    & Philosopher_{1} \| Fork_{1} \| \\
		   &    & Philosopher_{2} \| Fork_{2} \| \\
		   &    & Philosopher_{3} \| Fork_{3} \| \\
		   &    & Footman \\
\end{array}
\end{displaymath}

Where $\oplus$ is addition modulo 4.

To facilitate analysis of the CSP MoC additionally the following
analysis requirements must be satisfied:
\begin{requirement}\label{requirement-csp-communication}
  Parallel executing processes must only communicate over rendezvous channels,
  which must be Point-to-Point connections.
\end{requirement}

The requirements \ref{requirement-csp-rendezvous} -
\ref{requirement-csp-communication} of the CSP MoC are mapped in the following way
onto the aspects presented in Section~\ref{aspect-overview}.
(i) The rendezvous communication (Requirement~\ref{requirement-csp-rendezvous})
used by CSP is provided by the channel kind rendezvous (See~\ref{channel-kind-rendezvous})
(ii) Hoare's so-called general choice communication operator (Requirement~\ref{requirement-csp-general-choice})
is provided as a operation in the choice node interface (See~\ref{choice-node-interface-type}).
(iii) The parallel executing processes (Requirement~\ref{requirement-csp-concurrent-processes})
created by the init functions are mapped to the concurrently executing actors
(Subsection~\ref{node-functionality} and Subsection~\ref{node-interface}).
(iv) The Point-to-Point communication of CSP over rendezvous channels (Requirement~\ref{requirement-csp-communication})
is provided by the dataflow network graph (See~\ref{dataflow-network-graph}) and
its contained rendezvous channels, which is the only means of communication in a
actor-oriented design.

\subsection{Dataflow (DF)}
Kahn Process Networks \cite{kahn:1974}
is a MoC which consist of concurrently executing processes
which communicate via unidirectional unbounded \emph{FIFO channels}.
The input and output of a channel is connected to a dedicated
actor port.

The following requirements are the execution requirements to
implement KPN behavior:

\begin{enumerate}
\item An unbound FIFO channel for communication
\item A communication method to read from and write to FIFOs
\item Parallel executing processes
\end{enumerate}

In the following, a example dataflow program for audio coding
is demonstrated. For the audio encoding an algorithm
adapted for multimedia audio or an algorithm adapted for speech
is dynamically selected depending on the input audio stream
(See Figure~\ref{fig:media-speech-audio-coding}
for the processes and connection topology used in the example):

\begin{figure}[h]
\centering
\input{media-speech-audio-coding-fig.tex}
\caption{Processes and connection topology used for the audio encoding dataflow example}
\label{fig:media-speech-audio-coding}
\end{figure}



To facilitate analysis of the KPN MoC additionally the following
constraints must be fulfilled:
\begin{enumerate}
\item Parallel executing processes must only communicate over FIFO channels.
\item The channels must be Point-to-Point connections.
\item Arrival sequence of tokens on different channels must be indeterminable
      for the process.
\end{enumerate}

Mapping of the KPN MoC requirements onto the aspects presented in
Section~\ref{aspect-overview}:

\begin{itemize}

\item The node interface must only provide a communication operator which
      generates parameterized read and write requests on the actor ports.

\item The connections needed for CSP are provided by the Dataflow network graph.

\item As channel kind FIFO is selected.

\end{itemize}

\subsection{Synchronous Dataflow (SDF)}
Synchronous Data Flow \cite{Lee87b:1987}
is a more constricted form of the KPN MoC.
It has all the execution requirements of the KPN MoC and
the additional analysis requirement that actor consumption and
production rates are constant.

Mapping of the SDF MoC requirements onto the aspects presented in
Section~\ref{aspect-overview}:

\begin{itemize}

\item The node interface must only provide a communication operator which
      generates read and write requests with a fixed set of actor ports.

\item The connections needed for CSP are provided by the Dataflow network graph.

\item As channel kind FIFO is selected.

\end{itemize}

\section{Software Architecture}\label{software-architecture}

Due to its high abstraction level and possibilities for both
hardware and software refinements, we have chosen SystemC
\cite{systemc-lrm:2003} \cite{glms:2002} as our language for system design.
SystemC is an actor-oriented C++ based design framework and
allready allow to express dataflow MoCs. 

In the following, we propose a SystemC framework, called \SysteMoC, which
facilitates automatic extraction of the MoC of a SystemC design.
Actors in SystemC are C++ classes which are derived from the base class \code{sc\_module}.
The \SysteMoC{} framework provides the execution requirements for each MoC while
still supporting the extraction of the information needed for analysis.
This analysis is made possible by dividing the actor into its
node functionality and its node interface.
Furthermore, the \SysteMoC{} framework provides a way for these
actors to be connected to each other, via their ports. This connections
are provided by the network graph.
%Actors can have their own thread of control or be without. Actors
%with their own thread of control will be called in the following
%active actors and actors without a dedicated thread of control
%passive actors.

\begin{figure}
\centering
\begin{verbatim}
template <typename T>
class m_adder // Actor m_adder
  : public hscd_fixed_transact_node // Node interface
{
public:
  hscd_port_in<T>  in;
  hscd_port_out<T> out;
private:
  // Node functionality
  void transform() {
    out[0] = in[0] + in[1];
    std::cout << "Adding " << in[0] << " + " << in[1]
              << " = " << out[0] << std::endl;
  }
  
  // Firing rules
  void process() {
    while (true) {
      transform();
      transact();
    }
  }
public:
  m_adder( sc_module_name name )
    :hscd_fixed_transact_node( name,
        in(2) & out(1) /* Firing rules */ ) {}
};
\end{verbatim}
\caption{\label{example-adder-actor}Example of an adder in the \SysteMoC{} framework}
\end{figure}

\begin{figure}
\centering
\begin{verbatim}
template <typename T>
class m_multiply // Actor m_multiply
  : public hscd_fixed_transact_node // Node interface
{
public:
  hscd_port_in<T>  in1;
  hscd_port_in<T>  in2;
  hscd_port_out<T> out;
private:
  // Node functionality
  void transform() {
    out[0] = in1[0] + in2[0];
    std::cout << "Multiplying" << in1[0] << " * " << in2[0]
              << " = " << out[0] << std::endl;
  }
  
  // Firing rules
  void process() {
    while (true) {
      transform();
      transact();
    }
  }
public:
  m_multiply( sc_module_name name )
    :hscd_fixed_transact_node( name,
        in1(1) & in2(1) & out(1) /* Firing rules */ ) {}
};
\end{verbatim}
\caption{\label{example-multiply-actor}Example of a multiplier in the \SysteMoC{} framework}
\end{figure}

\subsection{Node Functionality}
The node functionality is only used for algorithmic transformations of data values.
The node functionality of an actor is defined in certain member functions,
which are called by the firing rules if their requirements for input data is met.
This member functions are not allowed to call communication operations and
the input and output data values used are read from
and written to the actor ports. All actor ports are globally accessible
by the actor member functions and can therefore be used to get input data
and place output data for the node functionality
(See Figure~\ref{example-adder-actor} method \code{transform} for an example of a node functionality).

\subsection{Node Interface Hierarchy}
The problem of extracting the communication behavior of an actor is caused by the fact,
that the communication methods in SystemC are all accessible to all SystemC modules.
And execution of these methods is controlled by the Turing equivalent coding possibilities
in the actor. To partially redress these problems we introduced the node interface aspect
which determines what communication methods are available to an actor. This is implemented
by disallowing all communication methods on \SysteMoC{} channels and providing them instead
in a base class from which the actor is derived. Therefore the node interface of an actor
corresponds to the base class from which the actor is derived
(See Table~\ref{node-interface-c++} for mapping of the node interface names to their
corresponding C++ class types).
Communication over other media than \SysteMoC{} channels is forbidden but this cannot be enforced
because the full power of SystemC should be available for the node functionality part
of the actor. So we require form the \SysteMoC{} user the assurance that the
node functionality does terminate and does not communicate with other actors.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
 Node interface & \SysteMoC{} node interface type \\
\hline \hline
 Choice Node          & \code{hscd\_choice\_node} \\
 Transact Node        & \code{hscd\_transact\_node} \\
 Fixed Transact Node  & \code{hscd\_fixed\_transact\_node} \\
\hline
\end{tabular}
\caption{\label{node-interface-c++}Node interfaces represented as \SysteMoC{} classes}
\end{table}

The following subset of the requirements enumerated in Section~\ref{revision-of-mocs}
determines the node interface of the corresponding MoCs:

\begin{enumerate}
\item Choice Node
  \begin{itemize}
  \item  A communication method which implements Hoare's 'general choice' operator \cite{csphoare:1985}.
  \end  {itemize}
\item Transact Node
  \begin{itemize}
  \item A communication method to read from and write to ports.
  \item Assurance that the arrival sequence of tokens at
        their ports cannot be determined.
  \end  {itemize}
\item Fixed Transact Node
  \begin{itemize}
  \item A communication method to read from and write to ports.
  \item Assurance that the arrival sequence of tokens at
        their ports cannot be determined.
  \item Assurance that consumption and production rates cannot
        be altered once set
  \end  {itemize}
\end{enumerate}

These requirements build a hierarchy of decreasing capability. The node
interface of CSP is the most capable in the hierarchy and it
fulfills the execution requirements of all more constraint interfaces.
To fulfill the execution requirement of KPN the general choice operator
can be used to implement the communication method for KPN by constraining
the list of actor ports for the choice operation to one and therefore
eliminating the choice between different actor ports.
The execution requirement of SDF are the same than that of KPN and can
therefore be fulfilled by the node interface of KPN.

However the analysis requirements of the MoC in the hierarchy
get progressively more constraining and therefore the power
of the communication operations in the node interface must
be reduced accordingly to meet them.

\begin{figure}
\centering
\includegraphics[scale=0.5]{NodeInterfaceHierarchy.\graphicPostfix}\\
\caption{\label{node-interface-hierarchy}Node interface hierarchy as UML}
\end{figure}

The hierarchy of the requirements is transformed into a C++ inheritance
hierarchy with the CSP node interface at the root (See Figure~\ref{node-interface-c++}).
Less capable node interfaces inherit from more capable ones. The
less capable node interfaces use the communication operations from the base class node
interface to implement their own operations. The communication operations of the
base class are disabled by declaring them private.

\begin{enumerate}
\item CSP
  \begin{itemize}
  \item  \code{choice( a(1) $\arrowvert$ b(2) )}

    This communication operation gets a list of actor ports (e.g. $a$, $b$) which
    are parameterized with the number of tokens that must be communicated
    over the port. The operations communicates over that actor port which is first ready
    for communication. If no port is ready for communication the operation blocks until
    at least one port is ready. Should more than one actor port be ready for
    communication at the same instance one of them is chosen nondeterministically.
  \end  {itemize}
\item KPN
  \begin{itemize}
  \item \code{transact( a(1) \& b(2) )}

    This communication operation gets a list of actor ports (e.g. $a$, $b$) which
    are parameterized with the number of tokens that must be communicated
    over the port. The operations blocks until all requested tokens on the ports
    have been communicated.
  \end  {itemize}
\item SDF
  \begin{itemize}
  \item \code{transact(), hscd\_fixed\_transact\_node( ..., a(1) \& b(2) )}

    Actors are C++ classes which are derived of their node interface class.
    The consumption and production rates for SDF Actors must be fixed, therefore
    the node interface of a SDF-Actor is parameterized with the consumption and production
    rates of the SDF-Actor (See actor constructor in Figure~\ref{example-multiply-actor} for an
    example of fixed consumption and production rates). The communication operation \code{transact} is
    therefore missing the port list which is available to KPN nodes.
  \end  {itemize}
\end{enumerate}

\subsection{Network Graph Type}

To complete a executable specification in \SysteMoC{} additionally
to the information about the actors, information about the connections
of the actors with each other is needed. This information is stored
in the network graph part of the executable specification, which can
be categorized into two different network graph types as defined in
Subsection~\ref{network-graph}.

The network graph is represented by a user provided C++ class, in the following called
network graph class. This class is derived from a \SysteMoC{} graph type class which
provides the methods needed to assemble the network graph in the constructor
of the network graph class. Once the constructor has finished the network graph must
be fully assembled. No alteration at a later date is allowed.
The methods provided by the \SysteMoC{} graph type class together with runtime checks
in these methods constrain the constructet network graph to conform to the corresponding
network graph type.
Therefore the network graph type of a network graph can be determined by looking
at the base class of the network graph class.
(See Table~\ref{network-graph-c++} for mapping of the network graph types to their
corresponding \SysteMoC{} graph type classes).

\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
 Network graph type   & \SysteMoC{} graph type class \\
\hline \hline
 Petri Choice Node    & \code{hscd\_graph\_petri} \\
 Transact Node        & \code{hscd\_graph\_sdf} \\
\hline
\end{tabular}
\caption{\label{network-graph-c++}Network graph types represented as \SysteMoC{} classes}
\end{table}

To construct the network graph the following methods are available for
composition of a network graph of the desired type:
\begin{enumerate}
\item Petri network graph

  \begin{itemize}
  \item registerNode:
    This method is used to add one actor $A$ to the set of actors $\mathcal{A}$
    of the network graph.

  \item registerChan:
    This method is used to add one channel $c$ to the set of channels $C$
    of the network graph. This functions takes an optional parameter which can
    be used to specify the initial state of the new channel, which is
    for example used for the count of inital tokens of a FIFO channel.

  \item connectChanPort:
    This method adds one edge $e \in C \times \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}} \times C$
    between channels and actor ports to the network graph.

  \item connectInterfacePorts
    This method adds one edge $e \in P_{i} \times \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}} \times P_{o}$
    between actor ports and uplevel ports to the network graph.

  \end{itemize}

\item Dataflow network graph

  \begin{itemize}
  \item registerNode: Same method as defined for petri network graphs.
  
  \item connectInterfacePorts: Same method as defined for petri network graphs.
  
  \item connectNodePorts:
    This method is a shorthand for adding one channel and
    connecting two actor ports via this channel. Only channels
    which are connected to a dedicated output actor port and
    a dedicated input actor port can be realized with it.
    This method takes an optional parameter which fulfils
    the same function as the parameter for method registerChan.
  
  \end{itemize}

\end{enumerate}

\subsection{Channel Kind}

SystemC is an actor-oriented design framework, it has the concepts
of actors and channels. So the channel kind aspect of the \SysteMoC{}
framework can cleanly be implemented as a base class of a channel in SystemC.
The channel kind determines the communication semantic of a channel but not
the data type of the tokens. The channel type is a template parameterized
with the data type for the tokens and derived from the channel kind.
Identifying the channel kind with a base class instead of a template enables
easier type signature checks of C++ for the enforcement of a particular
channel kind of a channel instance.

Further differences between \SysteMoC{} channels and a SystemC channels consist of the
absence of user callable methods for communicating on the \SysteMoC{} channels.
Having those communication methods on the channels would contradict the separation
of node interface and channel kind. The mapping of channel kind to corresponding C++
class types is displayed in Table~\ref{channel-kind-c++}.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
 Channel kind & \SysteMoC{} type \\
\hline \hline
 FIFO         & \code{hscd\_fifo\_kind} \\
 Rendezvous   & \code{hscd\_rendezvous\_kind} \\
\hline
\end{tabular}
\caption{\label{channel-kind-c++}Channel kinds represented as \SysteMoC{} classes}
\end{table}

\subsection{Constraint Set Composition for MoCs}

In Section~\ref{revision-of-mocs} we have demonstrated how
to map the requirements of some MoCs to the aspects presented
in Section~\ref{aspect-overview}. Furthermore, the analysis
requirement of these MoCs translate into certain constraints
on the aspects presented before. These constraints are
used to distinguish a aspect into aspect types. Therefore
for each MoC presented in Section~\ref{revision-of-mocs}
we have a set of aspect types, called \emph{constraint set} and
shown in table~\ref{constraintset-composition},
which represent the analysis requirements of this MoC.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
 Channel kind & Node interface & Network graph type & Constraint set \\
\hline \hline
 Fifo         & Fixed Transact node & Dataflow network graph & SDF constraint set \\
 Fifo         & Transact node       & Dataflow network graph & Dataflow constraint set \\
%% Fifo         & Choice node         & Dataflow network graph & FIFO CSP constraint set \\
 Rendezvous   & Choice node         & Dataflow network graph & CSP constraint set \\
\hline
\end{tabular}
\caption{\label{constraintset-composition}
  Composition of constraint set out of channel kind type, node interface type
  and network graph type}
\end{table}

The aspect types in the constraint set are node interface 
, channel kind and network graph. The node interface and
and channel kind are represented as \SysteMoC{} classes in
SystemC, the third network graph is represented as
a C++ template in \SysteMoC{}. Parameterizing this template
with the channel kind and node interface (As shown in
table~\ref{constraintset-c++}) leads to a C++
type which represents the constraint set in \SysteMoC{}.

\begin{table}[h]
\centering
\begin{tabular}{|l|p{6cm}|l|}
\hline
 Constraint set & Composition in C++ & \SysteMoC{} constraint set type \\
\hline \hline
 SDF constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_fixed\_transact\_node, hscd\_fifo\_kind$>$} &
  \code{hscd\_sdf\_constraintset} \\
\hline
 Dataflow constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_transact\_node, hscd\_fifo\_kind$>$} &
  \code{hscd\_df\_constraintset} \\
\hline
 CSP constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_choice\_node, hscd\_rendezvous\_kind$>$} &
  \code{hscd\_csp\_constraintset} \\
\hline
\end{tabular}
\caption{\label{constraintset-c++}Constraint sets represented as \SysteMoC{}
  classes and their composition in C++}
\end{table}

The executable specification with a certain constraint set is
represented by a user provided C++ class, called top class an example of
which is seen in Figure~\ref{example-sdf-constraintset}, which is
derived from the selected \SysteMoC{} constraint set type and by
user provided C++ classes representing the actors of the specification.
This actors are derived from a \SysteMoC{} node interface type which
meet the requirements of the selected constraint set. The network graph
is assembled in the constructor of the top class by using the
operators provided by the \SysteMoC{} network graph type.
Each actor registered with the \code{registerNode} method must implement
the parameterized node interface type of the constraint set or an even
less capable node interface type, which is enforced by the type signature
of the registerNode method and the node interface hierarchy.
Each registered channel must be of the parameterized channel kind,
enforcement is optained by the type signature of the
the registerChan and connectNodePorts methods.

\begin{figure}[h]
\centering
\begin{verbatim}
class m_top2: public hscd_sdf_constraintset {
  public:
    hscd_port_in<int>  in1;
    hscd_port_in<int>  in2;
    hscd_port_out<int> out;
    
    m_top2()
      : hscd_sdf_constraintset()
    {
      m_adder<int>    &adder =
        registerNode(new m_adder<int>("adder"));
      m_multiply<int> &mult  =
        registerNode(new m_multiply<int>("multiply"));
      
      connectInterfacePorts( in1, adder.in1 );
      connectInterfacePorts( in2, mult.in1 );
      connectNodePorts( adder.out, mult.in2 );
      connectNodePorts( mult.out2, adder.in2,
        hscd_fifo<int>() << 13 /* Start marking */ );
      connectInterfacePorts( out, mult.out1 );
    }
};
\end{verbatim}
\caption{\label{example-sdf-constraintset}Example of a network graph for the SDF-Actor in the \SysteMoC{} framework}
\end{figure}

%determine the MoC of a SystemC model additionally to the information
%required about the actors of the model information is required about the
%type of the network graph (See Subsection~\ref{network-graph} for defined graph types).

%The MoC is represented as an actor which is derived from the \code{hscd\_structure}
%template parameterized with the node interface and the channel kind. This actor can only
%instantiate sub actors of a predetermined kind and connect their ports with a  predetermined
%kind of channel.

%%The MoC is now determined by the composition of the two aspects node interface
%%and channel kind as following:
%%
%%\begin{tabular}{|c||c|c|c|}
%%\hline
%% Channel kind & \multicolumn{3}{c|}{ Node interface } \\
%%\hline
%%              & Choice Node         & Transact Node      & Fixed Transact Node \\
%%\hline \hline
%% Fifo         & No well known name  & KPN                & SDF \\
%%\hline
%% Rendezvous   & CSP                 & No well known name & No well known name \\
%%\hline
%%\end{tabular}

\section{Examples of MoC in SystemC with SysteMoC}\label{systemoc-examples}

\subsection{The dining philosophers problem}

\begin{figure}
\centering
\begin{verbatim}
enum dp_forkreq_ty { FORK_TAKE, FORK_DROP };

class dp_fork
  : public hscd_choice_node {
public:
  hscd_port_in<dp_forkreq_ty> l_forkreq;
  hscd_port_in<dp_forkreq_ty> r_forkreq;
private:
  void process() {
    while ( 1 ) {
      choice( l_forkreq(1) | r_forkreq(1) );
      assert( (l_forkreq && !r_forkreq && l_forkreq[0] == FORK_TAKE) ||
              (r_forkreq && !l_forkreq && r_forkreq[0] == FORK_TAKE) );
      if ( l_forkreq ) {
        std::cout << "Fork " << name() << " taken by left philosopher !" << std::endl;
        transact( l_forkreq(1) );
        assert( l_forkreq && l_forkreq[0] == FORK_DROP );
        std::cout << "Fork " << name() << " droped by left philosopher !" << std::endl;
      } else {
        std::cout << "Fork " << name() << " taken by right philosopher !" << std::endl;
        transact( r_forkreq(1) );
        assert( r_forkreq && r_forkreq[0] == FORK_DROP );
        std::cout << "Fork " << name() << " droped by right philosopher !" << std::endl;
      }
    }
  }
public:
  dp_fork( sc_module_name name )
    : hscd_choice_node(name) {}
};
\end{verbatim}
\caption{\label{dining-philosophers-fork-systemoc}
  Example of the fork implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}


\begin{figure}
\centering
\begin{verbatim}
class dp_footman
  : public hscd_choice_node {
public:
  hscd_port_in<void> sitreq_1;
  hscd_port_in<void> sitreq_2;
  hscd_port_in<void> sitreq_3;
  hscd_port_in<void> sitreq_4;
  hscd_port_in<void> standreq_1;
  hscd_port_in<void> standreq_2;
  hscd_port_in<void> standreq_3;
  hscd_port_in<void> standreq_4;
private:
  void process() {
    int count = 4;
    
    while ( 1 ) {
      if ( count != 0 )
        choice( sitreq_1(1) | standreq_1(1) |
                sitreq_2(1) | standreq_2(1) |
                sitreq_3(1) | standreq_3(1) |
                sitreq_4(1) | standreq_4(1) );
      else
        choice(               standreq_1(1) |
                              standreq_2(1) |
                              standreq_3(1) |
                              standreq_4(1) );
      if ( sitreq_1 || sitreq_2 || sitreq_3 || sitreq_4 )
        --count;
      else
        ++count;
    }
  }
public:
  dp_footman( sc_module_name name )
    : hscd_choice_node(name) {}
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example of the footman implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}


\begin{figure}
\centering
\begin{verbatim}
class dp_philosopher
  : public hscd_choice_node {
public:
  hscd_port_out<dp_forkreq_ty> l_forkreq;
  hscd_port_out<dp_forkreq_ty> r_forkreq;
  hscd_port_out<void>          sitreq;
  hscd_port_out<void>          standreq;
private:
  void process() {
    while ( 1 ) {
      std::cout << "Philosopher " << name() << " want's to eat !" << std::endl;
      transact( sitreq(1) );
      l_forkreq[0] = FORK_TAKE;
      transact( l_forkreq(1) );
      r_forkreq[0] = FORK_TAKE;
      transact( r_forkreq(1) );
      std::cout << "Philosopher " << name() << " eating !" << std::endl;
      wait( sc_time(3,SC_NS) );
      l_forkreq[0] = FORK_DROP;
      transact( l_forkreq(1) );
      r_forkreq[0] = FORK_DROP;
      transact( r_forkreq(1) );
      std::cout << "Philosopher " << name() << " finish eating !" << std::endl;
      transact( standreq(1) );
      wait( sc_time(1,SC_NS) );
    }
  }
public:
  dp_philosopher( sc_module_name name )
    : hscd_choice_node(name) {}
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example of the philosopher implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}

\begin{figure}
\centering
\begin{verbatim}
class m_top
: public hscd_csp_constraintset {
  public:
    m_top( sc_module_name name )
      : hscd_csp_constraintset(name) {
      dp_fork        &m_fork1        = registerNode(new dp_fork("m_fork1"));
      dp_fork        &m_fork2        = registerNode(new dp_fork("m_fork2"));
      dp_fork        &m_fork3        = registerNode(new dp_fork("m_fork3"));
      dp_fork        &m_fork4        = registerNode(new dp_fork("m_fork4"));
      dp_philosopher &m_philosopher1 = registerNode(new dp_philosopher("m_philosopher1"));
      dp_philosopher &m_philosopher2 = registerNode(new dp_philosopher("m_philosopher2"));
      dp_philosopher &m_philosopher3 = registerNode(new dp_philosopher("m_philosopher3"));
      dp_philosopher &m_philosopher4 = registerNode(new dp_philosopher("m_philosopher4"));
      dp_footman     &m_footman      = registerNode(new dp_footman("m_footman"));
      
      connectNodePorts( m_philosopher1.l_forkreq, m_fork1.r_forkreq );
      connectNodePorts( m_philosopher4.r_forkreq, m_fork1.l_forkreq );
      
      connectNodePorts( m_philosopher2.l_forkreq, m_fork2.r_forkreq );
      connectNodePorts( m_philosopher1.r_forkreq, m_fork2.l_forkreq );
      
      connectNodePorts( m_philosopher3.l_forkreq, m_fork3.r_forkreq );
      connectNodePorts( m_philosopher2.r_forkreq, m_fork3.l_forkreq );
      
      connectNodePorts( m_philosopher4.l_forkreq, m_fork4.r_forkreq );
      connectNodePorts( m_philosopher3.r_forkreq, m_fork4.l_forkreq );
      
      connectNodePorts( m_philosopher1.sitreq,   m_footman.sitreq_1   );
      connectNodePorts( m_philosopher1.standreq, m_footman.standreq_1 );

      connectNodePorts( m_philosopher2.sitreq,   m_footman.sitreq_2   );
      connectNodePorts( m_philosopher2.standreq, m_footman.standreq_2 );

      connectNodePorts( m_philosopher3.sitreq,   m_footman.sitreq_3   );
      connectNodePorts( m_philosopher3.standreq, m_footman.standreq_3 );

      connectNodePorts( m_philosopher4.sitreq,   m_footman.sitreq_4   );
      connectNodePorts( m_philosopher4.standreq, m_footman.standreq_4 );
    }
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example representation of the init function for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}

\section{Conclusion}\label{conclusion}



\clearpage
\appendix
\bibliographystyle{alpha}
\bibliography{literature}

\end{document}
