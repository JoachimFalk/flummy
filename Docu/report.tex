\newcommand{\graphicPostfix}{pdf}
\newcommand{\resdir}{../../../HscdTeXRes/}
%%\newcommand{\code}[1]{\texttt{#1}}
%%\newcommand{\SysteMoC}{{\bf SysteMoC}}
%%\newcommand{\SysteMoCV}{\SysteMoC{} {\bf 1.0}}
\newcommand{\code}[1]{\emph{#1}}
\newcommand{\SysteMoC}{\emph{SysteMoC}}
\newcommand{\SysteMoCV}{\emph{SysteMoC 1.0}}

\input{\resdir format.tex}

\usepackage{multirow}
\usepackage{fancyvrb}

% Use a small font for the verbatim environment
\makeatletter  % makes '@' an ordinary character
\renewcommand{\verbatim@font}{%
  \ttfamily\small\catcode`\<=\active\catcode`\>=\active%
}
\makeatother   % makes '@' a special symbol again

% \begin{Verbatim}[fontsize=\tiny]

\hypersetup{
  pdftitle   = {Representing Models of Computation in SystemC},
  pdfsubject = {Co-Design-Report},
  pdfauthor  = {\textcopyright\ Joachim Falk, Christian Haubelt, J\"urgen Teich},
  colorlinks = true,
  linkcolor  = black,
  anchorcolor= black,
  citecolor  = black,
  filecolor  = black,
  menucolor  = black,
  pagecolor  = black,
  urlcolor   = black
}

\begin{document}
\hscdtitle{Representing Models of Computation in SystemC}
{Joachim Falk, Christian Haubelt, J\"urgen Teich}{\today}
\clearpage
\tableofcontents
\clearpage

\section{Introduction\label{intro}}
Due to rising design complexity it is necessary to increase
the level of abstraction at which systems are designed. In
today's embedded systems the specification is mostly mapped
into a set of interacting tasks and hardware modules, which 
interact by the use of shared variables and various ways of
message passing. To guarantee exclusive access to the shared
variables and resources, mutually exclusive devices like semaphores,
mutexes, and monitors are used. But this unstructured use
of communication types lead to hardly analyzable systems.
However, by constraining the type of communication
used between tasks and the communication behavior of the tasks,
expressiveness is traded for analyzability.

\emph{Models of computation}
\cite{embsft:2002}, in the following called \emph{MoCs}, are
predefined types of communication and strategies for scheduling
communicating tasks. Thus, MoCs are comparable to design
patterns known from the area of software design \cite{gamma:1995}.
Limiting the expressiveness of an MoC enables:

\begin{enumerate}
\item Mathematically reasoning about communication patterns

\item Code generators to produce optimized code

\item Verification tools to check system properties automatically
\end{enumerate}

On the other hand, modern embedded system design is still based on
specification languages which allow unstructured communication.
Even worse, nearly all specification languages allow for Turing
complete MoCs making analysis in general impossible.
To make industry benefit from the best of both worlds,
engineers must restrict themselves to use certain subsets of
specification languages allowing for analyzability, identification,
and extraction of these MoCs from the source code automatically.

This report deals with the representation of some transformative
MoCs in SystemC. The rest of the report is structured as follows:
In Section~\ref{related-work}, we discuss related work. In
Section~\ref{aspect-overview}, we propose our framework for
representing MoCs in SystemC. In Section~\ref{revision-of-mocs},
we show how some MoCs fit into
the framework presented before. In Section~\ref{software-architecture}
an implementation of our framework in SystemC called \SysteMoC{} is
presented. Finally, we will give some examples using the \SysteMoC{}
framework in Section~\ref{systemoc-examples}, and we conclude
the present report in Section~\ref{conclusion}.

\section{Related Work}\label{related-work}

\section{Aspect Overview}\label{aspect-overview}

A model of computation \cite{embsft:2002} is defined as the 
interaction policy between \emph{actors} in an \emph{actor-oriented} design
\cite{agha97abstracting:1997}.
Actors are objects which execute concurrently. They can only
communicate with the environment (other actors) through their \emph{actor ports}.
The actor ports are connected with each other via a \emph{channel network}.
The data values, which are communicated over the channels
are abstracted. The values are called \emph{tokens} regardless
of their type or value.

Instead of a monolithic approach for representing an executable specification,
in this report, we will separate a specification into several
independent \emph{aspects}.
This is a refinement of actor-oriented design.
In actor-oriented design, actors only
communicate with each other via channels instead of method calls as known
in object-oriented design. In our proposed methodology, the specification is more
detailed than in actor-oriented design.
Four different aspects for distinguishing MoCs can be identified,
namely node functionality, node interface, network graph, and
channel kind. An aspect can be further divided into
\emph{aspect types} by different constraints placed on the aspect.
In the following, the aspects and their further
differentiation into aspect types is discussed in depth:

\subsection{Node Functionality}\label{node-functionality}

In our methodology proposed in this report, the actor concept is still used,
but we distinguish two different aspects.
The first part called \emph{node functionality} is responsible
for transforming data values. The node functionality can be
thought of as a function $F: V^{m} \to V^{n}$  which maps a fixed set
of parameters to a fixed set of results. The node functionality
can be implemented by a Turing-complete programming language but
the user must guarantee, that the node functionality terminates,
does not communicate with other actors and is deterministic.
The node functionality is the only aspect which is not
further distinguished into aspect types.

\subsection{Node Interface}\label{node-interface}

The second part of an actor which determines its communication
behavior is called \emph{firing rules}. The firing rules
determine for each actor port the number of tokens to receive or send
until the associated node functionality can be invoked.
%\begin{definition}\label{firing-rules}
%Firing rule is a set of functions $F: $
%\end{definition}
These firing rules are
constructed by the use of communication operations which are
provided by the \emph{node interface}. Furthermore, we
distinguish three separate \emph{node interface types} by the set
operations available to them:


\begin{definition}\label{choice-node-interface-type}
  Choice node interface type
  
  \emph{Choice} is an operation defined on a set of actor ports $A_{P}$
  and a function $D: A_{P} \to \mathcal{F}$, which maps each actor port
  $a_{p} \in A_{P}$ to a function $F_{x} \in \mathcal{F}$.
  The choice operation postpones the process execution 
  until at least one actor port $a_{p} \in A_{P}$
  becomes ready to communicate. The set of actor ports available
  is given by $A_{P_{ready}}$.
  Exactly one actor port $a_{p} \in A_{P_{ready}}$
  will be chosen nondeterministically. After
  finishing the communication on the chosen actor port $a_{p}$
  the process execution will continue
  with function $F_{continue} = D(a_{p})$.
\end{definition}

\begin{definition}\label{transact-node-interface-type}
  Transact node interface type
\end{definition}

\begin{definition}\label{fixed-transact-node-interface-type}
  Fixed transact node interface type
\end{definition}

\subsection{Network Graph}\label{network-graph} 

To represent an executable specification, not only information about
individual actors but also information about the communication network,
which is the only means of communication between actors,
must be provided. Moreover, information about hierarchical
composition of actors is required. This information is stored in
the \emph{network graph}.

\begin{definition}
A network graph is a 5-tuple $N=(\mathcal{A},C,P_{i},P_{o},E)$ containing
a set of actors $\mathcal{A}$, a set of channels $C$, a set of uplevel
input ports $P_{i}$, a set of uplevel output ports $P_{o}$ and a set of
directed edges $E \subseteq ((P_{i} \cup C) \times \mathcal{A}_{P_{i}})
\cup (\mathcal{A}_{P_{o}} \times (P_{o} \cup C))$.
Each actor $A \in \mathcal{A}$ can only communicate with other actors
through its dedicated actor input ports $A_{P_{i}}$ and
actor output ports $A_{P_{o}}$.
% $\forall{(X,Y)\in \mathcal{A^2}}: X \ne Y \Rightarrow X_{P} \cap Y_{P} = \emptyset$
Furthermore, we define the set of all input and output ports of an actor
as $A_{P} = A_{P_{i}} \cup A_{P_{o}}$,
the set of all actor input ports of the network graph as
$\mathcal{A}_{P_{i}} = \bigcup{}_{A \in \mathcal{A}} A_{P_{i}}$,
the set of all actor output ports of the network graph as 
$\mathcal{A}_{P_{o}} = \bigcup{}_{A \in \mathcal{A}} A_{P_{o}}$,
and the set of all actor input and actor output ports of the network graph as
$\mathcal{A}_{P} = \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}}$.

\end{definition}

There are two network graph types which are distinguished by our methodology:

\begin{definition}\label{petri-network-graph}
  A Petri network graph is constrained such that exactly
  one edge is incident to each actor port
  $\forall{p \in \mathcal{A}_{P}}: |(C \times \{p\}) \cap E| = 1$.
\end{definition}

\begin{figure}
\centering
%\includegraphics[scale=1]{ng-petri.\graphicPostfix}\\
\input{ng-petri-fig.tex}
\caption{\label{ng-petri}
  In a \emph{petri network graph} exactly
  one edge enters an actor input port. The
  indegree and outdegree of channels are
  unconstraint. See for example channel $c_2$
  which has both an indegree and outdegree of
  two.}
\end{figure}

  An example of a petri network graph is shown in Figure~\ref{ng-petri}.
  It demonstrates the use of a petri network graph in modelling
  a MAC unit which accumulates in channel $c_2$ the product of
  the values read in from the uplevel input ports $p_{i_1}$ and $p_{i_2}$.
  The uplevel input port $p_{i_3}$ is used to exchange the
  accumulated value in $c_2$ with the input from $p_{i_3}$. The
  old value of $c_2$ is send to the uplevel output port $p_{o_1}$
  via the exchange actor $a_3$. The model uses the nondeterminism
  of the petri network graph which allows to read the value of channel
  $c_2$ from different actors to either accumulate additional
  data via actor $a_2$ or exchange the value via actor $a_3$.

\begin{definition}\label{dataflow-network-graph}
  A Dataflow network graph is a petri network graph with the additional constraint
  that the indegree and outdegree of each channel in the graph is exactly one
  $\forall{c \in C}: |(\{c\} \times \mathcal{A}_{P_{i}}) \cap E| = 1 \wedge
                    |(\mathcal{A}_{P_{o}} \times \{c\}) \cap E| = 1$.
\end{definition}

  An example of a dataflow network graph is shown in Figure~\ref{ng-dataflow}.
  It demonstrates the use of a dataflow network graph in modelling
  a MAC unit which accumulates in channel $c_2$ and $c_3$ the product of
  the values read in from the uplevel input ports $p_{i_1}$ and $p_{i_2}$.
  Additionally for each value pair from $p_{i_1}$ and $p_{i_2}$ the
  new accumulated value is send to the output port $p_{o_1}$ via
  the fork actor $a_3$. The fork actor duplicates its received
  value on $a_{3_{pi1}}$ to its outputs $a_{3_{po1}}$ and $a_{3_{po2}}$.

\begin{figure}
\centering
%\includegraphics[scale=1]{ng-dataflow.\graphicPostfix}\\
\input{ng-dataflow-fig.tex}
\caption{\label{ng-dataflow}
  In a \emph{dataflow network graph} exactly
  one edge enters an actor input port and
  the channels can only be used for dedicated
  Point-to-Point connections.}
\end{figure}

\subsection{Channel Kind}\label{channel-kind}

The \emph{channel kind} defines the communication semantic of the channel.
Since the communication semantic is not influenced by the
data type communicated, the actual \emph{type} of a communication
channel is derived from the channel kind by parameterizing it with
the type of the communicated data. Examples for channel kinds are:

\begin{itemize}
\item \label{channel-kind-fifo} FIFO:
  An unbound FIFO channel for communication
  (nonblocking write and blocking read) implementing
  an first in first out discipline.

\item \label{channel-kind-rendezvous} Rendezvous:
  A rendezvous channel for communication % and barrier synchronisation
  (blocking write and read).

\item \label{channel-kind-register} Register:
  For expressing communication via shared variables
  (nonblocking write and nonblocking read).
\end{itemize}

\section{Revision of Different MoCs}\label{revision-of-mocs}

The characteristics of different MoCs can be separated into two distinct groups.
There are the execution characteristics which must be provided by
the programming system otherwise the MoC cannot be implemented.
On the other hand, there are the analysis characteristics which
permit the extraction of information needed for MoC specific analysis.

In the following subsections, different MoCs are considered and their
characteristics are determined. For each MoC these characteristics are
mapped onto the aspects presented in the previous Section.

\subsection{Communicating Sequential Processes (CSP)}
\emph{Communicating Sequential Processes} \cite{csphoare:1985}
is a MoC which consist of concurrently executing processes
which communicate via unidirectional \emph{rendezvous channels}.
As a difference to the CSP model of Hoare \cite{csphoare:1985}
which allows runtime creation of processes via parallel
composition and recursion, the CSP model considered in this report
is constraint to a fixed predetermined set of processes.
This constraint is required to allow hardware synthesis from this
model.

The following characteristics are the execution characteristics to
implement CSP behavior:

\begin{characteristic}\label{characteristic-csp-rendezvous}
  Rendezvous channel for communication
\end{characteristic}

\begin{characteristic}\label{characteristic-csp-general-choice}
  A communication method for Hoare's so-called \emph{general choice}
  
  General choice written $ce_{1} \to F_1 \Box ce_{2} \to F_2$
  is a operation defined on a set of \emph{channel expressions} $CE$ and
  a function $D: CE \to \mathcal{F}$, which maps each channel expression
  $ce \in CE$ to a function $F_{x} \in \mathcal{F}$. A channel
  expression can either send the content of a variable $v$ into
  the channel $c$ which is written $c!v$ or receive a value from
  the channel $c$ and store it in variable $v$ which is written
  $c?v$. A channel expression is ready to communicate when its
  associated channel is ready to communicate.
  The general choice operation postpones the process execution 
  until at least one channel expression $ce \in CE$
  becomes ready to communicate. The set of channel expressions
  ready to communicate is given by $CE_{ready}$.
  Exactly one channel expression $ce \in CE_{ready}$
  will be chosen nondeterministically. After
  finishing the communication for the chosen channel expression $ce$
  the process execution will continue
  with function $F_{continue} = D(ce)$.

\end{characteristic}

\begin{characteristic}\label{characteristic-csp-concurrent-processes}
  Fixed set of concurrently executing processes
  
  The CSP \emph{parallel composition} operation written $F_1 \| F_2$ executes the
  function $F_1$ and $F_2$ in parallel and terminates when both functions
  have terminated. By using recursion and parallel composition
  like $X = F_1 \| X$, CSP enables unlimited runtime creation of processes.
  Our CSP MoC only allows a fixed static number of processes. This
  leads to the constraint that only CSP programs can be represented which
  have a single init function which must not be called recursively. This init
  function creates all processes needed in the CSP program via parallel composition.
  Other functions in the CSP program must not use the parallel composition
  operation.
\end{characteristic}

%\item Sequential composition of functions
%  
%  Sequential composition written $F_1 \to F_2 \to F_3 \to \cdots$
%  is 
% $\to$ is sequential composition

In the following, a CSP program for the classical dining
philosophers problem is demonstrated. To reduce the complexity
of the example the number of philosophers has been reduced from five
to two. Each philosopher has only two goals in life to think and
to eat. Food is provided by a bowl of spaghetti on the table and
two forks for eating. To eat, each philosopher has to take a seat
at the table and take two forks which he will not release until he
is no longer hungry. As anybody knows this can lead to a deadlock.
This deadlock can can be eliminated by a footman which will only
allow philosopher to take a seat at the table if there are more
forks than philosophers at the table (See Figure~\ref{fig:dining-philosophers}
for the processes and connection topology used in the example).
The implementation demonstrates the use of the general choice operator
in the $Footman$ and the $Fork_{x}$ which are used to react to the first
philosopher requesting something from footman or fork.

\begin{figure}[h]
\centering
\input{dining-philosophers-fig.tex}
\caption{Processes and connection topology used for the ``Dining philosophers'' CSP example}
\label{fig:dining-philosophers}
\end{figure}

\begin{displaymath}
\begin{array}{rcl}
Philosopher_{i}    & := & FootSit_{i}!sit \to ForkReqL_{i}!take \to ForkReqR_{i\oplus1}!take \to \\
		   &    & Eat \to \\
		   &    & ForkReqL_{i}!drop \to ForkReqR_{i\oplus1}!drop \to FootStand_{i}!stand \to \\
		   &	& Philosopher_{i} \\
Fork_{i}	   & := & ForkReqR_{i}?req_{r} \to ForkReqR_{i}?req_{r} \to Fork_{i} \Box \\
		   &    & ForkReqL_{i}?req_{l} \to ForkReqL_{i}?req_{l} \to Fork_{i} \\
Footman		   & := & FootSit_{0}?req_{0} \to FootStand_{0}?req_{0} \to Footman \Box \\
		   &    & FootSit_{1}?req_{1} \to FootStand_{1}?req_{1} \to Footman \\
InitFunction       & := & Philosopher_{0} \| Fork_{0} \| \\
		   &    & Philosopher_{1} \| Fork_{1} \| \\
		   &    & Footman \\
\end{array}
\end{displaymath}

Where $\oplus$ is addition modulo 2 and $\to$ has higher precedence than $\Box$.

To facilitate analysis of the CSP MoC, additionally the following
analysis characteristics must be given:
\begin{characteristic}\label{characteristic-csp-communication}
  Parallel executing processes must only communicate over Point-to-Point rendezvous channels.
\end{characteristic}

The characteristics \ref{characteristic-csp-rendezvous} -
\ref{characteristic-csp-communication} of the CSP MoC are mapped in the following way
onto the aspects presented in Section~\ref{aspect-overview}.
(i) The rendezvous communication %(Requirement~\ref{characteristic-csp-rendezvous})
used by CSP is provided by the channel kind rendezvous %(See~\ref{channel-kind-rendezvous})
(ii) Hoare's general choice communication operator %(Requirement~\ref{characteristic-csp-general-choice})
is provided as a operation in the choice node interface %(See~\ref{choice-node-interface-type})
(iii) The parallel executing processes %(Requirement~\ref{characteristic-csp-concurrent-processes})
created by the init functions are mapped to the concurrently executing actors
%% (Subsection~\ref{node-functionality} and Subsection~\ref{node-interface})
(iv) The Point-to-Point communication of CSP over rendezvous channels %(Requirement~\ref{characteristic-csp-communication})
is provided by the dataflow network graph %(See~\ref{dataflow-network-graph})
and its contained rendezvous channels, which are the only means of communication in a
actor-oriented design.

\subsection{Kahn Process Network (KPN)}
\emph{Kahn Process Network} \cite{kahn:1974} is a MoC
which consist of a fixed predetermined set of
concurrently executing processes which communicate via unidirectional
unbounded \emph{FIFO channels}. The input and output of a channel
are connected to dedicated processes. The process must implement
a continuous function $F: S^m \to S^n$ regarding a prefix order on
$S^m$ and $S^n$ \cite{kahn:1974} \cite{stark87concurrent:1987}.
Where $S^m$ is a m-tuple of token sequences on the process input channels
and $S^n$ is a n-tuple on token sequences on the process output channels.
If the communication over FIFO channels is realized with blocking
reads and nonblocking writes the previous requirement is automatically
satisfied \cite{stark87concurrent:1987}. However the next channel
selected for a FIFO read or write operation can dependent on
the data values already read and the state of the actor.

% connected to the process of the process actor input
% port a number of tokens dependent on the port and the state
% of the actor must be available.
% Two closely related
% forms of dataflow are distinguished in the literature \cite{LeeDenotialDF:1997},
% Kahn Process Networks \cite{kahn:1974}, in the following 
% called KPN, and Dennis Dataflow \cite{}, in the following
% called DDF. DDF is an extension of KPN by the notion of
% firing. To enable firing of a DDF process each channel $c \in C$
% used as input by the process must have a certain number of
% tokens 

The following execution characteristics are required to
implement KPN behavior:

\begin{characteristic}\label{characteristic-kpn-fifo}
  An unbound FIFO channel for communication
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-fifo-read-write}
  A communication method to read from and write to FIFOs
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-concurrent-processes}
  Fixed set of concurrently executing processes
\end{characteristic}

In the following, a example dataflow program for audio coding
is demonstrated. For the audio encoding an algorithm
adapted for multimedia audio or an algorithm adapted for speech
is dynamically selected depending on the input audio stream.
The CodecSelect actor forwards the raw audio stream to the
selected audio codec and gets feedback of the codec quality back
via the corresponding CodecQuality channel. If a certain
limit for the codec quality is not satisfied the CodecSelect will
switch to the other audio codec. Additionally the CodecSelect actor
signals the StreamPacketizer via the PacketizerCodecSelect channel
which EncodedAudio channel to choose for input data to packetize.
(See Figure~\ref{fig:media-speech-audio-coding}
for the processes and connection topology used in the example):

\begin{figure}[h]
\centering
\input{media-speech-audio-coding-fig.tex}
\caption{Processes and connection topology used for the audio encoding dataflow example}
\label{fig:media-speech-audio-coding}
\end{figure}

To facilitate analysis of the KPN MoC additionally the following
characteristics must be satisfied:
\begin{characteristic}\label{characteristic-kpn-communication}
  Parallel executing processes must only communicate over Point-to-Point FIFO channels.
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-determinism}
  The process must implement a continuous function $F: S^m \to S^n$
\end{characteristic}

The characteristics \ref{characteristic-kpn-fifo} -
\ref{characteristic-kpn-determinism} of the KPN MoC are mapped in the following way
onto the aspects presented in Section~\ref{aspect-overview}.
(i) The FIFO communication
used by dataflow is provided by the FIFO channel kind
(ii) The fixed set of concurrently executing processes
are mapped to the concurrently executing actors
(iii) The Point-to-Point communication of dataflow over FIFO channels
is provided by the dataflow network graph
and its contained FIFO channels, which are the only means of communication in a
actor-oriented design
(iv) read and write operations on this FIFOs are provided by
the transact operation of the transact node interface
(v) The requirement for a continuous function is satisfied by using the
transact operation of the transact node interface.
The transact operation consumes and produces
a determined number of tokens on the actor ports
depending on the current state of the actor.
The node functionality must be deterministic, too.
Therefore the actor implements a function regarding the
prefix order on $S^m$ and $S^n$. Because the
transact functions does not allow canceling of already
written output of actor output ports, the functions is
monotonic. Fortunately, this means in practice
that the function is also continuous since practical monotonic
processes are invariably continuous, at least in the context
of Kahn process networks \cite{LeeDenotialDF:1997}.

\subsection{Synchronous Dataflow (SDF)}
Synchronous Data Flow \cite{Lee87b:1987} is a more constricted form of the
KPN MoC. It has all the characteristic of the KPN MoC and additionally the
following characteristic necessary for MoC analysis.

\begin{characteristic}\label{characteristic-sdf-fixed-rates}
The consumption and production rates of the actor must be constant.
In particular they are independent from the state of the actor.
\end{characteristic}

The characteristics \ref{characteristic-kpn-fifo} -
\ref{characteristic-sdf-fixed-rates} of the SDF MoC are mapped in the following way
onto the aspects presented in Section~\ref{aspect-overview}. (i) - (iii) is identical
to the KPN MoC
(iv) read and write operations on the FIFOs are provided by the transact
operation of the fixed transact node interface
(v) The constant consumption and production rates of the actor are
guaranteed by the fixed transact node interface which does
not allow the alteration of these rates once set.

\section{Software Architecture}\label{software-architecture}

Due to its high abstraction level and possibilities for both
hardware and software refinements, we have chosen SystemC
\cite{systemc-lrm:2003} \cite{glms:2002} as our language for system design.
SystemC is an actor-oriented C++ based design framework and
already allow to express dataflow MoCs. 

In the following, we propose a SystemC framework, called \SysteMoC, which
facilitates automatic extraction of the MoC of a SystemC design.
Actors in SystemC are C++ classes which are derived from the base class \code{sc\_module}.
The \SysteMoC{} framework provides the execution requirements for each MoC while
still supporting the extraction of the information needed for analysis.
This analysis is made possible by dividing the actor into its
node functionality and its node interface.
Furthermore, the \SysteMoC{} framework provides a way for these
actors to be connected to each other, via their ports. This connections
are provided by the network graph.
%Actors can have their own thread of control or be without. Actors
%with their own thread of control will be called in the following
%active actors and actors without a dedicated thread of control
%passive actors.

\begin{figure}
\centering
\begin{verbatim}
template <typename T>
class m_adder // Actor m_adder
  : public hscd_fixed_transact_node // Node interface
{
public:
  hscd_port_in<T>  in;
  hscd_port_out<T> out;
private:
  // Node functionality
  void transform() {
    out[0] = in[0] + in[1];
    std::cout << "Adding " << in[0] << " + " << in[1]
              << " = " << out[0] << std::endl;
  }
  
  // Firing rules
  void process() {
    while (true) {
      transform();
      transact();
    }
  }
public:
  m_adder( sc_module_name name )
    :hscd_fixed_transact_node( name,
        in(2) & out(1) /* Firing rules */ ) {}
};
\end{verbatim}
\caption{\label{example-adder-actor}Example of an adder in the \SysteMoC{} framework}
\end{figure}

\begin{figure}
\centering
\begin{verbatim}
template <typename T>
class m_multiply // Actor m_multiply
  : public hscd_fixed_transact_node // Node interface
{
public:
  hscd_port_in<T>  in1;
  hscd_port_in<T>  in2;
  hscd_port_out<T> out;
private:
  // Node functionality
  void transform() {
    out[0] = in1[0] + in2[0];
    std::cout << "Multiplying" << in1[0] << " * " << in2[0]
              << " = " << out[0] << std::endl;
  }
  
  // Firing rules
  void process() {
    while (true) {
      transform();
      transact();
    }
  }
public:
  m_multiply( sc_module_name name )
    :hscd_fixed_transact_node( name,
        in1(1) & in2(1) & out(1) /* Firing rules */ ) {}
};
\end{verbatim}
\caption{\label{example-multiply-actor}Example of a multiplier in the \SysteMoC{} framework}
\end{figure}

\subsection{Node Functionality}
The node functionality is only used for algorithmic transformations of data values.
The node functionality of an actor is defined in certain member functions,
which are called by the firing rules if their requirements for input data is met.
This member functions are not allowed to call communication operations and
the input and output data values used are read from
and written to the actor ports. All actor ports are globally accessible
by the actor member functions and can therefore be used to get input data
and place output data for the node functionality
(See Figure~\ref{example-adder-actor} method \code{transform} for an example of a node functionality).

\subsection{Node Interface Hierarchy}
The problem of extracting the communication behavior of an actor is caused by the fact,
that the communication methods in SystemC are all accessible to all SystemC modules.
And execution of these methods is controlled by the Turing equivalent coding possibilities
in the actor. To partially redress these problems we introduced the node interface aspect
which determines what communication methods are available to an actor. This is implemented
by disallowing all communication methods on \SysteMoC{} channels and providing them instead
in a base class from which the actor is derived. Therefore the node interface of an actor
corresponds to the base class from which the actor is derived
(See Table~\ref{node-interface-c++} for mapping of the node interface names to their
corresponding C++ class types).
Communication over other media than \SysteMoC{} channels is forbidden but this cannot be enforced
because the full power of SystemC should be available for the node functionality part
of the actor. So we require form the \SysteMoC{} user the assurance that the
node functionality does terminate and does not communicate with other actors.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
 Node interface & \SysteMoC{} node interface type \\
\hline \hline
 Choice Node          & \code{hscd\_choice\_node} \\
 Transact Node        & \code{hscd\_transact\_node} \\
 Fixed Transact Node  & \code{hscd\_fixed\_transact\_node} \\
\hline
\end{tabular}
\caption{\label{node-interface-c++}Node interfaces represented as \SysteMoC{} classes}
\end{table}

The following subset of the requirements enumerated in Section~\ref{revision-of-mocs}
determines the node interface of the corresponding MoCs:

\begin{enumerate}
\item Choice Node
  \begin{itemize}
  \item  A communication method which implements Hoare's 'general choice' operator \cite{csphoare:1985}.
  \end  {itemize}
\item Transact Node
  \begin{itemize}
  \item A communication method to read from and write to ports.
  \item Assurance that the arrival sequence of tokens at
        their ports cannot be determined.
  \end  {itemize}
\item Fixed Transact Node
  \begin{itemize}
  \item A communication method to read from and write to ports.
  \item Assurance that the arrival sequence of tokens at
        their ports cannot be determined.
  \item Assurance that consumption and production rates cannot
        be altered once set
  \end  {itemize}
\end{enumerate}

These requirements build a hierarchy of decreasing capability. The node
interface of CSP is the most capable in the hierarchy and it
fulfills the execution requirements of all more constraint interfaces.
To fulfill the execution requirement of KPN the general choice operator
can be used to implement the communication method for KPN by constraining
the list of actor ports for the choice operation to one and therefore
eliminating the choice between different actor ports.
The execution requirement of SDF are the same than that of KPN and can
therefore be fulfilled by the node interface of KPN.

However the analysis requirements of the MoC in the hierarchy
get progressively more constraining and therefore the power
of the communication operations in the node interface must
be reduced accordingly to meet them.

\begin{figure}
\centering
\includegraphics[scale=0.5]{NodeInterfaceHierarchy.\graphicPostfix}\\
\caption{\label{node-interface-hierarchy}Node interface hierarchy as UML}
\end{figure}

The hierarchy of the requirements is transformed into a C++ inheritance
hierarchy with the CSP node interface at the root (See Figure~\ref{node-interface-c++}).
Less capable node interfaces inherit from more capable ones. The
less capable node interfaces use the communication operations from the base class node
interface to implement their own operations. The communication operations of the
base class are disabled by declaring them private.

\begin{enumerate}
\item CSP
  \begin{itemize}
  \item  \code{choice( a(1) $\arrowvert$ b(2) )}

    This communication operation gets a list of actor ports (e.g. $a$, $b$) which
    are parameterized with the number of tokens that must be communicated
    over the port. The operations communicates over that actor port which is first ready
    for communication. If no port is ready for communication the operation blocks until
    at least one port is ready. Should more than one actor port be ready for
    communication at the same instance one of them is chosen nondeterministically.
  \end  {itemize}
\item KPN
  \begin{itemize}
  \item \code{transact( a(1) \& b(2) )}

    This communication operation gets a list of actor ports (e.g. $a$, $b$) which
    are parameterized with the number of tokens that must be communicated
    over the port. The operations blocks until all requested tokens on the ports
    have been communicated.
  \end  {itemize}
\item SDF
  \begin{itemize}
  \item \code{transact(), hscd\_fixed\_transact\_node( ..., a(1) \& b(2) )}

    Actors are C++ classes which are derived of their node interface class.
    The consumption and production rates for SDF Actors must be fixed, therefore
    the node interface of a SDF-Actor is parameterized with the consumption and production
    rates of the SDF-Actor (See actor constructor in Figure~\ref{example-multiply-actor} for an
    example of fixed consumption and production rates). The communication operation \code{transact} is
    therefore missing the port list which is available to KPN nodes.
  \end  {itemize}
\end{enumerate}

\subsection{Network Graph Type}

To complete a executable specification in \SysteMoC{} additionally
to the information about the actors, information about the connections
of the actors with each other is needed. This information is stored
in the network graph part of the executable specification, which can
be categorized into two different network graph types as defined in
Subsection~\ref{network-graph}.

The network graph is represented by a user provided C++ class, in the following called
network graph class. This class is derived from a \SysteMoC{} graph type class which
provides the methods needed to assemble the network graph in the constructor
of the network graph class. Once the constructor has finished the network graph must
be fully assembled. No alteration at a later date is allowed.
The methods provided by the \SysteMoC{} graph type class together with runtime checks
in these methods constrain the constructed network graph to conform to the corresponding
network graph type.
Therefore the network graph type of a network graph can be determined by looking
at the base class of the network graph class.
(See Table~\ref{network-graph-c++} for mapping of the network graph types to their
corresponding \SysteMoC{} graph type classes).

\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
 Network graph type   & \SysteMoC{} graph type class \\
\hline \hline
 Petri Choice Node    & \code{hscd\_graph\_petri} \\
 Transact Node        & \code{hscd\_graph\_sdf} \\
\hline
\end{tabular}
\caption{\label{network-graph-c++}Network graph types represented as \SysteMoC{} classes}
\end{table}

To construct the network graph the following methods are available for
composition of a network graph of the desired type:
\begin{enumerate}
\item Petri network graph

  \begin{itemize}
  \item registerNode:
    This method is used to add one actor $A$ to the set of actors $\mathcal{A}$
    of the network graph.

  \item registerChan:
    This method is used to add one channel $c$ to the set of channels $C$
    of the network graph. This functions takes an optional parameter which can
    be used to specify the initial state of the new channel, which is
    for example used for the count of initial tokens of a FIFO channel.

  \item connectChanPort:
    This method adds one edge $e \in C \times \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}} \times C$
    between channels and actor ports to the network graph.

  \item connectInterfacePorts
    This method adds one edge $e \in P_{i} \times \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}} \times P_{o}$
    between actor ports and uplevel ports to the network graph.

  \end{itemize}

\item Dataflow network graph

  \begin{itemize}
  \item registerNode: Same method as defined for petri network graphs.
  
  \item connectInterfacePorts: Same method as defined for petri network graphs.
  
  \item connectNodePorts:
    This method is a shorthand for adding one channel and
    connecting two actor ports via this channel. Only channels
    which are connected to a dedicated output actor port and
    a dedicated input actor port can be realized with it.
    This method takes an optional parameter which fulfils
    the same function as the parameter for method registerChan.
  
  \end{itemize}

\end{enumerate}

\subsection{Channel Kind}

SystemC is an actor-oriented design framework, it has the concepts
of actors and channels. So the channel kind aspect of the \SysteMoC{}
framework can cleanly be implemented as a base class of a channel in SystemC.
The channel kind determines the communication semantic of a channel but not
the data type of the tokens. The channel type is a template parameterized
with the data type for the tokens and derived from the channel kind.
Identifying the channel kind with a base class instead of a template enables
easier type signature checks of C++ for the enforcement of a particular
channel kind of a channel instance.

Further differences between \SysteMoC{} channels and a SystemC channels consist of the
absence of user callable methods for communicating on the \SysteMoC{} channels.
Having those communication methods on the channels would contradict the separation
of node interface and channel kind. The mapping of channel kind to corresponding C++
class types is displayed in Table~\ref{channel-kind-c++}.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
 Channel kind & \SysteMoC{} type \\
\hline \hline
 FIFO         & \code{hscd\_fifo\_kind} \\
 Rendezvous   & \code{hscd\_rendezvous\_kind} \\
\hline
\end{tabular}
\caption{\label{channel-kind-c++}Channel kinds represented as \SysteMoC{} classes}
\end{table}

\subsection{Constraint Set Composition for MoCs}

In Section~\ref{revision-of-mocs} we have demonstrated how
to map the requirements of some MoCs to the aspects presented
in Section~\ref{aspect-overview}. Furthermore, the analysis
requirement of these MoCs translate into certain constraints
on the aspects presented before. These constraints are
used to distinguish a aspect into aspect types. Therefore
for each MoC presented in Section~\ref{revision-of-mocs}
we have a set of aspect types, called \emph{constraint set} and
shown in table~\ref{constraintset-composition},
which represent the analysis requirements of this MoC.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
 Channel kind & Node interface & Network graph type & Constraint set \\
\hline \hline
 Fifo         & Fixed Transact node & Dataflow network graph & SDF constraint set \\
 Fifo         & Transact node       & Dataflow network graph & Dataflow constraint set \\
%% Fifo         & Choice node         & Dataflow network graph & FIFO CSP constraint set \\
 Rendezvous   & Choice node         & Dataflow network graph & CSP constraint set \\
\hline
\end{tabular}
\caption{\label{constraintset-composition}
  Composition of constraint set out of channel kind type, node interface type
  and network graph type}
\end{table}

The aspect types in the constraint set are node interface 
, channel kind and network graph. The node interface and
and channel kind are represented as \SysteMoC{} classes in
SystemC, the third network graph is represented as
a C++ template in \SysteMoC{}. Parameterizing this template
with the channel kind and node interface (As shown in
table~\ref{constraintset-c++}) leads to a C++
type which represents the constraint set in \SysteMoC{}.

\begin{table}[h]
\centering
\begin{tabular}{|l|p{6cm}|l|}
\hline
 Constraint set & Composition in C++ & \SysteMoC{} constraint set type \\
\hline \hline
 SDF constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_fixed\_transact\_node, hscd\_fifo\_kind$>$} &
  \code{hscd\_sdf\_constraintset} \\
\hline
 Dataflow constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_transact\_node, hscd\_fifo\_kind$>$} &
  \code{hscd\_df\_constraintset} \\
\hline
 CSP constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_choice\_node, hscd\_rendezvous\_kind$>$} &
  \code{hscd\_csp\_constraintset} \\
\hline
\end{tabular}
\caption{\label{constraintset-c++}Constraint sets represented as \SysteMoC{}
  classes and their composition in C++}
\end{table}

The executable specification with a certain constraint set is
represented by a user provided C++ class, called top class an example of
which is seen in Figure~\ref{example-sdf-constraintset}, which is
derived from the selected \SysteMoC{} constraint set type and by
user provided C++ classes representing the actors of the specification.
This actors are derived from a \SysteMoC{} node interface type which
meet the requirements of the selected constraint set. The network graph
is assembled in the constructor of the top class by using the
operators provided by the \SysteMoC{} network graph type.
Each actor registered with the \code{registerNode} method must implement
the parameterized node interface type of the constraint set or an even
less capable node interface type, which is enforced by the type signature
of the registerNode method and the node interface hierarchy.
Each registered channel must be of the parameterized channel kind,
enforcement is obtained by the type signature of the
the registerChan and connectNodePorts methods.

\begin{figure}[h]
\centering
\begin{verbatim}
class m_top2: public hscd_sdf_constraintset {
  public:
    hscd_port_in<int>  in1;
    hscd_port_in<int>  in2;
    hscd_port_out<int> out;
    
    m_top2()
      : hscd_sdf_constraintset()
    {
      m_adder<int>    &adder =
        registerNode(new m_adder<int>("adder"));
      m_multiply<int> &mult  =
        registerNode(new m_multiply<int>("multiply"));
      
      connectInterfacePorts( in1, adder.in1 );
      connectInterfacePorts( in2, mult.in1 );
      connectNodePorts( adder.out, mult.in2 );
      connectNodePorts( mult.out2, adder.in2,
        hscd_fifo<int>() << 13 /* Start marking */ );
      connectInterfacePorts( out, mult.out1 );
    }
};
\end{verbatim}
\caption{\label{example-sdf-constraintset}Example of a network graph for the SDF-Actor in the \SysteMoC{} framework}
\end{figure}

%determine the MoC of a SystemC model additionally to the information
%required about the actors of the model information is required about the
%type of the network graph (See Subsection~\ref{network-graph} for defined graph types).

%The MoC is represented as an actor which is derived from the \code{hscd\_structure}
%template parameterized with the node interface and the channel kind. This actor can only
%instantiate sub actors of a predetermined kind and connect their ports with a  predetermined
%kind of channel.

%%The MoC is now determined by the composition of the two aspects node interface
%%and channel kind as following:
%%
%%\begin{tabular}{|c||c|c|c|}
%%\hline
%% Channel kind & \multicolumn{3}{c|}{ Node interface } \\
%%\hline
%%              & Choice Node         & Transact Node      & Fixed Transact Node \\
%%\hline \hline
%% Fifo         & No well known name  & KPN                & SDF \\
%%\hline
%% Rendezvous   & CSP                 & No well known name & No well known name \\
%%\hline
%%\end{tabular}

\section{Examples of MoC in SystemC with SysteMoC}\label{systemoc-examples}

\subsection{The dining philosophers problem}

\begin{figure}
\centering
\begin{verbatim}
enum dp_forkreq_ty { FORK_TAKE, FORK_DROP };

class dp_fork
  : public hscd_choice_node {
public:
  hscd_port_in<dp_forkreq_ty> l_forkreq;
  hscd_port_in<dp_forkreq_ty> r_forkreq;
private:
  void process() {
    while ( 1 ) {
      choice( l_forkreq(1) | r_forkreq(1) );
      assert( (l_forkreq && !r_forkreq && l_forkreq[0] == FORK_TAKE) ||
              (r_forkreq && !l_forkreq && r_forkreq[0] == FORK_TAKE) );
      if ( l_forkreq ) {
        std::cout << "Fork " << name() << " taken by left philosopher !" << std::endl;
        transact( l_forkreq(1) );
        assert( l_forkreq && l_forkreq[0] == FORK_DROP );
        std::cout << "Fork " << name() << " droped by left philosopher !" << std::endl;
      } else {
        std::cout << "Fork " << name() << " taken by right philosopher !" << std::endl;
        transact( r_forkreq(1) );
        assert( r_forkreq && r_forkreq[0] == FORK_DROP );
        std::cout << "Fork " << name() << " droped by right philosopher !" << std::endl;
      }
    }
  }
public:
  dp_fork( sc_module_name name )
    : hscd_choice_node(name) {}
};
\end{verbatim}
\caption{\label{dining-philosophers-fork-systemoc}
  Example of the fork implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}


\begin{figure}
\centering
\begin{verbatim}
class dp_footman
  : public hscd_choice_node {
public:
  hscd_port_in<void> sitreq_1;
  hscd_port_in<void> sitreq_2;
  hscd_port_in<void> sitreq_3;
  hscd_port_in<void> sitreq_4;
  hscd_port_in<void> standreq_1;
  hscd_port_in<void> standreq_2;
  hscd_port_in<void> standreq_3;
  hscd_port_in<void> standreq_4;
private:
  void process() {
    int count = 4;
    
    while ( 1 ) {
      if ( count != 0 )
        choice( sitreq_1(1) | standreq_1(1) |
                sitreq_2(1) | standreq_2(1) |
                sitreq_3(1) | standreq_3(1) |
                sitreq_4(1) | standreq_4(1) );
      else
        choice(               standreq_1(1) |
                              standreq_2(1) |
                              standreq_3(1) |
                              standreq_4(1) );
      if ( sitreq_1 || sitreq_2 || sitreq_3 || sitreq_4 )
        --count;
      else
        ++count;
    }
  }
public:
  dp_footman( sc_module_name name )
    : hscd_choice_node(name) {}
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example of the footman implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}


\begin{figure}
\centering
\begin{verbatim}
class dp_philosopher
  : public hscd_choice_node {
public:
  hscd_port_out<dp_forkreq_ty> l_forkreq;
  hscd_port_out<dp_forkreq_ty> r_forkreq;
  hscd_port_out<void>          sitreq;
  hscd_port_out<void>          standreq;
private:
  void process() {
    while ( 1 ) {
      std::cout << "Philosopher " << name() << " want's to eat !" << std::endl;
      transact( sitreq(1) );
      l_forkreq[0] = FORK_TAKE;
      transact( l_forkreq(1) );
      r_forkreq[0] = FORK_TAKE;
      transact( r_forkreq(1) );
      std::cout << "Philosopher " << name() << " eating !" << std::endl;
      wait( sc_time(3,SC_NS) );
      l_forkreq[0] = FORK_DROP;
      transact( l_forkreq(1) );
      r_forkreq[0] = FORK_DROP;
      transact( r_forkreq(1) );
      std::cout << "Philosopher " << name() << " finish eating !" << std::endl;
      transact( standreq(1) );
      wait( sc_time(1,SC_NS) );
    }
  }
public:
  dp_philosopher( sc_module_name name )
    : hscd_choice_node(name) {}
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example of the philosopher implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}

\begin{figure}
\centering
\begin{verbatim}
class m_top
: public hscd_csp_constraintset {
  public:
    m_top( sc_module_name name )
      : hscd_csp_constraintset(name) {
      dp_fork        &m_fork1        = registerNode(new dp_fork("m_fork1"));
      dp_fork        &m_fork2        = registerNode(new dp_fork("m_fork2"));
      dp_fork        &m_fork3        = registerNode(new dp_fork("m_fork3"));
      dp_fork        &m_fork4        = registerNode(new dp_fork("m_fork4"));
      dp_philosopher &m_philosopher1 = registerNode(new dp_philosopher("m_philosopher1"));
      dp_philosopher &m_philosopher2 = registerNode(new dp_philosopher("m_philosopher2"));
      dp_philosopher &m_philosopher3 = registerNode(new dp_philosopher("m_philosopher3"));
      dp_philosopher &m_philosopher4 = registerNode(new dp_philosopher("m_philosopher4"));
      dp_footman     &m_footman      = registerNode(new dp_footman("m_footman"));
      
      connectNodePorts( m_philosopher1.l_forkreq, m_fork1.r_forkreq );
      connectNodePorts( m_philosopher4.r_forkreq, m_fork1.l_forkreq );
      
      connectNodePorts( m_philosopher2.l_forkreq, m_fork2.r_forkreq );
      connectNodePorts( m_philosopher1.r_forkreq, m_fork2.l_forkreq );
      
      connectNodePorts( m_philosopher3.l_forkreq, m_fork3.r_forkreq );
      connectNodePorts( m_philosopher2.r_forkreq, m_fork3.l_forkreq );
      
      connectNodePorts( m_philosopher4.l_forkreq, m_fork4.r_forkreq );
      connectNodePorts( m_philosopher3.r_forkreq, m_fork4.l_forkreq );
      
      connectNodePorts( m_philosopher1.sitreq,   m_footman.sitreq_1   );
      connectNodePorts( m_philosopher1.standreq, m_footman.standreq_1 );

      connectNodePorts( m_philosopher2.sitreq,   m_footman.sitreq_2   );
      connectNodePorts( m_philosopher2.standreq, m_footman.standreq_2 );

      connectNodePorts( m_philosopher3.sitreq,   m_footman.sitreq_3   );
      connectNodePorts( m_philosopher3.standreq, m_footman.standreq_3 );

      connectNodePorts( m_philosopher4.sitreq,   m_footman.sitreq_4   );
      connectNodePorts( m_philosopher4.standreq, m_footman.standreq_4 );
    }
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example representation of the init function for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}

\section{Conclusion}\label{conclusion}



\clearpage
\appendix
\bibliographystyle{alpha}
\bibliography{literature}

\end{document}
