\newcommand{\graphicPostfix}{pdf}
\newcommand{\resdir}{../../../HscdTeXRes/}
\newcommand{\code}[1]{{\bf #1}}
\newcommand{\SysteMoC}{{\bf SysteMoC}}
\newcommand{\SysteMoCV}{\SysteMoC{} {\bf 1.0}}

\input{\resdir format.tex}

\usepackage{multirow}

\begin{document}
\hscdtitle{Representing models of computation in SystemC}{Joachim Falk}{\today}
\clearpage
\tableofcontents
\clearpage

\section{Introduction\label{intro}}
Due to rising design complexity it is necessary to increase
the level of abstraction at which systems are designed. In
today's embedded software the specification ist mostly mapped
into a set of interacting tasks and hardware modules, which 
interact by the use of shared variables and various ways of
message passing. To guarantee exclusive access to the shared
variables and resources mutual exclusion devices like semaphores,
mutexes and monitors are used. But this unstructured use
of communication methods lead to hard to analyse systems.
However, by placing constraints on the type of communication method
used between tasks and the communication behaviour of the tasks
expressiveness is traded for analysability. A model of computation,
in the following called MoC, is a methodology for scheduling
the communicating tasks which requires a certain set of constraints.
Stricter constraints enable a MoC which can derive more facts
about the system which can be used to:

\begin{enumerate}
\item Mathematically reason about communication patterns

\item Enable code generators to produce better optimized code

\item Enable verification tools to check system properties like
      deadlock or memory consumption
\end{enumerate}
However, for these benefits to be practically realized, the
MoC must be extractable from the source code. Because the general case
is impossible to solve for a turing complete programming language
\footnote{Halting problem} a machine analyzable coding subset for
MoCs has to be defined.

\section{Concept overview}
\label{concept-overview}

Instead of a Monolitic approach for representing an executable specification
we choose to combine the specification out of  severel independent concepts.
This is a refinement of actor-oriented design. Actor-oriented design has actors which execute
concurrently and only communicate with each other via channels instead
of method calls as known in object-oriented design. In our
methodology the specification is even more finely divided than in
actor-oriented design.

\subsection{Node functionality}

In our methodology the actor concept is still used, but is split into two parts.
There is the part called node functionality which is responsible
for transforming data values. The node functionality can be
thought of as a function $F: V^{m} \to V^{n}$  which maps a fixed set
of parameters to a fixed set of results. The node functionality must
therefore terminate and it must not communicate with
other actors.

\subsection{Node interface}

The other part of the actor which determines the communication
behaviour of the actor is called firing rules. The firing rules
determine for each actor port the number of tokens needed
that a node functionality can be invoked.
%%Firing rules can be invoked
%%Examples of firing 
The node interface is the set of communication operations an
actor has available to construct its firing rules.

\subsection{Network graph}

To represent the executable specification not only information about
individual actors must be contained but also information about
the connection topology of the actor ports to each other and to uplevel ports.
This information is stored in the network graph \label{network-graph}
$N=(\mathcal{A},C,P_{i},P_{o},E)$ a 5-tupple containing
a set of actors $\mathcal{A}$, a set of channels $C$, a set of uplevel
input ports $P_{i}$, a set of uplevel output ports $P_{o}$ and a set of
directed edges $E \subseteq ((P_{i} \bigcup C) \times \mathcal{A}_{P_{i}})
\bigcup (\mathcal{A}_{P_{o}} \times (P_{o} \bigcup C))$.
Each actor $A \in \mathcal{A}$ can only communicate with other actors
through its set of dedicated actor input ports $A_{P_{i}}$ and
actor output ports $A_{P_{o}}$.
% $\forall{}_{(X,Y)\in \mathcal{A^2}} X \ne Y \Rightarrow X_{P} \cap Y_{P} = \emptyset$
Furthermore we define the set of all
actor input ports as $\mathcal{A}_{P_{i}} = \bigcup{}_{A \in \mathcal{A}} A_{P_{i}}$ and
the set of all actor output ports as
$\mathcal{A}_{P_{o}} = \bigcup{}_{A \in \mathcal{A}} A_{P_{o}}$.

There are two connection topologies which are distinguished by our methodology:

\begin{enumerate}
\item Petri network graph \label{petri-network-graph}

  Petri network graphs are network graphs which are constrained that only
  one edge enters an actor input port
  $\forall{p \in \mathcal{A}_{P_{i}}.} |(C \times \{p\}) \bigcap E| \le 1$.
  An example of a petri network graph is displayed in figure~\ref{ng-petri}.

\item SDF network graph \label{sdf-network-graph}

  A SDF network graph is a petri network graph with the additional constraint,
  that the indegree and outdegree of every channel in the graph must be one
  $\forall{c \in C.} |(\{c\} \times \mathcal{A}_{P_{i}}) \bigcap E| \le 1 \wedge
                    |(\mathcal{A}_{P_{o}} \times \{c\}) \bigcap E| \le 1$.
  An example of a SDF network graph is displayed in figure~\ref{ng-sdf}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics[scale=1]{ng-petri.\graphicPostfix}\\
\caption{\label{ng-petri}Petri network graph}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=1]{ng-sdf.\graphicPostfix}\\
\caption{\label{ng-sdf}SDF network graph}
\end{figure}

\subsection{Channel kind}

The channel kind defines the communication semantic of the channel.
Because the communication semantic is not influenced by the
type of the values communicated, the actual type of a communication
channel is derived from the channel kind by parameterizing it with
the type of the communicated values. Examples for channel kinds are:

\begin{enumerate}
\item FIFO
  An unbound FIFO channel for communication
  (Nonblocking write and blocking read).
\item Rendezvous
  A rendezvous channel for communication % and barrier synchronisation
  (Blocking write and read).
\item Register
  For expressing communication via shared variables
  (Nonblocking write and read).
\end{enumerate}

\section{Requirements of MoCs}\label{Requirements of MoCs}

A Model of Computation is defined \cite{embsft:2002} as the 
interaction policy between actors in an Actor-Oriented Design.
Actors are objects which execute concurrently. They can only
communicate with the environment (other actors) through their ports.
The actor ports are connected which each other via channels.
The data values, which are communicated over the channels,
are abstracted. The values are called tokens regardless
of their type or value.
%Actors can have their own thread of control or be without. Actors
%with their own thread of control will be called in the following
%active actors and actors without a dedicated thread of control
%passive actors.

The requirements of MoCs can be seperated into two different groups.
There are the execution requirements which must be fulfilled by
the programming system otherwise the MoC can not be implemented in
this system.
On the other hand there are the analysis requirements which
must be fulfilled otherwise we can not extract the information
needed for MoC specific analysis.

\subsection{Requirements of CSP}
Communicating Sequential Processes \cite{csphoare:1985}
is a MoC which consist of concurrently executing processes
which communicate via unidirectional rendezvous channels.
As a difference to the CSP model of Hoare which allows
runtime creation of processes via parallel composition and 
recursion this CSP like model is constraint to a fixed
predetermined number of processes. This constraint was
set to render hardware synthesis of the model possible.

The following requirements are the execution requirements to
implement CSP like behaviour:

\begin{enumerate}
\item A rendezvous channel for communication
\item A communication method for Hoare's 'general choice'
\item Parallel executing processes
\end{enumerate}

To faciliate analysis of the CSP MoC additionally the following
constraints must be fulfilled:
\begin{enumerate}
\item The indegree and outdegree of all channels in the network graph must be one.
\item The actors must only communicate over their ports which each other.
\end{enumerate}

Mapping of the CSP MoC requirements onto the concepts presented in
section~\ref{concept-overview}:

\begin{itemize}

\item The node interface must provide a communication operator which
      generates a 'general choice' communication.

\item The connection topology needed for CSP is provided by the SDF network graph.

\item As channel kind rendezvous is selected.

\end{itemize}

\subsection{Requirements of KPN}
Kahn Process Networks \cite{kahn:1974}
is a MoC which consist of concurrently executing processes
which communicate via unidirectional unbounded FIFO channels.
The input/ouput ends of a channel are connected to dedicated
processes.

The following requirements are the execution requirements to
implement KPN behaviour:

\begin{enumerate}
\item An unbound FIFO channel for communication
\item A communication method to read from and write to fifos
\item Parallel executing processes
\end{enumerate}

To faciliate analysis of the KPN MoC additionally the following
constraints must be fulfilled:
\begin{enumerate}
\item The indegree and outdegree of all channels in the network graph must be one.
\item Assurance that the arrival sequence of tokens at
      their ports can not be determined.
\item The actors must only communicate over their ports which each other.
\end{enumerate}

Mapping of the KPN MoC requirements onto the concepts presented in
section~\ref{concept-overview}:

\begin{itemize}

\item The node interface must only provide a communication operator which
      generates parameterized read and write requests on the actor ports.

\item The connection topology needed for CSP is provided by the SDF network graph.

\item As channel kind FIFO is selected.

\end{itemize}

\subsection{Requirements of SDF}
Synchronous Data Flow \cite{Lee87b:1987}
is a more constricted form of the KPN MoC.
It has all the execution requirements of the KPN MoC and
the additional analysis requirement that actor consumption and
production rates are constant.

The following requirements are the execution requirements to
implement SDF behaviour:

\begin{enumerate}
\item An unbound FIFO channel for communication
\item A communication method to read from and write to fifos
\item Parallel executing processes
\end{enumerate}

To faciliate analysis of the SDF MoC additionally the following
constraints must be fulfilled:
\begin{enumerate}
\item The indegree and outdegree of all channels in the network graph must be one.
\item Assurance that the arrival sequence of tokens at
      their ports can not be determined.
\item Assurance that consumption and production rates can not
      be altered once set.
\item The actors must only communicate over their ports which each other.
\end{enumerate}

Mapping of the SDF MoC requirements onto the concepts presented in
section~\ref{concept-overview}:

\begin{itemize}

\item The node interface must only provide a communication operator which
      generates read and write requests with a fixed set of actor ports.

\item The connection topology needed for CSP is provided by the SDF network graph.

\item As channel kind FIFO is selected.

\end{itemize}

\section{Software architecture}

Due to its high abstraction level and possibilities for both
hardware and software refinements we have chosen SystemC
\cite{systemc-lrm:2003} \cite{glms:2002} as our language for system design.
SystemC is a C++ based design framework.

In the following we propose a SystemC framework, called \SysteMoC, which
faciliates automatic extraction of the MoC of a SystemC design.
Actors in SystemC are C++ classes which are derived from the base class \code{sc\_module}.
However it is impossible, in the general case, to extract the kind of communication
behaviour these actors will exhibit. The \SysteMoC{} framework must now provide the
execution requirements for each MoC while still allowing to extract the information
needed for analysis. This analysis is made possible by dividing the actor into its
node functionallity and its node interface.
Furthermore the \SysteMoC{} framework must provide a way for these
actors to be connected to each othe via their ports. The topology of these connections
is decided by the network graph.

\begin{figure}
\centering
\begin{verbatim}
template <typename T>
class m_adder // Actor m_adder
  : public hscd_fixed_transact_node // Node interface
{
public:
  hscd_port_in<T>  in;
  hscd_port_out<T> out;
private:
  // Node functionality
  void transform() {
    out[0] = in[0] + in[1];
    std::cout << "Adding " << in[0] << " + " << in[1]
              << " = " << out[0] << std::endl;
  }
  
  // Firing rules
  void process() {
    while (true) {
      transform();
      transact();
    }
  }
public:
  m_adder( sc_module_name name )
    :hscd_fixed_transact_node( name,
        in(2) & out(1) /* Firing rules */ ) {}
};
\end{verbatim}
\caption{\label{example-sdf-actor}Example of a SDF-Actor in the \SysteMoC{} framework}
\end{figure}

\subsection{Node functionality}
The node functionality is only used for algorithmic transformations of data values.
The node functionality of an actor is defined in certain member functions,
which are called by the firing rules if their requirements for input data is met.
This member functions are not allowed to call communication operations and
the input and output data values used are read from
and written to the actor ports. All actor ports are globally accessible
by the actor member functions and can therefore be used to get input data
and place output data for the node functionality
(See figure \ref{example-sdf-actor} method \code{transform} for an example of a node functionality).

\subsection{Node interface hierarchy}
The problem of extracting the communication behaviour of an actor is caused by the fact,
that the communication methods in SystemC are all accessible to all SystemC modules.
And execution of these methods is controlled by the turing equivalent coding possibilities
in the actor. To partially redress these problems we introduce the concept of node interface
which determines what communication methods are available to an actor. This is implemented
by disallowing all communication methods on \SysteMoC{} channels and providing them instead
in a base class from which the actor is derived. Therefore the node interface of an actor
corresponds to the base class from which the actor is derived
(See table~\ref{node-interface-c++} for mapping of the node interface names to their
corresponding C++ class types).
Communication over other media than \SysteMoC{} channels is forbidden but this can not be enforced
because the full power of SystemC should be availlable for the node functionallity part
of the actor. So we require form the \SysteMoC{} user the assurance that the
node functionallity does terminate and does not communicate with other actors.

\begin{table}
\centering
\begin{tabular}{|c|c|}
\hline
 Node interface & C++ class type \\
\hline \hline
 Choice Node          & hscd\_choice\_node \\
 Transact Node        & hscd\_transact\_node \\
 Fixed Transact Node  & hscd\_fixed\_transact\_node \\
\hline
\end{tabular}
\caption{\label{node-interface-c++}Node interfaces represented as C++ classes}
\end{table}

The following subset of the requirements enumerated in Section~\ref{Requirements of MoCs}
determines the node interface of the corresponding MoCs:

\begin{enumerate}
\item Choice Node
  \begin{itemize}
  \item  A communication method which implements Hoare's 'general choice' operator \cite{csphoare:1985}.
  \end  {itemize}
\item Transact Node
  \begin{itemize}
  \item A communication method to read from and write to ports.
  \item Assurance that the arrival sequence of tokens at
        their ports can not be determined.
  \end  {itemize}
\item Fixed Transact Node
  \begin{itemize}
  \item A communication method to read from and write to ports.
  \item Assurance that the arrival sequence of tokens at
        their ports can not be determined.
  \item Assurance that consumption and production rates can not
        be altered once set
  \end  {itemize}
\end{enumerate}

These requirements build a hierarchy of decreasing capability. The node
interface of CSP is the most capable in the hierarchy and it
fulfills the execution requirements of all more constraint interfaces.
To fulfill the execution requirement of KPN the general choice operator
can be used to implement the communication method for KPN by constraining
the list of actor ports for the choice operation to one and therefore
eliminating the choice between different actor ports.
The execution requirement of SDF are the same than that of KPN and can
therefore be fulfilled by the node interface of KPN.

However the analysis requirements of the MoC in the hierarchy
get progressively more constraining and therefore the power
of the communication operations in the node interface must
be reduced accordingly to meet them.

\begin{figure}
\centering
\includegraphics[scale=0.5]{NodeInterfaceHierarchy.\graphicPostfix}\\
\caption{\label{node-interface-hierarchy}Node interfaces represented as C++ classes}
\end{figure}

The hierarchy of the requirements is transformed into a C++ inheritance
hierarchy with the CSP node interface at the root (See figure \ref{node-interface-c++}).
Less capable node interfaces inherit from more capable ones. The
less capable node interfaces use the communication operations from the base class node
interface to implement their own operations. The communication operations of the
base class are disabled by declaring them private.

\begin{enumerate}
\item CSP
  \begin{itemize}
  \item  $\mathrm{choice}( a(1) \arrowvert b(2) )$
    This communication operation gets a list of actor ports (e.g. $a$, $b$) which
    are parameterized with the number of tokens that must be communicated
    over the port. The operations communicates over that actor port which is first ready
    for communication. If no port is ready for communication the operation blocks until
    at least one port is ready. Should more than one actor port be ready for
    communication at the same instance one of them is chosen nondeterministicly.
  \end  {itemize}
\item KPN
  \begin{itemize}
  \item $\mathrm{transact}( a(1) \& b(2) )$
    This communication operation gets a list of actor ports (e.g. $a$, $b$) which
    are parameterized with the number of tokens that must be communicated
    over the port. The operations blocks until all requested tokens on the ports
    have been communicated.
  \end  {itemize}
\item SDF
  \begin{itemize}
  \item $\mathrm{transact}()$, $\mathrm{hscd\_fixed\_transact\_node}( ..., a(1) \& b(2) )$
    Actors are C++ classes which are derived of their node interface class.
    The consumption and production rates for SDF Actors must be fixed, therefore
    the node interface of a SDF-Actor is parameterized with the consumption and production
    rates of the SDF-Actor (See actor constructor in figure \ref{example-sdf-actor} for an
    example of fixed consumption and production rates). The communication operation \code{transact} is
    therefore missing the port list which is availlable to KPN nodes.
  \end  {itemize}
\end{enumerate}

\subsection{Network graph}

To determine the MoC of a SystemC modell additionally to the information
required about the actors of the modell information is required about the
topology of the connections of actors to each other.

There are two connection topologies which are distinguished by the \SysteMoC{}
framework.

\begin{enumerate}
\item Petri network graph
  
  A petri network graph is a graph as described in subsection~\ref{petri-network-graph}
  (See figure~\ref{ng-petri} for an example of a petri network graph).

\item SDF network graph
  
  A SDF network graph has the additional constraint that the indegree and outdegree
  of every channel $C$ in the graph must be one.
  (See figure~\ref{ng-sdf} for an example of a petri network graph).

\end{enumerate}

The network graph is represented by the C++ template \code{hscd\_structure} 
which has only methods to instantiate sub actors and connect their ports to each other.

The network graph is represented by the C++ template
\code{hscd\_structure} which has the parameters node interface
and channel kind. The network graph is assembled by the
constructor of the  \code{hscd\_structure} template.
Once the constructure has finished the network graph must
be fully assembled. No alteration at a later date is allowed.
To construct the network graph the following methods of the
\code{hscd\_structure} template are available:

\begin{enumerate}
\item registerNode

This method is used to add actor vertices to the network graph.
Each registered actor must implement
the parameterized node interface of the \code{hscd\_structure}
template or an even less capable node interface.
This constraint is enforeced by the type signature
of the registerNode method and the node interface hierarchy.

\item registerChan

This method is used to add channel vertices to the network graph.
Each registered channel must be of the parameterized channel kind.
The constraint is enforeced by the type signature
of the registerChan method.

\item connectChanPort

This method adds the edges between the actor ports and the
channels.

\item connectNodePorts

This method is a shorthand for adding a channel and
connecting two actor ports via this channel. It main usage
is for MoCs where a channel is only connected to a dedicated
output actor port and a dedicated input actor port. In
this MoCs the connectChanPort method is disabled.

\item connectInterfacePorts

\item assemble

\end{enumerate}

\subsection{Channel kind}

As SystemC is an actor-oriented design framework, it also has the concepts of actors
and channels. So the channel kind concept of the \SysteMoC{} framework can cleanly be implemented
as a base class of a channel in SystemC. The channel kind determines the
communication semantic of a channel but not the data type of the tokens.
The channel type is a template parameterized with the data type for the tokens and
derived from the channel kind. Identifying the channel kind with a base class instead
of a template enables easier type signature checks of C++ for the enforcement of a
particular channel kind of a channel instance.

Further differences between \SysteMoC{} channels and a SystemC channels consist of the
absence of user callable methods for communicating on the \SysteMoC{} channels.
Having those communication methods on the channels would contradict the separation
of node interface and channel kind.

For \SysteMoCV{} there exists two distinct channel kinds.

\begin{enumerate}
\item FIFO

This channel kind represents unbound FIFO semantic.


\item rendezvous

This channel kind represents rendezvous semantic.

\end{enumerate}

The channel kind is the parameter for the
\code{hscd\_structure} template which determines
the semantic of all channels in the parameterized
\code{hscd\_structure} template.


\subsection{MoC composition}

The MoC is represented as an actor which is derived from the \code{hscd\_structure}
template parameterized with the node interface and the channel kind. This actor can only
instantiate sub actors of a predetermined kind and connect their ports with a  predetermined
kind of channel.

The MoC is now determined by the composition of the two concepts node interface
and channel kind as following:

\begin{tabular}{|c||c|c|c|}
\hline
 Channel kind & \multicolumn{3}{c|}{ Node interface } \\
\hline
              & Choice Node         & Transact Node      & Fixed Transact Node \\
\hline \hline
 Fifo         & No well known name  & KPN                & SDF \\
\hline
 Rendezvous   & CSP                 & No well known name & No well known name \\
\hline
\end{tabular}

\clearpage
\appendix
\bibliographystyle{alpha}
\bibliography{literature}

\end{document}
