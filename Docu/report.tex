\newcommand{\graphicPostfix}{pdf}
\newcommand{\resdir}{../../../HscdTeXRes/}
\newcommand{\code}[1]{{\bf #1}}

\input{\resdir format.tex}

\usepackage{multirow}

\begin{document}
\hscdtitle{The Representing MoCs in SystemC}{Joachim Falk}{\today}
\clearpage
\tableofcontents
\clearpage

\section{Introduction\label{intro}}
Due to rising design complexity it is necessary to increase
the level of abstraction at which systems are designed. Using
Models of Computation in system design can achieve this goal.
Some of the benefits of MoCs are:
\begin{enumerate}
\item MoCs can be used to mathematically reason about communication
patterns.

\item Knowledge about MoCs can be used by code generators to produce
optimized code.

\item Knowledge about MoCs can be used by verification tools to
check system properties.
\end{enumerate}
However for these benefits to be practically realized the
MoC must be extractable from the source code. Because the general case
is impossible to solve for a turing complete programming language
\footnote{Halting problem} a machine analyzable coding subset for
MoCs has to be defined.

\section{Requirements of MoCs}\label{Requirements of MoCs}

A Model of Computation is defined \cite{embsft:2002} as the 
interaction policy between actors in an Actor-Oriented Design.
Actors are objects which execute concurrently. They can only
communicate with the environment (other actors) through their ports.
The ports of the actors are connected which eachother via channels.
The data values, which are communicated over the channels,
are abstracted away. The values are called tokens regardless
of their type or value.
Actors can have their own thread of control or be without. Actors
with their own thread of control will be called in the following
active actors and actors without a dedicated thread of control
passive actors.

\subsection{Requirements of CSP}
Communicating Sequential Processes \cite{csphoare:1985}
is a MoC which consist of parallel executing processes
which communicate via unidirectional rendezvous channels.
The input/ouput ends of a channel are connected to dedicated
processes.

The following requirements are the minimum necessary to
implement CSP like behaviour:

\begin{enumerate}
\item A rendezvous channel for communication
\item A communication method which implements Hoare's 'general choice' operator \cite{csphoare:1985}
\item Parallel executing processes
\end{enumerate}

\subsection{Requirements of KPN}
Kahn Process Networks \cite{kahn:1974}
is a MoC which consist of parallel executing processes
which communicate via unidirectional unbounded fifo channels.
The input/ouput ends of a channel are connected to dedicated
processes.

The following requirements are the minimum necessary to
implement KPN behaviour:

\begin{enumerate}
\item A unbound fifo channel for communication
\item A communication method to read from and write to the fifos
\item Assurance that the arrival sequence of tokens at
      their ports can not be determined
\item Parallel executing processes
\end{enumerate}

\subsection{Requirements of SDF}
Synchronous Data Flow \cite{sdf:xxx}
is a more constricted form of the KPN MoC.
It has all the requirement of the KPN MoC and
additionally the requirement, that consumption and
production rate of the actor are constant.

The following requirements are the minimum necessary to
implement SDF behaviour:

\begin{enumerate}
\item A unbound fifo channel kind for communication
\item A communication method to read from and write to the fifos
\item Assurance that the arrival sequence of tokens at
      their ports can not be determined
\item Assurance that consumption and production rates can not
      be altered once set
\item Parallel executing processes
\end{enumerate}

% \subsection{Requirements MoCs for their communication interface}

\section{Concept overview}

Due to it's high abstraction level and possibilities for both
hardware and software refinements we have chosen SystemC
\cite{systemc-lrm:2003} \cite{glms:2002} as our language for system design.
SystemC is a C++ based design framework.

In the following we propose a SystemC framework, called SysteMoC, which
faciliates automatic extraction of the MoC of a SystemC design.
Instead of a Monolitic approach to represent an executable specification
in SystemC we choose too represent the specification
by combining severel independent concepts. This is a refinement of
actor-oriented design.

\subsection{Concepts}

\begin{enumerate}
\item Node functionality

The specification is devided into several communicating actors.
The actor functionality is the algorithmic description
which is responsible for transforming data values. The communication
behaviour of the actor must not be altered in the node functionality.

\item Node interface

The node interface are the set of operators which are used to
define the communication behaviour of the actor.

\item Network graph

The Network graph is a directed multipartit graph $G=(V,E)$ whose vertices $V$
can be partitioned into actors $V_{A}$, channels $V_{C}$, input ports $V_{I}$ and output
ports $V_{O}$
whereas $V=V_{A} \bigcup V_{C} \wedge \emptyset=V_{A}\bigcap{}V_{C}$.
The actors have ports which are their only means of communication.
These ports are either input ports or output ports.
The network graph specifies the connections from
the output/input ports of the actors to the channels.

\item
Channel kind

The channel kind defines the semantic for all channels
the network graph containes.
\end{enumerate}

\subsection{MoC composition}

The MoC is now determined by the composition of the two concepts 'Node interface'
and 'Channel kind' as following:

\begin{tabular}{|c||c|c|c|}
\hline
 Channel kind & \multicolumn{3}{c|}{ Node interface } \\
\hline
              & Choice Node         & Transact Node      & Fixed Transact Node \\
\hline \hline
 Fifo         & No well known name  & KPN                & SDF \\
\hline
 Rendezvous   & CSP                 & No well known name & No well known name \\
\hline
\end{tabular}

\section{Software architecture}
The introduced concepts are converted into a software architecture in the following way.

As SystemC is an actor-oriented design framework, it also has the concepts of actors
and channels. So the 'Channel kind' concept of the SysteMoC framework can cleanly be implemented
as a base class of a channel in SystemC. The 'Channel kind' determines the
communication semantic of a channel but not the data type of the tokens.
The channel type is a template parameterized with the data type for the tokens and
derived from the 'Channel kind'.

Further differences between SysteMoC channels and a SystemC channels consist of the
absence of user callable methods for communicating on the SysteMoC channels.
Having those communication methods on the channels would contradict the separation
of 'Node interface' and 'Channel kind'.

Actors in SystemC are C++ classes which are derived from the base class \code{sc\_module}.
However it is impossible, in the general case, to extract the kind of communication
behaviour these actors will exhibit. These problems are caused by the fact, that the
communication methods are all accessible to all SystemC modules. And execution
of these methods is controlled by the turing equivalent coding possibilities in the actor.
To partially redress these problems we introduce the concept of 'Node interface' which
determines what communication methods are available to an actor. These is implemented
by disallowing all communication methods on SysteMoC channels and providing them instead
in a base class from which the actor is derived. Therefore the 'Node interface' of an actor
corresponds to the base class from which the actor is derived.

The 'Network graph' is represented by the C++ template \code{hscd\_structure} 
which has only methods to instantiate sub actors and connect their ports to eachother.

The MoC is represented as an actor which is derived from the \code{hscd\_structure}
template parameterized with the 'Node interface' and the 'Channel kind'. This actor can only
instantiate sub actors of a predetermined kind and connect their ports with a  predetermined
kind of channel.

\subsection{Node interface hierarchy}
After gathering the requirements of the three different MoCs CSP, KPN
and SDF a Node interface hierarchy is derived which fulfills these requirements.

In the following the requirements of the MoCs which concern the 'Node interface' are
extracted from Section~\ref{Requirements of MoCs} and repeated:

\begin{enumerate}
\item CSP

A communication method which implements Hoare's 'general choice' operator \cite{csphoare:1985}.

\item KPN

A communication method to read from and write to ports.
Assurance that the arrival sequence of tokens at
their ports can not be determined.

\item SDF

A communication method to read from and write to ports.
Assurance that the arrival sequence of tokens at
their ports can not be determined.
Assurance that consumption and production rates can not
be altered once set

\end{enumerate}

It is evident that this requirements build a hierarchy of decreasing
capability. The 'Node interface' needed for CSP is the most capable
in the hierarchy and it can emulate all lesser more constraint interfaces.
This hierarchy is transformed into a C++ inheritance hierarchy with the
CSP 'Node interface' at the root (See figure \ref{node-interface-c++}).
Less capable node interfaces inherit from more capable ones. The
less capable node interfaces use the operators from the base class node
interface to implement their own operators. The operators of the
base class are disabled by declaring them private.

\begin{figure}
\centering
\includegraphics[scale=0.5]{NodeInterfaceHierarchy.\graphicPostfix}\\
\begin{tabular}{|c|c|}
\hline
 Node interface & C++ class type \\
\hline \hline
 Choice Node          & hscd\_choice\_node \\
 Transact Node        & hscd\_transact\_node \\
 Fixed Transact Node  & hscd\_fixed\_transact\_node \\
\hline
\end{tabular}
\caption{\label{node-interface-c++}Node interfaces represented as C++ classes}
\end{figure}

\subsection{Network graph}
The 'Network graph' is represented by the C++ template
\code{hscd\_structure} which has the parameters 'Node interface'
and 'Channel kind'. The 'Network graph' is assembled by the
constructor of the  \code{hscd\_structure} template.
Once the constructure has finished the 'Network graph' must
be fully assembled. No alteration at a later date is allowed.
To construct the 'Network graph' the following methods of the
\code{hscd\_structure} template are available:

\begin{enumerate}
\item registerNode

This method is used to add actor vertices to the 'Network graph'.
Each registered actor must implement
the parameterized 'Node interface' of the \code{hscd\_structure}
template or an even less capable 'Node interface'.
This constraint is enforeced by the type signature
of the registerNode method and the node interface hierarchy.

\item registerChan

This method is used to add channel vertices to the 'Network graph'.
Each registered channel must be of the parameterized 'Channel kind'.
The constraint is enforeced by the type signature
of the registerChan method.

\item connectChanPort

This method adds the edges between the actor ports and the
channels.

\item connectNodePorts

This method is a shorthand for adding a channel and
connecting two actor ports via this channel. It main usage
is for MoCs where a channel is only connected to a dedicated
output actor port and a dedicated input actor port. In
this MoCs the connectChanPort method is disabled.

\item connectInterfacePorts

\item assemble

\end{enumerate}




\subsection{Channel kind}

\clearpage
\section{Dust bin}


to a new higher level hardware description
language for both system specification and system implementation is
desireable. One representative of this kind of hardware description
language is SystemC. Another challenge imposed by rising design complexity
is the exploding design space, which can no longer be reasonably explored
by humans.


If the Model of Computation is restricted to Dataflow the
MODES tool for automated Design Space exploration can be used. The MODES
tool uses a Graph model as an abstraction. The Graph model is called the
Specification Graph (following known as $G_{S}(V_{S},E_{S})$) which has as
induced Subgraphs a Problem Grap (following known as $G_{P}(V_{P},E_{P}) \subset G_{S}$) and
an Architecture Graph (following known as $G_{A}(V_{A},E_{A}) \subset G_{S}$).
... Say more Stuff here !!!
\par
To include the MODES tool into the Design Flow an automatic mapping between
the Graph model of MODES and the real world Design in a Hardware Description
Language must be implemented. The presented tool is concerned with the automated
mapping of a Design in SystemC, which uses the Dataflow Model of Computation,
to the MODES PG. Clearly not the full semantic of SystemC can be mapped to the
PG, only Dataflow is supported. And multiple ways exists to implement
Dataflow in SystemC. Therefore a subset of SystemC was choosen which not only
is restricted to Dataflow but to a certain way to implement Dataflow in SystemC.
\par
Following things have to be mapped from SystemC to the MODES PG:
\begin{enumerate}
\item Dataflow Nodes

These are mapped to SC\_MODULES in SystemC. They can have any semantic internally
but must export Dataflow semantic externally. These modules have only sc\_fifo\_in/sc\_fifo\_out
ports for communication. The only exception is an optional sc\_in\_clk for clock distribution.

Example:
\begin{verbatim}
SC_MODULE(design_mul2) {
 public:
  sc_in_clk                   clk;
  sc_fifo_in< tokentype_ty >  in;
  sc_fifo_out< tokentype_ty > out;

 private:
  void worker_thread( void ) {
    while ( 1 ) {
      out.write( in.read() * 2 );
    }
  }

 public:
  SC_CTOR(design_mul2) {
    SC_THREAD(worker_thread);
  }
};
\end{verbatim}
\item Datadependencies
\end{enumerate}

\par


\par
You can use labels as in Section~\ref{intro}.

\section{About Your Work}
You can place figures in your text as shown in Figure~\ref{yourfigure}.
\begin{figure}
\centering
\includegraphics[width=4in]{\resdir codesign.pdf}
\caption{\label{yourfigure}Your Figure}
\end{figure}
\par
You can cite any literatur by using the $\backslash$cite command. 
Here, an example: \cite{btt:1998}.
\subsection{First ideas}
\subsection{Obstacles}
\subsection{Results}

\clearpage
\appendix
\bibliographystyle{alpha}
\bibliography{literature}

\end{document}
