\newcommand{\graphicPostfix}{pdf}
%%\newcommand{\code}[1]{\texttt{#1}}
%%\newcommand{\SysteMoC}{{\bf SysteMoC}}
%%\newcommand{\SysteMoCV}{\SysteMoC{} {\bf 1.0}}
\newcommand{\code}[1]{\emph{#1}}
\newcommand{\SysteMoC}{\emph{SysteMoC}}
\newcommand{\SysteMoCV}{\emph{SysteMoC 1.0}}
\newcommand{\implies}{\Longrightarrow}

\input{format.tex}

\theoremheaderfont{\normalfont\sffamily\bfseries}
{\theorembodyfont{\normalfont\itshape}
  \newtheorem{sdefinition}{Definition}[section]
  \newtheorem{definition}{Definition}[subsection]
  \newtheorem{proof}{Proof}[subsection]
  \newtheorem{characteristic}{Characteristic}[subsection]
}
{\theorembodyfont{\normalfont}
  \newtheorem{sexample}{Example}[section]
  \newtheorem{example}{Example}[subsection]
}

\usepackage{multirow}
\usepackage{fancyvrb}

% Use a small font for the verbatim environment
\makeatletter  % makes '@' an ordinary character
\renewcommand{\verbatim@font}{%
  \ttfamily\small\catcode`\<=\active\catcode`\>=\active%
}
\makeatother   % makes '@' a special symbol again

% \begin{Verbatim}[fontsize=\tiny]

\hypersetup{
  pdftitle   = {Representing Models of Computation in SystemC},
  pdfsubject = {Co-Design-Report},
  pdfauthor  = {\textcopyright\ Joachim Falk, Christian Haubelt, J\"urgen Teich},
  colorlinks = true,
  linkcolor  = black,
  anchorcolor= black,
  citecolor  = black,
  filecolor  = black,
  menucolor  = black,
  pagecolor  = black,
  urlcolor   = black
}

\begin{document}
\hscdtitle{Representing Models of Computation in SystemC}
{Joachim Falk, Christian Haubelt, J\"urgen Teich}{2-2005}
\clearpage
\tableofcontents
\clearpage

\section{Introduction\label{intro}}
Due to rising design complexity it is necessary to increase
the level of abstraction at which systems are designed. In
today's embedded systems the specification is mostly mapped
into a set of interacting tasks and hardware modules, which 
interact by the use of shared variables and various ways of
message passing. To guarantee exclusive access to the shared
variables and resources, mutually exclusive devices like semaphores,
mutexes, and monitors are used. But this unstructured use
of communication types leads to hardly analyzable systems.
However, by constraining the type of communication
used between tasks and the communication behavior of the tasks,
expressiveness is traded for analyzability.

\emph{Models of computation}
\cite{embsft:2002}, in the following called \emph{MoCs}, are
predefined types of communication and strategies for scheduling
communicating tasks. Thus, MoCs are comparable to design
patterns known from the area of software design \cite{gamma:1995}.
Limiting the expressiveness of a MoC enables:

\begin{enumerate}
\item Mathematically reasoning about communication patterns

\item Code generation to produce optimized code

\item Automatic and efficient verification to check system properties
\end{enumerate}

On the other hand, modern embedded system design is still based on
specification languages which allow unstructured communication.
Even worse, nearly all specification languages allow for Turing
complete MoCs making analysis in general impossible.
To make industry benefit from the best of both worlds,
engineers must restrict themselves to use certain subsets of
specification languages allowing analyzability, identification,
and extraction of these MoCs at the source code level automatically.

This report deals with the representation of some %transformative
MoCs in SystemC. The rest of the report is structured as follows:
In Section~\ref{related-work}, we discuss related work. In
Section~\ref{actor-oriented-design}, we propose our framework for
representing MoCs in SystemC. In Section~\ref{revision-of-mocs},
we show how some MoCs fit into
the framework presented before. In Section~\ref{software-architecture},
a SystemC implementation of our framework called \SysteMoC{} is
presented. Finally, we will give some examples using the \SysteMoC{}
framework in Section~\ref{systemoc-examples}, and we conclude
the present report in Section~\ref{conclusions}.

\section{Related Work}\label{related-work}

SystemC \cite{glms:2002} already allows to implement
dataflow MoCs via communicating actors and \code{sc\_fifo} channels.
However, a dataflow MoC implemented in this way is unstructured
and no possibilities exist for deriving information about its
communication behavior. The facilities for implementing MoCs in
SystemC have been extended by Herrera et al.~\cite{herrerasystemc:2004}
which have implemented a custom library of channel types like rendezvous
on top of the SystemC discrete-event simulation kernel. But no
constraints have been imposed how these new channels types are used by
an actor. Consequently, no information about the communication behavior
of an actor can be derived.
Implementing these channels on top of the SystemC discrete-event
simulation kernel curtails the performance of such an implementation.
Another approach has been taken by Patel et al.~\cite{fermatmoc:2004}
which have extended SystemC itself with different simulation kernels
for Communicating Sequential Processes and Finite State Machine MoCs
to improve simulation efficiency. Moreover,
they have implemented hierarchical compositon of MoCs following
the approach of \hbox{Ptolemy II}. \hbox{Ptolemy II} \cite{ptolemyII} is a simulation
framework for MoCs implemented in Java. Its aim is the exploration of
different MoCs and the semantic of hierarchical composition of these MoC
with each other.

In contrast to the approaches discussed above, our methodology restricts
the communication behavior in such a way that the identification,
extraction, and analysis of different MoCs is permitted.

\section{The Tagged Signal Model}\label{lee-tsm}

We use Lee's \emph{tagged signal model} introduced in \cite{Lee98} to
distinguish MoCs and use it as starting point for our further
discussions. Before we can review the tagged signal model some mathematical
notations are needed.

Let $\{x_1,x_2\}$ denote a set and $[y_1,y_2,y_3,\ldots]$ denote a set
with total order $y_1 \le y_2 \le y_3 \le \ldots$, e.g., $\{x_1,x_2\} = \{x_2,x_1\}$ but
$[y_1,y_2] \ne [y_2,y_1]$ and $\{x_1,x_1\} = \{x_1\}$ but $[ y_1, y_2, y_1, y_3]$
is a \emph{illformed totally ordered set because} it does not define a total order,
as $y_1 \le y_2 \wedge y_2 \le y_1$ but $y_1 \ne y_2$.

Let $\mathbb{Z} = [\ldots,-2,-1,0,1,2,\ldots]$ denote the set of integers,
$\mathbb{N} = [1,2,3,\ldots]$ the set of natural numbers,
$\mathbb{N}^\infty = [1,2,3,\ldots\infty]$ the set of natural numbers including infinity,
%$\mathbb{Z}^- = [\ldots,-3,-2,-1]$ the set of negative integers,
$\mathbb{Z}^+_0 = [0,1,2,3,\ldots]$ the set of nonnegative integers,
$\mathbb{Z}^{+\infty}_0 = [0,1,2,3,\ldots\infty]$ the set of nonnegative integers including infinity,
%$\mathbb{Z}^-_0 = [\ldots,-3,-2,-1,0]$ the set of nonpositive integers,
and $\mathbb{N}_n = [1,2,3,\ldots,n] \subseteq \mathbb{N}^\infty$ the counting set from one to $n$
(Note that $\mathbb{N}_0 = \emptyset$).

A totally ordered set $X$ is called \emph{two-sided discrete}
if it is \emph{order isomorphic} to a subset of the integers $Z_X \subseteq \mathbb{Z}$,
%and let $\Sigma(X): Z_X \to X$ denote this order isomorphism,
i.e., $\exists{\Sigma(X): Z_X \to X, \Sigma(X)\textrm{ is a \emph{bijection}}}:
 \forall{i,j \in Z_X}: i \le j \iff \Sigma(X)(i) \le \Sigma(X)(j)$.
Intuitively this means, any two elements
$x_1, x_2 \in X$ have only a finite number of other elements between them.

A totally ordered set $X$ is called \emph{one-sided discrete} or \emph{discrete}
if it is \emph{order isomorphic} to a subset of the natural numbers $\mathbb{N}_{|X|}$
and let $\Sigma(X): \mathbb{N}_{|X|} \to X$ denote this order isomorphism,
i.e., $\exists{\Sigma(X): \mathbb{N}_{|X|} \to X, \Sigma(X)\textrm{ is a \emph{bijection}}}:
 \forall{i,j \in \mathbb{N}_{|X|}}: i \le j \iff \Sigma(X)(i) \le \Sigma(X)(j)$.
Intuitively this means,
any two elements $x_1, x_2 \in X$ have only a finite number of other elements
between them and there exists a least element $x_{least}, \forall{x \in X}: x_{least} \le x$.
For example, given the discrete set $X = ['A', 'B', 'C']$ then
$\Sigma(X)(1) = 'A'$,  $\Sigma(X)(2) = 'B'$, and $\Sigma(X)(3) = 'C'$.

Let $X^* = \bigcup_{N \in \mathbb{Z}^+_0} X^N$ denote the set of all
\emph{tuples} of $X$ also called \emph{finite sequences} of $X$ and
$X^{**} = \bigcup_{N \in \mathbb{Z}^{+\infty}_0} X^N$ denote the set of all
finite and infinite \emph{sequences} of $X$. A sequence
$\mathbf{x} = (x_1,x_2,\ldots,x_n) \in X^n, n \in \mathbb{Z}^{+\infty}_0$
can also be thought of as a function $\mathbf{x} : \mathbb{N}_n \to X$.
For example, given the sequence $X = ('A', 'B', 'A', 'C')$ then
$X(1) = 'A'$,  $X(2) = 'B'$, $X(3) = 'A'$, and $X(4) = 'C'$.
Note that a function is also a relation and a relation is also a set, e.g
$\mathbf{x} : \mathbb{N}_n \to X \equiv \{ (i,x_i) \mid x_i = \mathbf{x}(i), i \in \mathbb{N}_n \}$.
Note also that the $\Sigma$ function converts a discrete set to a sequence,
e.g., $\Sigma([1,2,3]) = (1,2,3)$.

\subsection{Events and Signals}

Lee's \emph{tagged signal model} consist of concurrent \emph{processes} which
can only communicate with each other via \emph{signals}.
Before defining a signal, the notion of an event must be introduced first.
Given a partially or totally ordered set of tags $T$ and a set of values $V$:
\begin{definition}\label{tsm-event}
An \emph{event} $e$ is a  tag-value pair, i.e., $e = (t,v) \in T \times V$.
\end{definition}
Events are often called \emph{tokens} which represent the basic communication units.
Tags are used to model time, precedence relationships, synchronization points, or
other key properties of MoCs. The odering of the tags induces ordering of events, i.e.,
given $e_1 = (t_1,v_1)$ and $e_2 = (t_2,v_2)$ then $e_1 < e_2 \iff t_1 < t_2$.
Two Events $e_1$, $e_2$ are called \emph{synchronous} if they contain
the same tag, i.e., $e_1 = (t,v_1)$ and $e_2 = (t,v_2)$. Otherwise they
are called \emph{asynchronous}.

Values represent data which can be manipulated by computations.
For some MoCs the set of values contains the special symbol \emph{bottom} ($\bot$)
which denotes the absence of a value.

A \emph{signal} can be thought of as a subset of the \emph{set of all events} $T \times V$ or as
an element of the \emph{set of all signals} $S$ which is the powerset $S = 2^{T \times V}$.
\begin{definition}\label{tsm-signal}
A \emph{signal} $s$ is defined as a set of events, i.e., $s \subseteq T \times V$.
\end{definition}

A \emph{functional signal} or \emph{proper signal} is a signal $s$ where each tag is unique in $s$,
i.e., $e_1 = (t,v_1) \in s$ and $e_2 = (t,v_2) \in s \implies v_1 = v_2$.
A functional signal can also be thought of as a (possibly partial) function 
from its set of tags to its set of values, i.e, $s: T \to V$.
Intuitively, if tags represent time a functional signal is a signal which has
at most one value at each instance of time. For example, 
given the functional signal $s = \{(t_1,'A'),(t_2,'B'),(t_3,'C')\}$ then
$s(t_1) = 'A'$, $s(t_2) = 'B'$, and $s(t_3) = 'C'$.
Furthermore, $T(s) \subseteq T$ denotes the set of tags in the signal $s$,
i.e., $T(s) = \{t \mid (t,v) \in s\}$. A \emph{discrete signal} is a functional
signal $s$ which has a discrete set of tags $T(s)$.

The $\Sigma$ function can be generalized to discrete signals.
Each discrete signal $s \subseteq T \times V$ has a corresponding \emph{sequence} $\Sigma(s) \in V^{**}$,
where the value $v = \Sigma(s)(i)$ on position $i$ is defined to be the value
of the $i$-th event in the signal $s$, i.e.,  $\Sigma : S \to V^{**}, \Sigma(s) = \{(i,v) \mid (\Sigma(T(s))(i),v) \in s\}$.
For example, given the discrete signal $s = [(t_1,'A'),(t_2,'B'),(t_3,'C')]$ then
$\Sigma(s) = ('A','B','C')$. Note that a sequence $\mathbf{v} \in V^{**}$ is also a discrete signal with tags
$T(\mathbf{v}) = \mathbb{N}_{|\mathbf{v}|}$.

Two signals $s_1$ and $s_2$ are called \emph{sequence equivalent} if they
have the same corresponding sequence, i.e., $\Sigma(s_1) = \Sigma(s_2)$.
Two signals $s_1$ and $s_2$ are called \emph{synchronous} if they contain
the same set of tags, i.e., $T(s_1) = T(s_2)$. Otherwise they are
called \emph{asynchronous}.
Hence, if two signals are synchronous each event in one
signal has a corresponding synchronous event in the other signal and vice versa.
See also Figure~\ref{fig:example-synchronous-signals} for an
example of synchronous and asynchronous signals.

\begin{figure}
\centering
\input{example-synchronous-signals-fig.tex}
\caption{\label{fig:example-synchronous-signals}Example of thress signals
  $s_1$, $s_2$, and $s_3$ where only the two signals $\{s_1,s_2\}$ are synchronous.
  All other subsets of two signals ($\{s_1,s_3\}$ and $\{s_2,s_3\}$) are asynchronous.}
\end{figure}

A tuple of $N \in \mathbb{N}$ signals is denoted $\mathbf{s} = (s_1, s_2, \dots, s_N)$ and the
set of all $N$-tuples of signals will be denoted $S^N$.
The \emph{empty signal} is denoted by $\lambda$. This
signal does not have any events, i.e., $\lambda = \emptyset$. A \emph{tuple
of empty signals} is denoted by $\Lambda$.

The $\Sigma$ function can trivially be extended to tupples of signals
$(s_1,s_2,\ldots,s_N) = \mathbf{s} \in S^N$ by pointwise extension,
i.e., $\Sigma : S^N \to (V^{**})^N, \Sigma(\mathbf{s}) = (\mathbf{v}_1, \mathbf{v}_2,\ldots,\mathbf{v}_N)$,
where $\mathbf{v}_i = \Sigma(s_i), i \in \mathbb{N}_N$.

% The position of a signal in its tuple is equivalent to its name. To
% achieve the equivalent of renaming or hiding signals, the position of
% signals in a tuple must be changed or the signal must be drop from the tuple.
% This is done by applying the \emph{projection} function to a tuple.
\begin{definition}\label{tsm-projection}
A \emph{projection} $\pi{}_I: S^N \to S^M$ is a function which discards and reorders signals according
to the discrete set of indices $I$ in a $N$-tuple of signals
to form a new $M$-tuple of signals, where $M \le N$. In other words, given $\mathbf{s} = (s_1,\ldots,s_N) \in S^N$
and $I = [i_1,\ldots,i_M] \subseteq \mathbb{N}_N$
then $\pi{}_I(\mathbf{s}) = (s_{i_1}, \ldots, s_{i_M})$.
A projection $\pi{}_I$ can be generalized to subsets $\mathbf{P}$ of $S^N$,
i.e., $\pi{}_I(\mathbf{P}) = \{\pi{}_I(\mathbf{s}) \mid \mathbf{s} \in \mathbf{P}\}$.
\end{definition}

As example consider the tuple of signals $\mathbf{s} = (s_1,s_2,s_3,s_4,s_5)$, and the discrete set
$I=[5,4,2,1]$ then the projection is given as $\pi{}_I(\mathbf{s}) = (s_5,s_4,s_2,s_1)$.

\subsection{Processes}

After defining signals, we are able to review the definition of processes \cite{Lee98}.
Later, we will use processes to transform signals.
Processes are described as sets of possible behaviors, where
a \emph{behavior} is a tuple of signals:
\begin{definition}\label{tsm-process}
A process $\mathbf{P}$ is a subset of $S^N$, i.e., $\mathbf{P} \subseteq S^N$.
\end{definition}
Each element $\mathbf{s} \in \mathbf{P}$ of the process $\mathbf{P}$ is
called a \emph{behavior} of the process $\mathbf{P}$. A particular tuple
of signals $\mathbf{s} \in S^N$ is said to \emph{satisfy} the process,
if it is one of its behaviors, i.e., $\mathbf{s} \in \mathbf{P}$.
A process $\mathbf{P}$ is called \emph{synchronous} if
every pair of signals in the behaviour of the process is synchronous, i.e.,
$\forall{\mathbf{s} \in \mathbf{P} \subseteq S^N, i_1, i_2 \in \mathbb{N}_N}:
T(\pi{}_{[i_1]}(\mathbf{s})) = T(\pi{}_{[i_2]}(\mathbf{s}))$.

\begin{definition}\label{tsm-connection}
A \emph{connection process} $\mathbf{C}_I \subseteq S^N$ is a
process where two (or more) of the signals in the $N$-tuple are
constrained to be identical. In other words, given $I \subseteq \mathbb{N}_N$
then $\mathbf{C}_I = \{\mathbf{s} \mid \mathbf{s} \in S^N \wedge \forall{i_1, i_2 \in I}: \pi{}_{[i_1]}(\mathbf{s}) = \pi{}_{[i_2]}(\mathbf{s})\}$.
\end{definition}

If the two signals $s_i$ and $s_{i'}$ in a connection process $\mathbf{C}_{\{i,i'\}}$ are
associated with the same process, e.g., as seen in Figure~\ref{fig:example-self-loop},
then the connection is called a self-loop.

\begin{figure}[htb]
\centering
\input{example-self-loop-fig.tex}
\caption{A process $\mathbf{P}$ with self-loop $\mathbf{C}_{\{2,3\}}$.
         The signals $s_2$ and $s_3$ are constrained to be identical in
         $\mathbf{C}_{\{2,3\}}$.\label{fig:example-self-loop}}
\end{figure}

Two processes $\mathbf{P_1}$ and $\mathbf{P_2}$ can be composed into
a new \emph{composite process} $\mathbf{Q}$, where
each behavior of the composite process is a behavior of its
component processes. Thus, composition can be defined as set intersection of
its component processes, i.e., $\mathbf{Q} = \mathbf{P_1} \cap \mathbf{P_2}$.
However, care has to be taken before forming such an intersection.
Each process to be composed must be defined as a subset of the same
set of signals.
Cross product and projection are syntactic operations
used to transform the processes to achieve this goal. They play no
semantic role in composition.

\begin{figure}[htb]
\centering
\input{example-tsm-composition-fig.tex}
\caption{Composition of two processes $\mathbf{P}_1$, $\mathbf{P}_2$,
         and the connection process $\mathbf{C}_{\{2,5\}}$ between them
         into a new process $\mathbf{Q}' \ni (s'_1,s'_2,s'_3,s'_4)$.
         \label{fig:example-tsm-composition}}
\end{figure}

\begin{example}
Two processes $\mathbf{P}_1$, $\mathbf{P}_2$, and a connection process
$\mathbf{C}_{\{2,5\}}$ will be composed into a new process $\mathbf{Q}'$ according to
Figure~\ref{fig:example-tsm-composition}. However, the processes are
not defined as subsets of the same set of signals
($(s_1,s_2,s_3) \in \mathbf{P}_1$ and $(s_4,s_5,s_6) \in \mathbf{P}_2$).
Thus, both processes will be augmented with the missing signals
($(s_1,s_2,s_3,s_4,s_5,s_6) \in \mathbf{P}'_1 = \mathbf{P}_1 \times S^3$ and
 $(s_1,s_2,s_3,s_4,s_5,s_6) \in \mathbf{P}'_2 = S^3 \times \mathbf{P}_2$).
Afterwards both processes and the connection process can be intersected to form
the new process ($\mathbf{Q} = \mathbf{P}'_1 \cap \mathbf{P}'_2 \cap \mathbf{C}_{\{2,5\}}$).
Finally a projection is used to eliminate signals which are no longer
visible outside of the composite process ($\mathbf{Q}' = \pi{}_{[1,4,3,6]}(\mathbf{Q})$).
Further examples about composition are presented in \cite{Lee98}.
\end{example}

Many processes have a concept of \emph{inputs}. The set of behaviors
a process can show, is constrained by its inputs.
% An input are events or signals which are specified by an external
% constraint and which must therefore be contained in every behaviour
% of a process coupled with this input.
\begin{definition}\label{tsm-input}
An \emph{input} to a process $\mathbf{P}$ is an externally
imposed contraint $\mathbf{I} \subset S^N$ such that
$\mathbf{I} \cap \mathbf{P}$ is the set of acceptable behaviors.
\end{definition}
An input can assert the presence of a certain event $e = (t,v)$ in a signal,
e.g., $\mathbf{I} = \{\mathbf{s} \mid \mathbf{s} \in S^N \wedge e \in \pi{}_{[1]}(\mathbf{s}) \}$.
But generally, an input defines a whole signal or set of signals.
Signals which are entirely defined externally are called \emph{input signals},
e.g., given $\mathbf{I} = \{\mathbf{s} \mid \mathbf{s} \in S^N \wedge s_i = \pi{}_{[1]}(\mathbf{s})\}$ and
$\mathbf{s} = (s_1, s_2)$ then $s_1$ is the input signal which
is constrained to be $s_i$ by the input $\mathbf{I}$.


\begin{example}
For example, given the following process
\label{ex:example-with-process-1}
\begin{displaymath}
\begin{array}{rll}
  \mathbf{P} = \{ & (\emptyset,\emptyset), (\{(1,0),(2,1)\},\{(2,1)\}), (\{(1,1),(2,0)\},\{(1,0)\})&\\
                  & (\{(2,0)\},\emptyset), (\{(1,0)\},\emptyset), (\{(1,1),(2,1)\},\{(1,0),(2,0)\})&\\
                  & (\{(2,1)\},\{(2,0)\}), (\{(1,0),(2,0)\},\emptyset), (\{(1,1)\},\{(1,0)\}) &\} \subset S^2\\
\end{array}
\end{displaymath}
and the input $\mathbf{I} = \{\mathbf{s} \mid  \mathbf{s} \in S^2 \wedge \{(1,0),(2,1)\} = \pi{}_{[1]}(\mathbf{s})\}$
which constrains the first signal of a process to be $\{(1,0),(2,1)\}$ then
the resulting acceptable behaviors of the process $\mathbf{P}$ after being
constrained by $\mathbf{I}$ are as follows:
\begin{displaymath}
  \mathbf{I} \cap \mathbf{P} = \{\mathbf{s} \mid \mathbf{s} \in \mathbf{P} \wedge \{(1,0),(2,1)\} = \pi{}_{[1]}(\mathbf{s})\} =
                               \{(\{(1,0),(2,1)\},\{(2,1)\})\}\\
\end{displaymath}
In other words, if the input is $0$ and $1$ at times $1$ and $2$ respectively,
then the output will be $1$ at time $2$.
\end{example}

%Some characteristics of processes can only be determined in combination with
%its set of possible inputs $\mathbf{B} \subseteq 2^{S^N}$.
%One such characteristic is the \emph{determinancy} of a process.
A process $\mathbf{P}$ is called \emph{determinate} with respect
to its set of possible inputs $\mathbf{B} \subseteq 2^{S^N}$, if after being
constrained by its inputs, it consists of exactly one or exactly
no behaviors for each input $\mathbf{I} \in \mathbf{B}$,
i.e., $\forall{\mathbf{I} \in \mathbf{B}}: |\mathbf{P} \cap \mathbf{I}| \le 1$.
Otherwise the process is called \emph{nondeterminate} with respect
to its set of possible inputs. A process without inputs is called
\emph{determinate} if it consists of exactly one or exactly
no behaviors, i.e., $|\mathbf{P}| \le 1$.

\begin{example}
The process $\mathbf{P}$ given in Example~\ref{ex:example-with-process-1}
is determinate with respect to its set of possible inputs 
$\mathbf{B}_1 = \{ \{\mathbf{s} \mid \mathbf{s} \in S^2 \wedge s_i = \pi{}_{[2]}(\mathbf{s})\} \mid
                  s_i \in \{\{(2,0)\},\{(2,1)\},\{(1,0),(2,0)\}\} \}$
but nondeterminate with respect to its set of possible inputs 
$\mathbf{B}_2 = \{ \{\mathbf{s} \mid \mathbf{s} \in S^2 \wedge s_i = \pi{}_{[2]}(\mathbf{s})\} \mid
                  s_i \in \{\{(1,0)\},\{(2,1)\},\{(1,0),(2,0)\}\} \}$,
because $\mathbf{P} \cap \{\mathbf{s} \mid \mathbf{s} \in S^2 \wedge \{(1,0)\} = \pi{}_{[2]}(\mathbf{s})\} =
\{(\{(1,1),(2,0)\},\{(1,0)\}),(\{(1,1)\},\{(1,0)\})\}$.
\end{example}

A process $\mathbf{P}$ is called \emph{sequence determinate} with respect
to its set of possible inputs $\mathbf{B} \subseteq 2^{S^N}\!\!$, if after being
constrained by its inputs, its behaviors are all sequence equivalent
for each input $\mathbf{I} \in \mathbf{B}$,
i.e., $\forall{\mathbf{I} \in \mathbf{B}, \mathbf{s}_1, \mathbf{s}_2 \in \mathbf{P} \cap \mathbf{I}}: \Sigma(\mathbf{s}_1) = \Sigma(\mathbf{s}_2)$.
A process without inputs is called
\emph{sequence determinate} if its behaviors are all sequence equivalent
i.e., $\forall{\mathbf{s}_1, \mathbf{s}_2 \in \mathbf{P}}: \Sigma(\mathbf{s}_1) = \Sigma(\mathbf{s}_2)$.


\begin{example}
For example, given the following processes
\begin{displaymath}
\begin{array}{rll}
  \mathbf{P}_1 = \{ & ([(1.5,'A'),(1.6,'B')]),([(-3.14,'A'),(16,'B')]) & \} \subseteq S^1\\
  \mathbf{P}_2 = \{ & ([(1.5,'A'),(1.6,'C')]),([(-3.14,'A'),(16,'B')]) & \} \subseteq S^1\\
  \mathbf{P}_3 = \{ & ([(1.5,'B'),(1.6,'A')]),([(-3.14,'A'),(16,'B')]) & \} \subseteq S^1\\
\end{array}
\end{displaymath}
then the process $\mathbf{P}_1$ is sequence determinate, whereas the
processes $\mathbf{P}_2$ and $\mathbf{P}_3$ are not sequence determinate.
\end{example}

So far, a process contains no information which of the signals in its behaviors are
input signals and which are output signals. A \emph{input/output partition}
divides the signals in a behavior of a process into input signals and output signals.
\begin{definition}\label{tsm-input-output-partition}
A \emph{input/output partition} $(I,O) \in \left( 2^{\mathbb{N}_N} \right)^2$
of a process $\mathbf{P} \subseteq S^N$ is a pair of discrete sets,
where $I \cap O = \emptyset$ and $|I \cup O| = N$. The signals in
a behaviour on indeces in $I$ are input signals and the
signals on indeces in $O$ are output signals.
\end{definition}
A Process $\mathbf{P} \subseteq S^N$ is called \emph{functional} with
respect to a input/output partition $(I,O)$ if for each pair of
behaviors of the process where the input signals are equal,
the output signals must be equal as well,
i.e., $\forall{\mathbf{s_1} \in \mathbf{P}, \mathbf{s_2} \in \mathbf{P}}:
\pi{}_I(\mathbf{s_1}) = \pi{}_I(\mathbf{s_2}) \implies
\pi{}_O(\mathbf{s_1}) = \pi{}_O(\mathbf{s_2})$.
Otherwise a process is called \emph{nonfunctional} with respect to a
input/output partition.

\begin{example}
The process given in Example~\ref{ex:example-with-process-1}
is functional with respect to the input/output partition $(I,O) = ([1],[2])$
but nonfunctional for partition $(I,O) = ([2],[1])$. Whereas a connection process
$\mathbf{C}_{\{1,2\}} \subseteq S^2$ is functional for both
input/output partitions $(I,O) = ([1],[2])$ and $(I,O) = ([2],[1])$.
This is due to the constraints imposed on the two signals.
\end{example}

A Process $\mathbf{P} \subseteq S^N$ is called \emph{sequence functional} with
respect to a input/output partition $(I,O)$ if for each pair of
behaviors of the process where the input signals are sequence equivalent,
the output signals must be sequence equivalent as well,
i.e., $\forall{\mathbf{s_1} \in \mathbf{P}, \mathbf{s_2} \in \mathbf{P}}:
\Sigma(\pi{}_I(\mathbf{s_1})) = \Sigma(\pi{}_I(\mathbf{s_2})) \implies
\Sigma(\pi{}_O(\mathbf{s_1})) = \Sigma(\pi{}_O(\mathbf{s_2}))$.

\subsection{Models of Computation}

After defining processes, we are able to review the definitions of some MoCs.

\subsubsection*{Sequential Process}
A \emph{sequential process} is a process $\mathbf{P}$ with a self loop $\mathbf{C}_{\{i,i'\}}$
(As for example shown in Figure~\ref{fig:example-self-loop} on page~\pageref{fig:example-self-loop}) in which
the tags $T(s_i) = T(s_{i'})$ of the connected signals $s_i = s_{i'}$ are totally ordered.
This can be interpreted as the well known \emph{Von Neumann model of computation}, where the
events $e = (t,v) \in s_i$ correspond to the state $v$ of the process $\mathbf{P}$ at a certain
instance of time $t$ and the signal $s_i$ corresponds to the history of states which
have occured during the execution of the process $\mathbf{P}$.
%Below, we will show several ways to construct untimed concurrent systems by composing sequential systems.

\subsubsection*{Communicating Sequential Processes}

\begin{figure}[htb]
\centering
\input{example-csp-tsm-fig.tex}
\caption{Two sequential processes $\mathbf{P}_1$ and $\mathbf{P}_2$
         and a connection $\mathbf{C}_{\{3,4\}}$ used for rendezvous
         communication between these two processes. \label{fig:example-csp-tsm}}
\end{figure}

\emph{Communicating Sequential Processes} is a MoC introduced by Hoare
\cite{csphoare:1985} which consists of sequential processes which communicate
via so-called \emph{rendezvous channels}. Rendezvous means that a sequential
process $\mathbf{P}_1$
reaches a particular state $v_i, (t_i,v_i) \in s_1$ in its program execution
at which point it waits till another sequential processes $\mathbf{P}_2$
reaches a corresponding state $v_j, (t_j,v_j) \in s_6$. If both processes
have reached their rendezvous states they proceed in their execution.

This behavior can be represented in the tagged signal model as shown in
Figure~\ref{fig:example-csp-tsm} where both processes $\mathbf{P}_1$ and
$\mathbf{P}_2$ are modelled as sequential processes by their self loops
$\mathbf{C}_{\{1,2\}}$ and $\mathbf{C}_{\{5,6\}}$. The additional connection
$\mathbf{C}_{\{3,4\}}$ between these two processes is used to capture the
rendezvous behavior by requiring an event $e_r = (v_r,t_r) \in s_3$ for
each pair of states $v_i, (t_i,v_i) \in s_1$ and $v_j, (t_j,v_j) \in s_6$
where the two processes must have a rendezvous.

% Note that CSP and CCS are neither synchronous
% nor even timed. Events directly modeling a rendezvous are synchronous, but
% events that are not associated with rendezvous have only a partial ordering
% relationship with each other. Indeed, this partial ordering is one of the most
% interesting properties of these models of computation, particularly when there
% are more than two processes. In some such models of computation, a process can
% reach a state where it will rendezvous with one of several other processes
% (this sort of behavior is supported, for example, by the  select  statement in
% Ada). In this case, a composition of such processes is often nondeterminate.

\subsubsection*{Kahn Process Network}

\emph{Kahn Process Network} is a MoC introduced by Kahn \cite{kahn:1974}
which consists of processes which communicate with each other via
unidirectional unbounded FIFO \emph{channels} with a  single reader and
a single writer. The FIFO property implies that each signal $s$ in any
behavior $\mathbf{s}$ of any Kahn process in the Kahn Process Network
is discrete. But the set of all tags $T$ is in general only partially ordered.

Before formally defining a Kahn Process, we first need a partial order on
the set $V^{**}$. A set with an associated partial order is called a
\emph{poset}. Let $\sqsubseteq$ called \emph{prefix order} denote the
associated partial order on the set $V^{**}$ of all finite and infinite sequences of $V$.
And let $\mathbf{v}_1 \sqsubseteq \mathbf{v}_2$ denote that
$\mathbf{v}_1$ is a prefix of the sequence $\mathbf{v}_2$, i.e.,
$\mathbf{v}_1 \sqsubseteq \mathbf{v}_2 \iff \forall{n \in T(\mathbf{v}_1)}: \mathbf{v}_1(n) = \mathbf{v}_2(n)$.

An \emph{upper bound} of a subset $X \subseteq V^{**}$ is an element
$\mathbf{v} \in V^{**}$ where every sequence $\mathbf{x}$ in $X$ is a
prefix of $\mathbf{v}$, i.e., $\forall{\mathbf{x} \in X}: \mathbf{x} \sqsubseteq \mathbf{v}$.
A \emph{least upper bound} of a subset $X \subseteq V^{**}$, written $\sqcup X$,
is an upper bound which is a prefix of every other upper bound of $X$.
A \emph{lower bound} and \emph{greatest lower bound} of $X \subseteq V^{**}$,
written $\sqcap X$, are defined respectively.

A \emph{chain} in a poset $X$ is a totally ordered subset of $X$. A
\emph{bottom element} of a poset $X$, if it exists, is an element of the
poset which is also a greatest lower bound of the whole poset $\sqcap X \in X$.
A \emph{complete partial order} is a poset $X$ with a bottom element
in which every chain $Y \subseteq X$ has a least upper bound
$\sqcup Y$. The set $V^{**}$ of all finite and infinite sequences of $V$
is a complete partial order with bottom element $\lambda$, the
empty sequence.

This definitions can be trivially generalized to tupples of sequences
$\upsilon \in (V^{**})^N$, i.e., $\upsilon_1 \sqsubseteq \upsilon_2 \iff
\forall{n \in \mathbb{N}_N}: \upsilon_1(n) \sqsubseteq \upsilon_2(n)$.
With this generalization the set $(V^{**})^N$ of all $N$-tupples of finite and
infinite sequences of $V$ is also a complete partial order with
bottom element $\Lambda = (\lambda, \lambda, \ldots, \lambda)$, the $N$-tupple
of empty sequences $\lambda$.

A function $F: (V^{**})^N \to (V^{**})^M$ is \emph{monotonic} if
adding additional elements to the input sequence tupple $\upsilon_{in} \in (V^{**})^N$
results in additional elements on the output sequence tupple
$\upsilon_{out} = F(\upsilon_{in}) \in (V^{**})^M$,i.e.,
$\forall{\upsilon_{in_1}, \upsilon_{in_2} \in (V^{**})^N}:
\upsilon_{in_1} \sqsubseteq \upsilon_{in_2} \implies F(\upsilon_{in_1}) \sqsubseteq F(\upsilon_{in_2})$.
This can be considered as a untimed notion of causality
where the additional elements to the input sequence correspond
to input tokens and the additional elements on the output sequence
are the tokens produced from the consumption of these input tokens.

A function $F: (V^{**})^N \to (V^{**})^M$ is \emph{continuous} if
for every chain $Y$ in $(V^{**})^N$, $F(Y)$ has a least upper bound
$\sqcup F(Y)$ which is equal to the function $F$ applied to the
upper bound $\sqcup Y$ of the chain $Y$,
i.e., $\forall{Y \subseteq (V^{**})^N, Y\textrm{ is a chain}}: F(\sqcup Y) = \sqcup F(Y)$.
Where $F : 2^{\left( (V^{**})^N \right)} \to 2^{\left( (V^{**})^M \right)}$
is the pointwise extension of $F : (V^{**})^N \to (V^{**})^M$, i.e.,
$F(Y) = \{ F(\upsilon) \mid \upsilon \in Y\}$. Note that
every continuous function is also monotonic but the reverse
is not necessarily true.

Formally a Kahn Process is a  continuous function $F: (V^{**})^N \to (V^{**})^M$
\cite{kahn:1974,stark87concurrent:1987}.
The corresponing process in the tagged signal model is defined by
$\mathbf{P} = \{ \mathbf{s} \mid \mathbf{s} \in S^{N+M},
  \Sigma(\pi{}_{[N+1,N+2,\ldots,N+M]}(\mathbf{s})) =
  F(\Sigma(\pi{}_{[1,2,\ldots,N]}(\mathbf{s}))) \}$.
However the causality represented by the monotonicity of the
Kahn Process must be converted to ordering constraints
between events of different signals of the process $\mathbf{P}$.

For example, let $\mathbf{P} \ni (s_1,s_2)$ be a Kahn Process
represented in the tagged signal model
which reads two input tokens before generating an output token and
let $s_1$ be the input signal and $s_2$ be the output signal then
$\forall{i_1 \in \mathbb{N}_{|s_1|}, i_2 \in \mathbb{N}_{|s_2|}}: i_1 \le 2 \cdot i_2 \implies \Sigma(T(s_1))(i_1) \le \Sigma(T(s_2))(i_2)$.


%Fortunately, this means in practice
%that the function is also \emph{continuous} since practical monotonic
%processes are invariably continuous, at least in the context
%of Kahn process networks \cite{LeeDenotialDF:1997}.
%The read and write actions by a Kahn process are translated into
%ordering constraints on events between different signals of the process.

\section{Actor-Oriented Design}\label{actor-oriented-design}

Instead of a monolithic approach for representing an executable specification
of an embedded system,
in this report, we will use a refinement of \emph{actor-oriented} design.
In actor-oriented design, \emph{actors} only
communicate with each other via \emph{channels} instead of method calls as known
in object-oriented design.

A model of computation is defined in \cite{embsft:2002} as the
interaction policy between actors in an actor-oriented design
\cite{agha97abstracting:1997}. Actors are objects which execute concurrently. They can only
communicate with the environment (other actors) through their \emph{actor ports}.
The actor ports are connected with each other via channels.
These concepts are related to the tagged signal model in the following way:
(i) actors are processes with a predetermined input/output partition
(ii) actor ports are used to name signals and are equivalent to the position of signals in
a behavior of a process
(iii) channels are processes too.

In our proposed methodology, the specification is more
detailed than in actor-oriented design. The actor is divided into
its \emph{node functionality} and its \emph{firing rules}. The
type of firing rules an actor can show is dependent on its \emph{node interface}.

% The data values, which are communicated over the channels
% are abstracted. Thus, these data are called \emph{tokens} regardless
% of their type or value.

\begin{sdefinition}\label{actor}
An actor is a tupple $A=(\mathcal{F},\mathcal{R},I,O)$ containing
a \emph{node functionality} $\mathcal{F}$, \emph{firing rules} $\mathcal{R}$,
a set of \emph{actor input ports} $I$, and a set of \emph{actor output ports} $O$.
\end{sdefinition}

However these aspects are not sufficient for distinguishing MoCs.
The communication network used by actors must be considered as well.
These infrastructure is seperated into \emph{network graph} and
\emph{channel kind}. In the following , the four parts of our actor
oriented-design will be discussed in detail. Moreover, we will define
different types of these parts in order to allow the identification
of different MoCs.

% An aspect can be further divided into
% \emph{aspect types} by different constraints imposed on an aspect.
% In the following, the aspects and their further
% differentiation into aspect types is discussed in depth:
% In particular, four different aspects for distinguishing MoCs can be identified.

\subsection{Network Graph}\label{network-graph} 

To represent an executable specification, not only information about
individual actors but also information about the communication network,
which is the only means of communication between actors,
must be provided.
% Moreover, information about hierarchical composition of actors is required.
This information is stored in the \emph{network graph}.

\begin{definition}\label{network-graph}
A network graph is a directed bipartite graph $G_N=(\mathcal{A},C,E)$ containing
a set of actors $\mathcal{A}$, a set of channels $C$, and a set of
directed edges $E \subseteq (C \times \mathcal{P}_I)
\cup (\mathcal{P}_O \times C)$, where
$\mathcal{P}_I = \bigcup{}_{A \in \mathcal{A}} A.I$
is the set of actor input ports of all actors in the network graph and
$\mathcal{P}_O = \bigcup{}_{A \in \mathcal{A}} A.O$
is the set of actor output ports of all actors in the network graph.
Each actor $A \in \mathcal{A}$ can only communicate with other actors
through its dedicated actor input ports $A.I$ and
actor output ports $A.O$.
Furthermore, the set of all actor input and actor output ports of all actors in
the network graph is given by $\mathcal{P} = \mathcal{P}_I \cup \mathcal{P}_O$ and
the set of all input and output ports of an actor is given by $\mathcal{P}_{A} = A.I \cup A.O$.

% A network graph is a 5-tuple $N=(\mathcal{A},C,P_{i},P_{o},E)$ containing
% a set of actors $\mathcal{A}$, a set of channels $C$, a set of uplevel
% input ports $P_{i}$, a set of uplevel output ports $P_{o}$ and a set of
% directed edges $E \subseteq ((P_{i} \cup C) \times \mathcal{A}_{P_{i}})
% \cup (\mathcal{A}_{P_{o}} \times (P_{o} \cup C))$, where
% $\mathcal{A}_{P_{i}} = \bigcup{}_{A \in \mathcal{A}} A_{P_{i}}$
% is the set of all actor input ports of the network graph and
% $\mathcal{A}_{P_{o}} = \bigcup{}_{A \in \mathcal{A}} A_{P_{o}}$
% is the set of all actor output ports of the network graph.
% Each actor $A \in \mathcal{A}$ can only communicate with other actors
% through its dedicated actor input ports $A_{P_{i}}$ and
% actor output ports $A_{P_{o}}$.
% Furthermore, the set of all input and output ports of an actor
% is given by $A_{P} = A_{P_{i}} \cup A_{P_{o}}$ and
% the set of all actor input and actor output ports of the network graph
% is given by $\mathcal{A}_{P} = \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}}$.

\end{definition}

There are two \emph{network graph types} which are distinguished in our methodology:

\begin{definition}\label{conflicting-network-graph}
  A \emph{conflicting network graph} is constrained such that exactly
  one edge is incident to each actor port,
  i.e., $\forall{p \in \mathcal{P}}: |((\{p\} \times C) \cup (C \times \{p\})) \cap E| = 1$.
\end{definition}

\begin{figure}
\centering
%\includegraphics[scale=1]{fig:ng-conflicting.\graphicPostfix}\\
\input{ng-conflicting-fig.tex}
\begin{displaymath}
\begin{array}{rcl}
  G_N & = & (\mathcal{A},C,E) \\
  \mathcal{A} & = & \{A_1,A_2,A_3,A_4\} \\
      &   & A_1.I = \emptyset, A_1.O=\{o_1,o_2\}, A_2.I = \{i_1,i_2\}, A_2.O=\{o_1\},\\
      &   & A_3.I = \{i_1,i_2\}, A_3.O=\{o_1\},A_4.I = \{i_1\}, A_4.O=\{o_1\}\\
  C   & = & \{c_1,c_2,c_3,c_4\} \\
  E   & = & \{(A_1.o_1,c_1),(c_1,A_2.i_1),(A_1.o_2,c_2),(c_2,A_2.i_2),(A_2.o_1,c_3),\\
      &   &   (c_3,A_3.i_1),(A_3.o_1,c_4),(c_4,A_3.i_2),(A_4.o_1,c_4),(c_4,A_4.i_1)\}\\
\end{array}
\end{displaymath}
\caption{\label{fig:ng-conflicting}In a \emph{conflicting network graph} exactly
  one edge is incident to an actor port. Multiple edges can
  enter and leave a channel, e.g., channel $c_4$
  which has both an indegree and outdegree of two.}
\end{figure}

  An example of a conflicting network graph is shown in Figure~\ref{fig:ng-conflicting}.
  It demonstrates the use of a conflicting network graph for modeling
  a Multiply-Accumulate-Unit which accumulates in channel $c_4$ the
  product of the values generated by the source actor $A_1$.
  The controller actor $A_4$ can replace the
  accumulated value in $c_4$ by using the conflict at channel $c_4$ which
  allows to read/write the values in the channel from different actors.
  This can be used to either accumulate additional data via actor $A_3$
  or exchange the value via actor $A_4$.

\begin{definition}\label{noconflicting-network-graph}
  A \emph{nonconflicting network graph} is a conflicting network graph with the
  additional constraint that the indegree and outdegree of each channel in
  the graph is exactly one, i.e.,
  $\forall{c \in C}: |(\{c\} \times \mathcal{P}_I) \cap E| = 1 \wedge
                     |(\mathcal{P}_O \times \{c\}) \cap E| = 1$.
\end{definition}

  An example of a nonconflicting network graph is shown in Figure~\ref{fig:ng-nonconflicting}.
  It demonstrates the use of a nonconflicting network graph for modeling
  a Multiply-Accumulate-Unit which accumulates in channel $c_4$ or $c_5$ the product of
  the values generated by the source actor $A_1$.
  Additionally each token received by the duplicator actor $A_4$ via actor port $A_4.i_1$
  is forwarded to both actor output ports $A_4.o_1$ and $A_4.o_2$.
  Thus, the sink actor $A_5$ receives a copy of the accumulated value at
  each update of the accumulated value.

\begin{figure}
\centering
%\includegraphics[scale=1]{fig:ng-nonconflicting.\graphicPostfix}\\
\input{ng-nonconflicting-fig.tex}
\begin{displaymath}
\begin{array}{rcl}
  G_N & = & (\mathcal{A},C,E) \\
  \mathcal{A} & = & \{A_1,A_2,A_3,A_4,A_5\} \\
      &   & A_1.I = \emptyset, A_1.O=\{o_1,o_2\}, A_2.I = \{i_1,i_2\}, A_2.O=\{o_1\},A_3.I = \{i_1,i_2\},\\
      &   & A_3.O=\{o_1\},A_4.I = \{i_1\}, A_4.O=\{o_1,o_2\}, A_5.I = \{i_1\}, A_5.O=\emptyset \\
  C   & = & \{c_1,c_2,c_3,c_4,c_5,c_6\} \\
  E   & = & \{(A_1.o_1,c_1),(c_1,A_2.i_1),(A_1.o_2,c_2),(c_2,A_2.i_2),(A_2.o_1,c_3),\\
      &   &   (c_3,A_3.i_1),(A_3.o_1,c_4),(c_4,A_4.i_1),(A_4.o_1,c_5),(c_5,A_3.i_2),\\
      &   &   (A_4.o_2,c_6),(c_6,A_5.i_1)\} \\
\end{array}
\end{displaymath}
\caption{\label{fig:ng-nonconflicting} In a \emph{nonconflicting network graph} exactly
  one edge is incident to an actor port and the channels are
  constraint to have an indegree and outdegree of exactly one.
  Hence, the channels can only be used for dedicated
  Point-to-Point connections.}
\end{figure}

\subsection{Channel Kind}\label{channel-kind}

The \emph{channel kind} defines the communication semantics of a channel.
Since the communication semantics are not influenced by the
data type communicated, the actual \emph{type} of a communication
channel is derived from the channel kind by parameterizing it with
the type of the communicated data. Examples for channel kinds are:

\begin{itemize}
\item \label{channel-kind-fifo} FIFO:
  An unbounded FIFO channel for communication
  (nonblocking write and blocking read) implementing
  a first in first out discipline.

\item \label{channel-kind-rendezvous} Rendezvous:
  A rendezvous channel for communication % and barrier synchronisation
  (blocking write and read).
%  A rendezvous channel corresponds to a connection process
%  $\mathbf{C}_{\{x,y\}}$ in the tagged signal model.

\item \label{channel-kind-register} Register:
  For expressing communication via shared variables
  (nonblocking write and nonblocking read).
\end{itemize}

\subsection{Node Functionality}\label{node-functionality}

In actor-oriented design the node functionality and the firing rules
are combined into one opaque block, which can in general not be analyzed.
However the information in this block would help to reason about communication
patterns, to produce optimized code, and to check system properties.
In our methodology proposed in this report, the actor concept is still used,
but we distinguish two different aspects of an actor $A$. The first part called
\emph{node functionality} ($A.\mathcal{F}$) is responsible for transforming the data values
which reside inside tokens. The node functionality will still be regarded as
an opaque block we do not try to analyze in this report.

\begin{definition}\label{node-functionality}
  The \emph{node functionality} of an actor $A$ is a tupple $A.\mathcal{F} = (F,Q,q_1)$
  containing a set of \emph{functions} $F$, a set of \emph{functionality states} $Q$
  (possibly infinite), and an \emph{initial functionality state} $q_1$.
\end{definition}

The functions $f \in F$ of the node functionality map a fixed number of
input values $(v_{i1},v_{i2},\ldots,v_{iN}) = \mathbf{v}_i \in V^N$
and a functionality state $q_i \in Q$ to a fixed number of output values
$(v_{o1},v_{o2},\ldots,v_{oM}) = \mathbf{v}_o \in V^M$ and a new
functionality state $q_{i+1} \in Q$, i.e.,  $f: V^N \times Q \to V^M \times Q$.

The functions in the node functionality can be implemented by any
programming language % (E.g. C++ in case of the \SysteMoC{} framework, See Figure~\ref{example-node-functionality})
but the user must guarantee, that the functions
(i) terminate, and (ii) do not communicate directly with other actors
avoiding the \SysteMoC{} communication mechanism.
% The node functionality is the only aspect which is not
% further distinguished into aspect types.
The input values $v_{i1}, v_{i2}, \ldots$ are provided by the firing rules
which receive them from the channels connected to the actor input ports.
The output values $v_{o1}, v_{o2}, \ldots$ produced by the execution of
the node functionality are later written to the actor output ports by
the firing rules. The communication of input and output values between the
node functionality and the firing rules happens via temporary buffers in
the actor ports.

\subsection{Node Interface}\label{node-interface}

The second part of an actor $A$ which determines its communication
behavior is called \emph{firing rules} ($A.\mathcal{R}$). The firing rules
determine for each actor port the number of tokens to receive or send
until the associated node functionality can be invoked.
The firing rules are encoded in form of a finite state machine (FSM).

\begin{definition}\label{firing-rules}
  The \emph{firing rules} of an actor $A$ is a 4-tuple $A.\mathcal{R} = (\mathcal{T}, Q, q_1, \delta)$
  containing a set of \emph{firing transitions} $\mathcal{T}$,  a set of \emph{firing states} $Q$,
  an \emph{initial firing state} $q_1$, and a \emph{firing transition function} $\delta: Q \to 2^\mathcal{T}$
  which maps each state $q \in Q$ to its set of transitions
  $\mathcal{T}_q \subseteq \mathcal{T}$ which leave this state.
\end{definition}
% \emph{Firing rules} is a 5-tuple $R = (S, Q, \mathcal{J}, k, s_0)$ containing
% a set of \emph{firing states} $S$, a set of activation patterns $Q$,
% a set of interface actions $\mathcal{J}$, an action selection function
% $k: S \times Q \to \mathcal{J} \cup \bot$,
% and a initial state $s_0 \in S$. An actor is inactive until at least
% one activation pattern $q$ is enabled which has a corresponding
% interface action in the current firing state $s \in S$ of the actor,
% i.e., $\exists{q \in Q}: k(s,q) \ne \bot \wedge q\ \textrm{is enabled}$.
% The set of ready activation patterns is given by $Q_{ready}$.
% Exactly one activation pattern $q \in Q_{ready}$ will be
% chosen nondeterministically and its corresponding interface action
% $k(s,q)$ will be executed.

An actor is \emph{blocked} until at least one firing transition
$\mathbf{t} \in \mathcal{T}_q$ for the current state $q$ is enabled.
The set of enabled transitions is given by
$\mathcal{T}_{\mathrm{ready\ in\ }q} = \{ \mathbf{t} \mid \mathbf{t} \in \mathcal{T}_q \wedge \mathbf{t} \textrm{ is enabled}\}$.
Exactly one transition $t \in \mathcal{T}_{\mathrm{ready\ in\ }q}$ will be
chosen nondeterministically for execution.
A firing transition is annotated with a condition called
\emph{activation pattern} and an action called \emph{interface action}.

\begin{definition}\label{firing-transition}
  A \emph{firing transition} is a tuple $\mathbf{t} = (k,J)$ containing
  an \emph{activation pattern} $k$ and an \emph{interface action} $J$.
\end{definition}

An activation pattern is a predicate on actor ports. It encodes how many
tokens to send (via actor output ports) or to receive (via actor input ports)
when the activation pattern is executed.

\begin{definition}\label{activation-pattern}
  An \emph{activation pattern} is a function
  $k: A.I \cup A.O \to \mathbb{Z}^+_0,\ k \in \mathcal{K}$
  which maps each actor port of the actor $A$ to a nonnegative integer.
\end{definition}

An activation pattern $k$ is enabled if for each actor input port
$p_I \in A.I$ at least $k(p_I)$ tokens can be received and for each
actor output port $p_O \in A.O$ at least $k(p_O)$ tokens can be sent.
If an activation pattern $k$ is executed it receives $k(p_I)$ tokens
via the actor input port $p_I$ and stores them in
temporary buffers in these actor input ports. For actor output ports
$p_O$ the $k(p_O)$ tokens in temporary buffers of the actor
output ports are sent via these ports.

\begin{example}\label{ex:example-activation-pattern}
Assuming the actor input ports $I = \{i_1,i_2,i_3\}$ and output ports
$O = \{o_1,o_2\}$ are connected to bounded FIFO channels then the
activation pattern 
\[k(p) = \left\{ \begin{array}{ll}
2 & \textrm{if $p = i_1$} \\
1 & \textrm{if $p = i_2$} \\
1 & \textrm{if $p = o_1$} \\
0 & \textrm{otherwise}
\end{array} \right.\]
is enabled, if there are at least two token in the FIFO channel connected
via $i_1$, at least one token in the FIFO channel connected via $i_2$, and
there is space available for at least one additional token in the FIFO channel
connected via $o_1$.
\end{example}

The specification of an activation pattern by its function as seen in Example~\ref{ex:example-activation-pattern}
poses a great overhead. Therefore, we will use the shortcut notation
$i_1(2) \& i_2(1) \& o_1(1)$ to express the same information.

\begin{definition}\label{interface-action}
  An \emph{interface action} is a tuple $J = (f,Q_\mathrm{succ}),\ J \in \mathcal{J}$ containing
  a function $f \in A.\mathcal{F}.F$ of the node functionality $A.\mathcal{F}$
  and a set of possible successor states $Q_\mathrm{succ}$. Where the set of
  possible successor states must contain at least one element, i.e.,
  $|Q_\mathrm{succ}| \ge 1$.
\end{definition}

A transition $\mathbf{t} = (k,J)$ is enabled if its activation
pattern $k$ is enabled. If a transition $\mathbf{t}$ is enabled and 
part of the transitions $\mathcal{T}_q$ which leave the current state $q$
the transition $\mathbf{t}$ can be taken, i.e.,
$(k,J) = \mathbf{t} \in \mathcal{T}_q \wedge k\textrm{ is enabled} \implies \mathbf{t}\textrm{ can be taken}$.

A transition $\mathbf{t} = (k,J)$ is called a \emph{deterministic transition}
if the associated interface action $J$ has only one successor state, i.e.,
$|J.Q_\mathrm{succ}| = 1$. An example of a deterministic transition can
be seen in Figure~\ref{fig:deterministic-transition}.
A transition $\mathbf{t} = (k,J)$ is called a \emph{conflict transition}
if the associated interface action $J$ has more then one possible
successor state, i.e., $|J.Q_\mathrm{succ}| > 1$. An example of a
conflict transition can be seen in Figure~\ref{fig:conflict-transition}.

\begin{figure}[h]
\centering
\input{deterministic-transition-fig.tex}
\caption{Example of a deterministic transition $\mathbf{t} = (k,J)$
with $k = i_1(2) \& i_2(1) \& o_1(1)$, $J.f = f_1$, and
$J.Q_\mathrm{succ} = \{S_x\}$.}
\label{fig:deterministic-transition}
\end{figure}

\begin{figure}[h]
\centering
\input{conflict-transition-fig.tex}
\caption{Example of a conflict transition $\mathbf{t} = (k,J)$
with $k = i_1(1) \& o_2(1)$, $J.f = f_2$, and $J.Q_\mathrm{succ} = \{S_x,S_y,S_z\}$.}
\label{fig:conflict-transition}
\end{figure}

The notion of firing is similar to the concepts introduced in
SPI~\cite{ZERTT99a} and FunState~\cite{STZETG00}.
If a transition $\mathbf{t} = (k,J)$ is taken first the assosciated
activation pattern $k$ then the function $J.f$ of the node functionality
is executed. In case of a deterministic transition the current firing
state is updated to the single successor state in $J.Q_\mathrm{succ}$.
In case of a conflict transition the successor state actually used is
a runtime decision of the function $J.f$.

These firing rules are constructed by use of the following operations:

\begin{itemize}
\item branch

\emph{Branch} is a operation which maps a function $f$ of the node functionality and
a none empty set of firing state $Q_B \ne \emptyset$ to an interface action $J$,
i.e., $\textrm{Branch}: A.\mathcal{F}.F \times 2^{A.\mathcal{R}.Q} \to \mathcal{J}$.
If the resulting interface action $J$ is included into a transition
$\mathbf{t}$ it permits to create a conflict transition.

\item call

\emph{Call} is a operation which maps a node functionality $f$ of the node functionality and
a firing state $q$ to an interface action $J$,
i.e., $\textrm{Call}: A.\mathcal{F}.F \times A.\mathcal{R}.Q \to \mathcal{J}$.
If the resulting interface action $J$ is included into a
transition $\mathbf{t}$, it creates a deterministic transition.
Furthermore, the call operation is clearly a subset of the
branch operation.

\item transition

\emph{Transition} is a operation which maps an activation pattern $k$ and
an interface action $J$ to an interface transition $\mathbf{t}$,
i.e., $\textrm{Transition}: \mathcal{K} \times \mathcal{J} \to \mathcal{T}$.

\item choice

\emph{Choice} is a operation which maps a set of interface transitions $\mathcal{T}$
to a firing state $q$,
i.e., $\textrm{Choice}: 2^{\mathcal{T}} \to Q$.
The firing state created by this operation can have multiple outgoing
transitions.

\item transact

\emph{Transact} is a operation which maps an interface transition $T$
to a firing state $s$,
i.e., $\textrm{Transact}: \mathcal{T} \to Q$.
The firing state created by this operation has only one outgoing
transition $\mathbf{t}$.
Furthermore, the transact operation is clearly a subset of the
choice operation.

\end{itemize}

The set of operations available to construct the firing rules constraints
the type of firing rules that can be constructed.
Our methodology distinguishes three separate \emph{node interface types}
by the set of operations available to them:

\begin{definition}\label{choice-node-interface-type}
Choice node interface provides the operations
\emph{transition}, \emph{choice}, \emph{transact}, \emph{call} and \emph{branch}.
\end{definition}

An example of firing rules constructible with this node interface
type can be seen in Figure~\ref{fig:firing-rules-choice}.

\begin{figure}
\centering
\input{firing-rules-choice-fig.tex}
\caption{Example of firing rules which can be created by the choice node interface}
\label{fig:firing-rules-choice}
\end{figure}

\begin{definition}\label{transact-node-interface-type}
Transact node interface provides the operations
\emph{transition}, \emph{transact}, \emph{call} and \emph{branch}.
\end{definition}

An example of firing rules constructible with this node interface
type can be seen in Figure~\ref{fig:firing-rules-transact}.

\begin{figure}
\centering
\input{firing-rules-transact-fig.tex}
\caption{Example of firing rules which can be created by the transact node interface}
\label{fig:firing-rules-transact}
\end{figure}

\begin{definition}\label{fixed-transact-node-interface-type}
Fixed transact node interface provides only the operations
\emph{transition} and \emph{call}.
\end{definition}

An example of firing rules constructible with this node interface
type can be seen in Figure~\ref{fig:firing-rules-fixed-transact}.

\begin{figure}
\centering
\input{firing-rules-fixed-transact-fig.tex}
\caption{Example of firing rules which can be created by the fixed transact node interface}
\label{fig:firing-rules-fixed-transact}
\end{figure}

% \emph{Choice} is an operation defined on a set of actor ports $A_{P}$
% and a function $D: A_{P} \to \mathcal{F}$, which maps each actor port
% $a_{p} \in A_{P}$ to a function $F_{x} \in \mathcal{F}$.
% The choice operation postpones the process execution 
% until at least one actor port $a_{p} \in A_{P}$
% becomes ready to communicate. The set of actor ports available
% is given by $A_{P_{ready}}$.
% Exactly one actor port $a_{p} \in A_{P_{ready}}$
% will be chosen nondeterministically. After
% finishing the communication on the chosen actor port $a_{p}$
% the process execution will continue
% with function $F_{continue} = D(a_{p})$.

\section{Revision of Different MoCs}\label{revision-of-mocs}

The \emph{characteristics} of different MoCs can be separated into two distinct groups.
There are the \emph{execution characteristics} which must be provided by
the programming system otherwise the MoC cannot be implemented.
On the other hand, there are the \emph{analysis characteristics} which
permit the extraction of information needed for MoC-Specific analysis.

In the following subsections, different MoCs are considered and their
characteristics are determined. For each MoC these characteristics are
mapped onto the aspects presented in the previous Section.

\subsection{Communicating Sequential Processes (CSP)}
\emph{Communicating Sequential Processes} \cite{csphoare:1985}
is a MoC which consists of concurrently executing processes
which communicate via unidirectional \emph{rendezvous channels}.
As a difference to the CSP model of Hoare \cite{csphoare:1985}
which allows runtime creation of processes via parallel
composition and recursion, the CSP model considered in this report
is constraint to a fixed predetermined set of processes.
This constraint is required to allow hardware synthesis from this
model.

The following characteristics are the execution characteristics to
implement CSP behavior:

\begin{characteristic}\label{characteristic-csp-rendezvous}
  Rendezvous channel for communication
\end{characteristic}

\begin{characteristic}\label{characteristic-csp-general-choice}
  A communication method for Hoare's so-called \emph{general choice}
  
  General choice written $ce_{1} \to F_1 \Box ce_{2} \to F_2$
  is a operation defined on a set of \emph{channel expressions} $CE$ and
  a function $D: CE \to \mathcal{F}$, which maps each channel expression
  $ce \in CE$ to a function $F \in \mathcal{F}$. A channel
  expression can either send the content of a variable $v$ to
  a channel $c$ which is written $c!v$ or receive a value from
  a channel $c$ and store it in variable $v$ which is written
  $c?v$. A channel expression is ready to communicate when its
  associated channel is ready to communicate.
  The general choice operation postpones the process execution 
  until at least one channel expression $ce \in CE$
  becomes ready to communicate. The set of channel expressions
  ready to communicate is given by $CE_{ready}$.
  Exactly one channel expression $ce \in CE_{ready}$
  will be chosen nondeterministically. After
  finishing the communication for the chosen channel expression $ce$
  the process execution will continue
  with function $F_{continue} = D(ce)$.

\end{characteristic}

\begin{characteristic}\label{characteristic-csp-concurrent-processes}
  Fixed set of concurrently executing processes
  
  The CSP \emph{parallel composition} operation written $F_1 \| F_2$ executes the
  function $F_1$ and $F_2$ in parallel and terminates when both functions
  have terminated. By using recursion and parallel composition
  like $X = F_1 \| X$, CSP enables unlimited runtime creation of processes.
  Our CSP MoC only allows a fixed static number of processes. This
  leads to the constraint that only CSP programs can be represented which
  have a single init function which must not be called recursively. This init
  function creates all processes needed in the CSP program via parallel composition.
  Other functions in the CSP program must not use the parallel composition
  operation.
\end{characteristic}

%\item Sequential composition of functions
%  
%  Sequential composition written $F_1 \to F_2 \to F_3 \to \ldots$
%  is 
% $\to$ is sequential composition

In the following, a CSP program for the well known dining
philosophers problem is demonstrated. To reduce the complexity
of the example the number of philosophers has been reduced
to two. Each philosopher has only two goals in life, namely to think and
to eat. Food is provided by a bowl of spaghetti on the table and
two forks for eating. To eat, each philosopher has to take a seat
at the table and take two forks which he will not release until he
is no longer hungry. As anybody knows this can lead to a deadlock.
This deadlock can can be eliminated by a footman which will only
allow philosopher to take a seat at the table if there are more
forks than philosophers at the table (See Figure~\ref{fig:dining-philosophers}
for the processes and connection topology used in the example).
The implementation demonstrates the use of the general choice operator
in the $Footman$ and the $Fork_{x}$ which are used to react to the first
philosopher requesting something from footman or fork.

\begin{figure}[h]
\centering
\input{dining-philosophers-fig.tex}
\caption{Processes and connection topology used for the ``Dining philosophers'' CSP example}
\label{fig:dining-philosophers}
\end{figure}

\begin{displaymath}
\begin{array}{rcl}
Philosopher_{i}    & := & FootSit_{i}!sit \to ForkReqL_{i}!take \to ForkReqR_{i\oplus1}!take \to \\
                   &    & Eat \to \\
                   &    & ForkReqL_{i}!drop \to ForkReqR_{i\oplus1}!drop \to FootStand_{i}!stand \to \\
                   &        & Philosopher_{i} \\
Fork_{i}           & := & ForkReqR_{i}?req_{r} \to ForkReqR_{i}?req_{r} \to Fork_{i} \Box \\
                   &    & ForkReqL_{i}?req_{l} \to ForkReqL_{i}?req_{l} \to Fork_{i} \\
Footman                   & := & FootSit_{0}?req_{0} \to FootStand_{0}?req_{0} \to Footman \Box \\
                   &    & FootSit_{1}?req_{1} \to FootStand_{1}?req_{1} \to Footman \\
InitFunction       & := & Philosopher_{0} \| Fork_{0} \| \\
                   &    & Philosopher_{1} \| Fork_{1} \| \\
                   &    & Footman \\
\end{array}
\end{displaymath}

Where $\oplus$ is addition modulo 2 and $\to$ has higher precedence than $\Box$.

To facilitate analysis of the CSP MoC, additionally the following
analysis characteristics must be given:
\begin{characteristic}\label{characteristic-csp-communication}
  Parallel executing processes must only communicate over Point-to-Point rendezvous channels.
\end{characteristic}

The characteristics \ref{characteristic-csp-rendezvous} -
\ref{characteristic-csp-communication} of the CSP MoC are mapped in the following way
onto the aspects presented in Section~\ref{actor-oriented-design}:
(i) The rendezvous communication %(Requirement~\ref{characteristic-csp-rendezvous})
used by CSP is provided by the channel kind rendezvous. %(See~\ref{channel-kind-rendezvous})
(ii) Hoare's general choice communication operator %(Requirement~\ref{characteristic-csp-general-choice})
is provided as a operation in the choice node interface. %(See~\ref{choice-node-interface-type})
(iii) The parallel executing processes %(Requirement~\ref{characteristic-csp-concurrent-processes})
created by the init functions are mapped to the concurrently executing actors.
%% (Subsection~\ref{node-functionality} and Subsection~\ref{node-interface})
(iv) The Point-to-Point communication of CSP over rendezvous channels %(Requirement~\ref{characteristic-csp-communication})
is provided by the nonconflicting network graph %(See~\ref{noconflicting-network-graph})
and its contained rendezvous channels, which are the only means of communication in a
actor-oriented design.

\subsection{Kahn Process Network (KPN)}
\emph{Kahn Process Network} \cite{kahn:1974} is a MoC
which consists of a fixed predetermined set of
concurrently executing processes which communicate via unidirectional
unbounded \emph{FIFO channels}. The input and output of a channel
are connected to dedicated processes. The process must implement
a continuous function $F: S^m \to S^n$ regarding a prefix order on
$S^m$ and $S^n$ \cite{kahn:1974,stark87concurrent:1987}.
Where $S^m$ is a $m$-tuple of token sequences on the process input channels
and $S^n$ is a $n$-tuple on token sequences on the process output channels.
If the communication over FIFO channels is realized with blocking
reads and nonblocking writes the previous requirement is automatically
satisfied \cite{stark87concurrent:1987}. However, the next channel
selected for a FIFO read or write operation can dependent on
the data values already read and the state of the actor.

% connected to the process of the process actor input
% port a number of tokens dependent on the port and the state
% of the actor must be available.
% Two closely related
% forms of dataflow are distinguished in the literature \cite{LeeDenotialDF:1997},
% Kahn Process Networks \cite{kahn:1974}, in the following 
% called KPN, and Dennis Dataflow \cite{}, in the following
% called DDF. DDF is an extension of KPN by the notion of
% firing. To enable firing of a DDF process each channel $c \in C$
% used as input by the process must have a certain number of
% tokens 

The following execution characteristics are required to
implement the KPN MoC:

\begin{characteristic}\label{characteristic-kpn-fifo}
  An unbounded FIFO channel for communication
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-fifo-read-write}
  A communication method to read from and write to FIFOs
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-concurrent-processes}
  Fixed set of concurrently executing processes
\end{characteristic}

In the following, an example KPN program for audio coding
is demonstrated. For the audio encoding an algorithm
adapted for multimedia audio or an algorithm adapted for speech
is dynamically selected depending on the input audio stream.
The CodecSelect actor forwards the raw audio stream to the
selected audio codec and gets feedback of the codec quality
via the corresponding CodecQuality channel. If a certain
limit for the codec quality is not satisfied the CodecSelect will
switch to the other audio codec. Additionally the CodecSelect actor
signals the StreamPacketizer via the PacketizerCodecSelect channel
which EncodedAudio channel must be chosen for input data to packetize.
(See Figure~\ref{fig:media-speech-audio-coding}
for the processes and connection topology used in the example):

\begin{figure}[h]
\centering
\input{media-speech-audio-coding-fig.tex}
\caption{Processes and connection topology used for the audio encoding KPN example}
\label{fig:media-speech-audio-coding}
\end{figure}

To facilitate analysis of the KPN MoC additionally the following
characteristics must be satisfied:
\begin{characteristic}\label{characteristic-kpn-communication}
  Parallel executing processes must only communicate over Point-to-Point FIFO channels.
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-determinism}
  The process must implement a continuous function $F: S^m \to S^n$
\end{characteristic}

The characteristics \ref{characteristic-kpn-fifo} -
\ref{characteristic-kpn-determinism} of the KPN MoC are mapped in the following way
onto the aspects presented in Section~\ref{actor-oriented-design}:
(i) The FIFO communication
used by dataflow is provided by the FIFO channel kind.
(ii) The fixed set of concurrently executing processes
are mapped to the concurrently executing actors.
(iii) The Point-to-Point communication of dataflow over FIFO channels
is provided by the nonconflicting network graph
and its contained FIFO channels, which are the only means of communication in a
actor-oriented design.
(iv) Read and write operations on this FIFOs are provided by
the transact operation of the transact node interface.
(v) The requirement for a continuous function is satisfied by using the
transact operation of the transact node interface.
The transact operation consumes and produces
a determined number of tokens on the actor ports
depending on the current state of the actor.
The node functionality must be deterministic, too.
Therefore the actor implements a function regarding the
prefix order on $S^m$ and $S^n$. Because the
transact functions does not allow canceling of already
written output of actor output ports, the functions is
\emph{monotonic}. Fortunately, this means in practice
that the function is also \emph{continuous} since practical monotonic
processes are invariably continuous, at least in the context
of Kahn process networks \cite{LeeDenotialDF:1997}.

\subsection{Synchronous Dataflow (SDF)}
Synchronous Data Flow \cite{Lee87b:1987} is a more constricted form of the
KPN MoC. It has all the characteristic of the KPN MoC and additionally the
following characteristic necessary for MoC analysis.

\begin{characteristic}\label{characteristic-sdf-fixed-rates}
The consumption and production rates of the actor must be constant.
In particular they are independent from the state of the actor.
\end{characteristic}

In the following, an example of a Multiply-Accumulate-Unit for stereo signals is given
as a SDF system. The unit reads two tokens from input $in_1$,
performs a multiplication for both tokens with a value read from $in_2$,
and accumulates the results in the channels $c_2$ and
$c_3$. The accumulated values are written to $o_1$ for each
token pair received on $in_1$.
In Figure~\ref{fig:sdf-mac-unit},
the constant consumption and production rates of the SDF
MoC are annotated at the actor input and output ports
respectively.

\begin{figure}[h]
\centering
\input{sdf-mac-unit-fig.tex}
\caption{Processes and connection topology used for a stereo signal MAC
  unit implemented in the SDF MoC}
\label{fig:sdf-mac-unit}
\end{figure}

The characteristics \ref{characteristic-kpn-fifo} -
\ref{characteristic-sdf-fixed-rates} of the SDF MoC are mapped in the following way
onto the aspects presented in Section~\ref{actor-oriented-design}: (i) - (iii) is identical
to the KPN MoC.
(iv) Read and write operations on the FIFOs are provided by the transact
operation of the fixed transact node interface.
(v) The constant consumption and production rates of the actor are
guaranteed by the fixed transact node interface which does
not allow the alteration of these rates once set.

\section{Software Architecture}\label{software-architecture}

Due to its high abstraction level and its capabilities in both,
hardware and software refinement, we have chosen SystemC
\cite{systemc-lrm:2003,glms:2002} as our platform for system design.
SystemC is an actor-oriented C++-Based design language and
already allows to express dataflow MoCs.

In the following, we propose a SystemC framework, called \SysteMoC, which
facilitates automatic extraction of a MoC from a SystemC design.
Actors in SystemC are C++ classes which are derived from the base class \code{sc\_module}.
The \SysteMoC{} framework provides the execution requirements for each MoC while
still supporting the extraction of the information needed for analysis.
This analysis is made possible by dividing the actor into its
node functionality and its node interface.
Furthermore, the \SysteMoC{} framework provides a way for these
actors to be connected to each other. This connections
are provided by the network graph.
%Actors can have their own thread of control or be without. Actors
%with their own thread of control will be called in the following
%active actors and actors without a dedicated thread of control
%passive actors.

\begin{figure}[h]
\centering
\input{SysteMoC-Goals-fig.tex}
\caption{Integration of \SysteMoC{} into SystemC}
\label{fig:SysteMoC-Goals}
\end{figure}

\subsection{Node Functionality}
The node functionality is only used for algorithmic transformations of data values.
The node functionality of an actor is defined in certain member functions,
which are called by the firing rules when their requirements for input data
is fulfilled. This member functions are not allowed to call communication
operations. All required input and output data values are kept in temporary buffers
in the actor ports. These buffers are managed by the firing rules which store
new data received via actor input ports in temporary buffers in these
actor input ports and send data in temporary buffers in actor output ports
to the channels connected via these ports. An example of an actor which all parts
except the node functionality stripped can be seen in Figure~\ref{example-node-functionality}.

%The firing rules store the input values in temporary buffers in the actor input ports
%for later usage by the functions of the node functionality.
%The node functionality stores the output values in temporary buffers in the actor output ports
%These temporary buffers are sent to the channels connected to these actor output ports by the
%firing rules.

\begin{figure}[h]
\centering
\begin{verbatim}
class my_actor ... {
  hscd_port_in<int>  i1, i2; // actor input port i1, i2
  hscd_port_out<int> o1;     // actot output port o1
  ...
  // qi the functionality state
  uint32_t sum;
  ...
  void accumulate()       { // A function of the node functionality
    sum +=                  // update functionality state
           i1[0] * i1[1];   // access position 0 and 1 of the temporary buffer in i1
    o1[0] = sum;          } // update position 0 of the temporary buffer in o1
  void reset()   { // A function of the node functionality
    sum = i2[0]; } // update functionality state with the value
                   // in position 0 of the temporary buffer in i2
  ...
  my_actor( ... ) : sum = 0, ... { ... }
};
\end{verbatim}
\caption{Example of a node functionality
($F = \{\textrm{accumulate}, \textrm{reset}\}$, $Q= [0,1,\ldots,2^{32}-1]$, $q_1 = 0$)
in the \SysteMoC{} framework}\label{example-node-functionality}
\end{figure}

\begin{figure}[h]
\centering
\scalebox{0.5}[0.5]{\input{ng-moc-identification-fig.tex}}
\caption{Identification of MoC in SystemC with \SysteMoC}
\label{fig:ng-moc-identification}
\end{figure}

%\begin{figure}[h]
%\centering
%\begin{verbatim}
%template <typename T>
%class m_adder // Actor m_adder
%  : public hscd_fixed_transact_node // Node interface
%{
%public:
%  hscd_port_in<T>  in;
%  hscd_port_out<T> out;
%private:
%  // Node functionality
%  void transform() {
%    out[0] = in[0] + in[1];
%    std::cout << "Adding " << in[0] << " + " << in[1]
%              << " = " << out[0] << std::endl;
%  }
%public:
%  m_adder( sc_module_name name )
%    :hscd_fixed_transact_node( name,
%        (in(2) & out(1)) >> call(transform) /* Firing rules */ ) {}
%};
%\end{verbatim}
%\caption{\label{example-adder-actor}Example of an adder in the \SysteMoC{} framework}
%\end{figure}
%
%\begin{figure}[h]
%\centering
%\begin{verbatim}
%template <typename T>
%class m_multiply // Actor m_multiply
%  : public hscd_fixed_transact_node // Node interface
%{
%public:
%  hscd_port_in<T>  in1;
%  hscd_port_in<T>  in2;
%  hscd_port_out<T> out;
%private:
%  // Node functionality
%  void transform() {
%    out[0] = in1[0] + in2[0];
%    std::cout << "Multiplying" << in1[0] << " * " << in2[0]
%              << " = " << out[0] << std::endl;
%  }
%public:
%  m_multiply( sc_module_name name )
%    :hscd_fixed_transact_node( name,
%        (in1(1) & in2(1) & out(1)) >> call(transform) /* Firing rules */ ) {}
%};
%\end{verbatim}
%\caption{\label{example-multiply-actor}Example of a multiplier in the \SysteMoC{} framework}
%\end{figure}

\subsection{Node Interface}
The problem of extracting the communication behavior of an actor is caused
by the fact, that the communication methods in SystemC are all accessible
to all SystemC modules. Moreover, execution of these methods is controlled
by the Turing complete coding possibilities in the actor. To remedy these
problems, we prohibit any method calls on \SysteMoC{} channels
by the node functionality. Moreover,
communication over other media than \SysteMoC{} channels is forbidden.
Unfortunately this cannot be strictly enforced. Hence, we require the \SysteMoC{} user
to assure that the node functionality does terminate and does not
directly communicate with other actors omitting the \SysteMoC{} channels.

After prohibiting any form of communication by the node functionality we,
instead introduce firing rules which is a finite state machine which determines
the communication behavior of an actor. However some MoCs, e.g. KPN, need
a Turing complete control of their communication behavior. To
accomodate this, we again allow the node functionality to indirectly
influence the communication behavior via a conflict transition
created by the branch operation. Clearly this is undesirable for more
constrainted MoCs. Therefore, we have to distinguish firing rules into
different categories which allow or disallow such possibilities. We
distinguish firing rules into these categories by the operations we
support for constructing them. These operations are provided by the
node interface which is a base class of the actor. Therefore the
type of firing rules possible for an actor is determined by the
node interface type from which the actor is derived.

%The following subset of the requirements enumerated in Section~\ref{revision-of-mocs}
%determines the node interface of the corresponding MoCs:

The set of operations available for each node interface type
build a hierarchy of decreasing execution capabilities and
correspondingly increasing analysis capabilities.
The choice node interface is the most powerful in this hierarchy.
Next is the transact node interface, and finally the last powerful is the
fixed transact node interface. This can also be clearly seen
by observing the operations available to node interface types.
Less powerful node interface types provide a strict subset of
the operations available on higher levels in the hierarchy.
How these execution and analysis capabilities map to some transformative
MoCs has been presented in Section~\ref{revision-of-mocs}.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{NodeInterfaceHierarchy.\graphicPostfix}\\
\caption{\label{node-interface-hierarchy}Node interface hierarchy as UML}
\end{figure}

The hierarchy of the node interface types is transformed into
a C++ inheritance hierarchy which can be seen in Figure~\ref{node-interface-hierarchy}.
The node interface types are mapped to C++ class types as follows:
(i) The choice node interface is represented by the \code{hscd\_choice\_node} class.
(ii) The transact node interface is represented by the \code{hscd\_transact\_node} class.
(iii) The fixed transact node interface is represented by the \code{hscd\_fixed\_transact\_node} class.
Operations which are no longer available for node interface types
at lower levels inthe hierarchy are disabled by declaring them to be private.

%\begin{enumerate}
%\item Choice Node
%  \begin{itemize}
%  \item  A communication method which implements Hoare's 'general choice' operator \cite{csphoare:1985}.
%  \end  {itemize}
%\item Transact Node
%  \begin{itemize}
%  \item A communication method to read from and write to ports.
%  \item Assurance that the arrival sequence of tokens at
%        their ports cannot be determined.
%  \end  {itemize}
%\item Fixed Transact Node
%  \begin{itemize}
%  \item A communication method to read from and write to ports.
%  \item Assurance that the arrival sequence of tokens at
%        their ports cannot be determined.
%  \item Assurance that consumption and production rates cannot
%        be altered once set
%  \end  {itemize}
%\end{enumerate}
%
%\begin{enumerate}
%\item CSP
%  \begin{itemize}
%  \item  \code{choice( a(1) $\arrowvert$ b(2) )}
%
%    This communication operation gets a list of actor ports (e.g. $a$, $b$) which
%    are parameterized with the number of tokens that must be communicated
%    over the port. The operations communicates over that actor port which is first ready
%    for communication. If no port is ready for communication the operation blocks until
%    at least one port is ready. Should more than one actor port be ready for
%    communication at the same instance one of them is chosen nondeterministically.
%  \end  {itemize}
%\item KPN
%  \begin{itemize}
%  \item \code{transact( a(1) \& b(2) )}
%
%    This communication operation gets a list of actor ports (e.g. $a$, $b$) which
%    are parameterized with the number of tokens that must be communicated
%    over the port. The operations blocks until all requested tokens on the ports
%    have been communicated.
%  \end  {itemize}
%\item SDF
%  \begin{itemize}
%  \item \code{transact(), hscd\_fixed\_transact\_node( ..., a(1) \& b(2) )}
%
%    Actors are C++ classes which are derived of their node interface class.
%    The consumption and production rates for SDF Actors must be fixed, therefore
%    the node interface of a SDF-Actor is parameterized with the consumption and production
%    rates of the SDF-Actor (See actor constructor in Figure~\ref{example-multiply-actor} for an
%    example of fixed consumption and production rates). The communication operation \code{transact} is
%    therefore missing the port list which is available to KPN nodes.
%  \end  {itemize}
%\end{enumerate}

%(See Table~\ref{node-interface-c++} for mapping of the node interface types to their
%corresponding C++ class types).
%To partially remedy these problems we introduced the node interface aspect
%which determines what communication methods are available to an actor.

%\begin{table}
%\centering
%\begin{tabular}{|l|l|}
%\hline
% Node interface & \SysteMoC{} node interface type \\
%\hline \hline
% Choice Node          & \code{hscd\_choice\_node} \\
% Transact Node        & \code{hscd\_transact\_node} \\
% Fixed Transact Node  & \code{hscd\_fixed\_transact\_node} \\
%\hline
%\end{tabular}
%\caption{\label{node-interface-c++}Node interfaces represented as \SysteMoC{} classes}
%\end{table}

\subsection{Network Graph Type}

To complete an executable specification in \SysteMoC{}, beside
the information about the actors, additionally information about the connections
of the actors with each other is needed. This information is stored
in the network graph of the executable specification, which can
be categorized into two different network graph types as defined in
Subsection~\ref{network-graph}.

The network graph is represented by a user provided C++ class, in the following called
network graph class. This class is derived from a \SysteMoC{} graph type class which
provides the methods needed to assemble the network graph in the constructor
of the network graph class. Once the constructor has finished the network graph must
be fully assembled. No alteration at a later date is allowed.
The methods provided by the \SysteMoC{} graph type class together with runtime checks
in these methods constrain the constructed network graph to conform to the corresponding
network graph type.
Therefore, the network graph type of a network graph can be determined by looking
at the base class of the network graph class.
The network graph types are mapped to C++ class types as follows:
(i) The petri network graph is represented by the \code{hscd\_graph\_petri} class.
(ii) And the nonconflicting network graph is represented by the \code{hscd\_graph\_dataflow} class.
Of the two network graph types the nonconflicting network graph is the more constraint
one. Therefore, it is implemented by deriving from the petri network graph
and disabling by declaring private the \code{registerChan} and \code{connectChanPort}
methods which allow the creation of channels with multiple indegree and outdegree.
This hierarchy is shown in Figure~\ref{network-graph-hierarchy}.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{NetworkGraphHierarchy.\graphicPostfix}\\
\caption{\label{network-graph-hierarchy}UML inheritance hierarchy of the network graph types}
\end{figure}

To construct the network graph the following methods are available for
composition of a network graph of the desired type:

\begin{enumerate}
\item Petri network graph

  \begin{itemize}
  \item registerNode:
    This method is used to add one actor $A$ to the set of actors $\mathcal{A}$
    of the network graph.

  \item registerChan:
    This method is used to add one channel $c$ to the set of channels $C$
    of the network graph. This functions takes an optional parameter which can
    be used to specify the initial state of the new channel, which is
    for example used for the count of initial tokens of a FIFO channel.

  \item connectChanPort:
    This method adds one edge $e \in C \times \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}} \times C$
    between channels and actor ports to the network graph.

  \item connectInterfacePorts
    This method adds one edge $e \in P_{i} \times \mathcal{A}_{P_{i}} \cup \mathcal{A}_{P_{o}} \times P_{o}$
    between actor ports and uplevel ports to the network graph.

  \end{itemize}

\item Dataflow network graph

  \begin{itemize}
  \item registerNode: Same method as defined for petri network graphs.
  
  \item connectInterfacePorts: Same method as defined for petri network graphs.
  
  \item connectNodePorts:
    This method is a shortcut for adding one channel and
    connecting two actor ports via this channel. Only channels
    which are connected to a dedicated output actor port and
    a dedicated input actor port can be realized with it.
    This method takes an optional parameter which fulfils
    the same function as the parameter for method registerChan.
  
  \end{itemize}

\end{enumerate}

%\begin{table}[h]
%\centering
%\begin{tabular}{|l|l|}
%\hline
% Network graph type   & \SysteMoC{} graph type class \\
%\hline \hline
% Petri Choice Node    & \code{hscd\_graph\_petri} \\
% Transact Node        & \code{hscd\_graph\_sdf} \\
%\hline
%\end{tabular}
%\caption{\label{network-graph-c++}Network graph types represented as \SysteMoC{} classes}
%\end{table}

\subsection{Channel Kind}

SystemC is an actor-oriented design language, i.e., it supports the concept
of actors and channels. The channel kind aspect of the \SysteMoC{}
framework can cleanly be implemented as a base class of a channel in SystemC.
The channel kind determines the communication semantics of a channel but
makes no assumptions about the data type of the tokens.
The channel type is a template parameterized
with the data type for the tokens and derived from the channel kind.
Identifying the channel kind with a base class instead of a template enables
easier type signature checks of C++ for the enforcement of a particular
channel kind of a channel instance.

Further differences between \SysteMoC{} channels and SystemC channels are the
absence of user callable methods for communicating on the \SysteMoC{} channels.
Providing those communication methods on the channels would contradict the separation
of node interface and channel kind. The mapping of channel kind to corresponding C++
class types is as follows:
(i) The fifo channel kind is represented by the \code{hscd\_fifo\_kind} class.
(ii) And rendezvous channel kind is represented by the \code{hscd\_rendezvous\_kind} class.

%\begin{table}
%\centering
%\begin{tabular}{|l|l|}
%\hline
% Channel kind & \SysteMoC{} type \\
%\hline \hline
% FIFO         & \code{hscd\_fifo\_kind} \\
% Rendezvous   & \code{hscd\_rendezvous\_kind} \\
%\hline
%\end{tabular}
%\caption{\label{channel-kind-c++}Channel kinds represented as \SysteMoC{} classes}
%\end{table}

\subsection{Constraint Set Composition for MoCs}

In Section~\ref{revision-of-mocs} we have demonstrated how
to map the requirements of some MoCs to the aspects presented
in Section~\ref{actor-oriented-design}. Furthermore, the analysis
requirement of these MoCs translate into certain constraints
on the aspects presented before. These constraints are
used to distinguish an aspect into aspect types. Therefore
for each MoC presented in Section~\ref{revision-of-mocs}
we have a set of aspect types, called \emph{constraint set}.
Predefined constraint sets supported by \SysteMoC{} are
shown in Table~\ref{constraintset-composition}.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
 Channel kind & Node interface & Network graph type & Constraint set \\
\hline \hline
 Fifo         & Fixed Transact node & Dataflow network graph & SDF constraint set \\
 Fifo         & Transact node       & Dataflow network graph & Dataflow constraint set \\
%% Fifo         & Choice node         & Dataflow network graph & FIFO CSP constraint set \\
 Rendezvous   & Choice node         & Dataflow network graph & CSP constraint set \\
\hline
\end{tabular}
\caption{\label{constraintset-composition}
  Composition of constraint set out of channel kind type, node interface type
  and network graph type}
\end{table}

The aspect types in the constraint set are node interface,
channel kind and network graph. The node interface and
and channel kind are represented as \SysteMoC{} classes in
SystemC, the network graph is represented as
a C++ template in \SysteMoC{}. Parameterizing this template
with the channel kind and node interface (As shown in
table~\ref{constraintset-c++}) leads to a C++
type which represents the constraint set in \SysteMoC{}.

\begin{table}[h]
\centering
\begin{tabular}{|l|p{6cm}|l|}
\hline
 Constraint set & Composition in C++ & \SysteMoC{} constraint set type \\
\hline \hline
 SDF constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_fixed\_transact\_node, hscd\_fifo\_kind$>$} &
  \code{hscd\_sdf\_constraintset} \\
\hline
 Dataflow constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_transact\_node, hscd\_fifo\_kind$>$} &
  \code{hscd\_df\_constraintset} \\
\hline
 CSP constraint set &
  \code{hscd\_graph\_sdf$<$ hscd\_choice\_node, hscd\_rendezvous\_kind$>$} &
  \code{hscd\_csp\_constraintset} \\
\hline
\end{tabular}
\caption{\label{constraintset-c++}Constraint sets represented as \SysteMoC{}
  classes and their composition in C++}
\end{table}

The executable specification with a certain constraint set is
represented by a user provided C++ class. An example
is shown in Figure~\ref{example-sdf-constraintset}, which is
derived from the selected \SysteMoC{} constraint set type and by
user provided C++ classes representing the actors of the specification.
These actors are derived from a \SysteMoC{} node interface type which
meet the requirements of the selected constraint set. The network graph
is assembled in the constructor of the top class by using the
operators provided by the \SysteMoC{} network graph type.
Each actor registered with the \code{registerNode} method must implement
the parameterized node interface type of the constraint set or an even
less capable node interface type, which is enforced by the type signature
of the registerNode method and the node interface hierarchy.
Each registered channel must be of the parameterized channel kind,
enforcement is obtained by the type signature of the
the registerChan and connectNodePorts methods.

\begin{figure}[h]
\centering
\begin{verbatim}
class m_top2: public hscd_sdf_constraintset {
  public:
    hscd_port_in<int>  in1;
    hscd_port_in<int>  in2;
    hscd_port_out<int> out;
    
    m_top2()
      : hscd_sdf_constraintset()
    {
      m_adder<int>    &adder =
        registerNode(new m_adder<int>("adder"));
      m_multiply<int> &mult  =
        registerNode(new m_multiply<int>("multiply"));
      
      connectInterfacePorts( in1, adder.in1 );
      connectInterfacePorts( in2, mult.in1 );
      connectNodePorts( adder.out, mult.in2 );
      connectNodePorts( mult.out2, adder.in2,
        hscd_fifo<int>() << 13 /* Start marking */ );
      connectInterfacePorts( out, mult.out1 );
    }
};
\end{verbatim}
\caption{\label{example-sdf-constraintset}Example of a network graph for the SDF-Actor in the \SysteMoC{} framework}
\end{figure}

%determine the MoC of a SystemC model additionally to the information
%required about the actors of the model information is required about the
%type of the network graph (See Subsection~\ref{network-graph} for defined graph types).

%The MoC is represented as an actor which is derived from the \code{hscd\_structure}
%template parameterized with the node interface and the channel kind. This actor can only
%instantiate sub actors of a predetermined kind and connect their ports with a  predetermined
%kind of channel.

%%The MoC is now determined by the composition of the two aspects node interface
%%and channel kind as following:
%%
%%\begin{tabular}{|c||c|c|c|}
%%\hline
%% Channel kind & \multicolumn{3}{c|}{ Node interface } \\
%%\hline
%%              & Choice Node         & Transact Node      & Fixed Transact Node \\
%%\hline \hline
%% Fifo         & No well known name  & KPN                & SDF \\
%%\hline
%% Rendezvous   & CSP                 & No well known name & No well known name \\
%%\hline
%%\end{tabular}

\section{Examples of MoC in SystemC with SysteMoC}\label{systemoc-examples}

\subsection{The dining philosophers problem}

\begin{figure}
\centering
\begin{verbatim}
enum dp_forkreq_ty { FORK_TAKE, FORK_DROP };

class dp_fork
  : public hscd_choice_node {
public:
  hscd_port_in<dp_forkreq_ty> l_forkreq;
  hscd_port_in<dp_forkreq_ty> r_forkreq;
private:
  void l_forkreq_take() { assert(l_forkreq[0] == FORK_TAKE);
    std::cout << "Fork " << name() << " taken by left philosopher !" << std::endl; }
  void l_forkreq_drop() { assert(l_forkreq[0] == FORK_DROP);
    std::cout << "Fork " << name() << " droped by left philosopher !" << std::endl; }
  void r_forkreq_take() { assert(r_forkreq[0] == FORK_TAKE);
    std::cout << "Fork " << name() << " taken by right philosopher !" << std::endl; }
  void r_forkreq_drop() { assert(r_forkreq[0] == FORK_DROP);
    std::cout << "Fork " << name() << " droped by right philosopher !" << std::endl; }
  
  static
  hscd_firing_state fireRules() const {
    hscd_firing_state start =
      choice( l_forkreq >> call(l_forkreq_take,
                choice( l_forkreq >> call(l_forkreq_drop, &start) ) ) |
              r_forkreq >> call(r_forkreq_take,
                choice( r_forkreq >> call(r_forkreq_drop, &start) ) )
            );
    return start;
  }
public:
  dp_fork( sc_module_name name )
    : hscd_choice_node(name, fireRules() ) {}
};
\end{verbatim}
\caption{\label{dining-philosophers-fork-systemoc}
  Example of the fork implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}


\begin{figure}
\centering
\begin{verbatim}
class dp_footman
  : public hscd_choice_node {
public:
  hscd_port_in<void> sitreq_0;
  hscd_port_in<void> sitreq_1;
  hscd_port_in<void> standreq_0;
  hscd_port_in<void> standreq_1;
private:
  void philosopher0_sitdown() {
    std::cout << "Seat " << name() << " taken by philosopher 0 !" << std::endl; }
  void philosopher0_standup() {
    std::cout << "Seat " << name() << " vacated by philosopher 0 !" << std::endl; }
  void philosopher1_sitdown() {
    std::cout << "Seat " << name() << " taken by philosopher 1 !" << std::endl; }
  void philosopher1_standup() {
    std::cout << "Seat " << name() << " vacated by philosopher 1 !" << std::endl; }
  
  static
  hscd_firing_state fireRules() const {
    hscd_firing_state start =
      choice( sitreq_0 >> call(philosopher0_sitdown,
                choice( standreq_0 >> call(philosopher0_standup, &start ) ) ) |
              sitreq_1 >> call(philosopher1_sitdown,
                choice( standreq_1 >> call(philosopher1_standup, &start ) ) )
            );
    return start;
  }
public:
  dp_footman( sc_module_name name )
    : hscd_choice_node(name, fireRules() ) {}
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example of the footman implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}


\begin{figure}
\centering
\begin{verbatim}
class dp_philosopher
  : public hscd_choice_node {
public:
  hscd_port_out<dp_forkreq_ty> l_forkreq;
  hscd_port_out<dp_forkreq_ty> r_forkreq;
  hscd_port_out<void>          sitreq;
  hscd_port_out<void>          standreq;
private:
  void nothing() {}
  
  void eat() {
    std::cout << "Philosopher " << name() << " eating !" << std::endl;
    wait( sc_time(3,SC_NS) );
    l_forkreq[0] = r_forkreq[0] = FORK_DROP;
  }
  
  void think() {
    std::cout << "Philosopher " << name() << " thinking !" << std::endl;
    wait( sc_time(100,SC_NS) );
    l_forkreq[0] = r_forkreq[0] = FORK_TAKE; 
  }
  
  static
  hscd_firing_state fireRules() const {
    hscd_firing_state start =
      choice( sitreq >> call(nothing,
        choice( l_forkreq >> call(nothing,
          choice( r_forkreq >> call(eat,
            choice( r_forkreq >> call(nothing,
              choice( l_forkreq >> call(nothing,
                choice( standreq >> call(think, &start ) )
              ) )
            ) )
          ) )
        ) )
      ) );
    return start;
  }
public:
  dp_philosopher( sc_module_name name )
    : hscd_choice_node(name, fireRules() ) {
    l_forkreq[0] = r_forkreq[0] = FORK_TAKE; 
  }
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example of the philosopher implementation for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}

\begin{figure}
\centering
\begin{verbatim}
class m_top
: public hscd_csp_constraintset {
  public:
    m_top( sc_module_name name )
      : hscd_csp_constraintset(name) {
      dp_fork        &m_fork0        = registerNode(new dp_fork("m_fork0"));
      dp_fork        &m_fork1        = registerNode(new dp_fork("m_fork1"));
      dp_philosopher &m_philosopher0 = registerNode(new dp_philosopher("m_philosopher0"));
      dp_philosopher &m_philosopher1 = registerNode(new dp_philosopher("m_philosopher1"));
      dp_footman     &m_footman      = registerNode(new dp_footman("m_footman"));
      
      connectNodePorts( m_philosopher0.l_forkreq, m_fork0.r_forkreq );
      connectNodePorts( m_philosopher1.r_forkreq, m_fork0.l_forkreq );
      
      connectNodePorts( m_philosopher1.l_forkreq, m_fork1.r_forkreq );
      connectNodePorts( m_philosopher0.r_forkreq, m_fork1.l_forkreq );
      
      connectNodePorts( m_philosopher0.sitreq,   m_footman.sitreq_0   );
      connectNodePorts( m_philosopher0.standreq, m_footman.standreq_0 );

      connectNodePorts( m_philosopher1.sitreq,   m_footman.sitreq_1   );
      connectNodePorts( m_philosopher1.standreq, m_footman.standreq_1 );
    }
};
\end{verbatim}
\caption{\label{dining-philosophers-csp-systemoc}
  Example representation of the init function for the
  dining philosophers problem in \SysteMoC{}}
\end{figure}

\section{Conclusions}\label{conclusions}

We have implemented a framework which restricts
the communication behavior of actor-oriented MoCs in such a way that the identification,
extraction, and analysis of these MoCs is permitted.
In actor-oriented design, actors only
communicate with each other via channels instead of method calls as known
in object-oriented design. In our proposed methodology, the specification is
distinguished in four different aspects,
namely \emph{node functionality}, \emph{node interface}, \emph{network graph}, and
\emph{channel kind}. Our result is a SystemC library named \SysteMoC{}.

\clearpage
\appendix
\bibliographystyle{alpha}
\bibliography{literature}

\end{document}
