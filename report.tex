\newcommand{\graphicPostfix}{pdf}

\input{format.tex}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\SysteMoC}{\mbox{\emph{SysteMoC}}}
\newcommand{\SysteMoCV}{\emph{SysteMoC 1.0}}
\newcommand{\implies}{\Longrightarrow}
\newcommand{\comment}[1]{}

\theoremheaderfont{\normalfont\sffamily\bfseries}
{\theorembodyfont{\normalfont\itshape}
  \newtheorem{sdefinition}{Definition}[section]
  \newtheorem{definition}{Definition}[subsection]
  \newtheorem{proof}{Proof}[subsection]
  \newtheorem{characteristic}{Characteristic}[subsection]
}
{\theorembodyfont{\normalfont}
  \newtheorem{sexample}{Example}[section]
  \newtheorem{example}{Example}[subsection]
}

\usepackage{multirow}
\usepackage{fancyvrb}
\usepackage{subfigure}

% Use a small font for the verbatim environment
\makeatletter  % makes '@' an ordinary character
\renewcommand{\verbatim@font}{%
  \ttfamily\small\catcode`\<=\active\catcode`\>=\active%
}
\makeatother   % makes '@' a special symbol again

% \begin{Verbatim}[fontsize=\tiny]

\hypersetup{
  pdftitle   = {Representing Models of Computation in SystemC},
  pdfsubject = {Co-Design-Report},
  pdfauthor  = {\textcopyright\ Joachim Falk, Christian Haubelt, J\"urgen Teich},
  colorlinks = true,
  linkcolor  = black,
  anchorcolor= black,
  citecolor  = black,
  filecolor  = black,
  menucolor  = black,
  pagecolor  = black,
  urlcolor   = black
}

\begin{document}
\hscdtitle{Representing Models of Computation in SystemC}
{Joachim Falk, Christian Haubelt, J\"urgen Teich}{2-2005}
\clearpage
\tableofcontents
\clearpage

\section{Introduction\label{intro}}

Due to rising design complexity, it is necessary to increase
the level of abstraction at which systems are designed.
This can be achieved by model-based design which makes extensive use
of so-called
\emph{models of computation} \cite{embsft:2002} (MoCs).
MoCs are comparable to design patterns known from the area of
software design \cite{gamma:1995}.
On the other hand, industrial embedded system design is still based on
design languages like C, C++, Java, VHDL, SystemC, and SystemVerilog which
allow unstructured communication.
Even worse, nearly all design languages are Turing
complete making analysis in general impossible.
This precludes the automatic identification of communication patterns
out of the many forms of interactions, e.g, shared variables and
various ways of message passing, between processes.
To make industry benefit from the best of both worlds,
engineers must restrict themselves to use certain subsets of
a design language. This results in a model-based design methodology
that permits automatic analysis, identification, and
and extraction of MoCs at the source code level.

\begin{figure}[t]
\centering
\resizebox{0.95\textwidth}{!}{\input{SysteMoC-Goals-fig.tex}}
\caption{\label{fig:SysteMoC-Goals}The Goal of the \SysteMoC{}-framework
  is the identification and extraction of models of computation
  from a subset of SystemC. Later the extracted MoC can be used
  in a model-based design methodology, e.g, in design space exploration
  and for code generation.
}
\end{figure}
The advantages of using a model-based approach has been shown
by many examples, e.g, in protocol design \cite{SDL-92} and
in the signal processing domain \cite{bhattacharyya,bb:2000a}.
SystemC permits the modelling of many different MoCs.
Unfortunately, there is no unique representation of a given
MoC in SystemC. Moreover, the use of unstructured communication makes
the automatic analysis of a SystemC design nearly impossible.
In this paper, we will propose a library, called \SysteMoC{},
that provides classes allowing the easy expression of MoCs
in SystemC. The overall methodology is depicted in Figure~\ref{fig:SysteMoC-Goals}.
In this paper, we focus on the \SysteMoC{}-framework.
The rest of this paper is structured as follows:
In Section~\ref{related-work}, we discuss related work. In
Section~\ref{actor-oriented-design}, we present the mathematical background for
representing MoCs in SystemC. In Section~\ref{software-architecture},
a SystemC implementation of our framework called \SysteMoC{} is
presented,
and we conclude the present paper in Section~\ref{conclusions}.

%\emph{Models of computation}
%\cite{embsft:2002}, in the following called \emph{MoCs}, are
%predefined types of communication and strategies for scheduling
%communicating tasks. Thus, MoCs are comparable to design
%patterns known from the area of software design \cite{gamma:1995}.
%Limiting the expressiveness of a MoC permits code generators to produce
%optimized code and automatic and efficient verification to check
%system properties. Examples of MoCs are \emph{Finite State Machines},
%\emph{Dataflow models}, \emph{Communicating Sequential Processes}, etc.
%
%On the other hand, industrial embedded system design is still based on
%design languages which allow unstructured communication.
%Even worse, nearly all design languages are Turing
%complete making analysis in general impossible.
%To make industry benefit from the best of both worlds,
%engineers must restrict themselves to use certain subsets of
%a design language. This results in a model-based design methodology
%that permits automatic analysis, identification, and
%and extraction of MoCs at the source code level.
%
%\begin{figure}[t]
%\centering
%\scalebox{0.5}[0.5]{\input{SysteMoC-Goals-fig.tex}}
%\caption{\label{fig:SysteMoC-Goals}The Goal of the \SysteMoC{}-framework
%  is the identification and extraction of models of computation
%  from a subset of SystemC. Later the extracted MoC can be used
%  in a model-based design methodology, e.g, in design space exploration
%  and for code generation.
%}
%\end{figure}
%
%In this paper, we will propose a library, called \SysteMoC{},
%that provides classes allowing the easy expression of MoCs
%in SystemC. The overall methodology is depicted in Figure~\ref{fig:SysteMoC-Goals}.
%In this paper, we focus on the \SysteMoC{}-framework and MoC-extraction.
%The rest of this paper is structured as follows:
%In Section~\ref{related-work}, we discuss related work. In
%Section~\ref{actor-oriented-design}, we present the mathematical background for
%representing MoCs in SystemC. In Section~\ref{software-architecture},
%a SystemC implementation of our framework called \SysteMoC{} is
%presented,
%%Finally, we will give some examples using the \SysteMoC{}
%%framework in Section~\ref{systemoc-examples}
%and we conclude the present paper in Section~\ref{conclusions}.

\section{Related Work}\label{related-work}

SystemC \cite{glms:2002} already allows to easily implement
dataflow MoCs via communicating actors and \code{sc\_fifo} channels.
However, a dataflow MoC implemented in this way is unstructured
and no possibilities exist for deriving information about its
communication behavior. The facilities for implementing MoCs in
SystemC have been extended by Herrera et al.~\cite{herrerasystemc:2004}
who have implemented a custom library of channel types like rendezvous
on top of the SystemC discrete event simulation kernel. But no
constraints have been imposed how these new channels types are used by
an actor. Consequently, no information about the communication behavior
of an actor can be derived.
Implementing these channels on top of the SystemC discrete event
simulation kernel curtails the performance of such an implementation.
Another approach has been taken by Patel et al.~\cite{fermatmoc:2004}
which have extended SystemC itself with different simulation kernels
for \emph{Communicating Sequential Processes} and \emph{Finite State Machine MoCs}
to improve simulation efficiency. Moreover,
they have implemented hierarchical composition of MoCs following
the approach of \hbox{Ptolemy II}. \hbox{Ptolemy II} \cite{ptolemyII} is a simulation
framework for MoCs implemented in Java. Its aim is the exploration of
different MoCs and the semantic of hierarchical composition of these MoC
with each other. Other work on MoCs can be found in \cite{ZERTT99a} and
\cite{STZETG00}.

In contrast to the approaches discussed above, our methodology restricts
the communication behavior in such a way that the identification,
extraction, and analysis of different MoCs is permitted. That way
our work is partially related to the new SystemC TLM standartd \cite{SystemC-TLM05}.
But in our approach we go one step further by restricting the behavior
of an actor, too.

\section{The Tagged Signal Model}\label{lee-tsm}

We use Lee's \emph{tagged signal model} introduced in \cite{Lee98} to
distinguish MoCs and use it as starting point for our further
discussions. Before we can review the tagged signal model some mathematical
notations are needed.

Let $\{x_1,x_2\}$ denote a set and $[y_1,y_2,y_3,\ldots]$ denote a set
with total order $y_1 \le y_2 \le y_3 \le \ldots$, e.g., $\{x_1,x_2\} = \{x_2,x_1\}$ but
$[y_1,y_2] \ne [y_2,y_1]$ and $\{x_1,x_1\} = \{x_1\}$ but $[ y_1, y_2, y_1, y_3]$
is a \emph{illformed totally ordered set because} it does not define a total order,
as $y_1 \le y_2 \wedge y_2 \le y_1$ but $y_1 \ne y_2$.

Let $\mathbb{Z} = [\ldots,-2,-1,0,1,2,\ldots]$ denote the set of integers,
$\mathbb{N} = [1,2,3,\ldots]$ the set of natural numbers,
$\mathbb{N}^\infty = [1,2,3,\ldots\infty]$ the set of natural numbers including infinity,
%$\mathbb{Z}^- = [\ldots,-3,-2,-1]$ the set of negative integers,
$\mathbb{Z}^+_0 = [0,1,2,3,\ldots]$ the set of nonnegative integers,
$\mathbb{Z}^{+\infty}_0 = [0,1,2,3,\ldots\infty]$ the set of nonnegative integers including infinity,
%$\mathbb{Z}^-_0 = [\ldots,-3,-2,-1,0]$ the set of nonpositive integers,
and $\mathbb{N}_n = [1,2,3,\ldots,n] \subseteq \mathbb{N}^\infty$ the counting set from one to $n$
(Note that $\mathbb{N}_0 = \emptyset$).

A totally ordered set $X$ is called \emph{two-sided discrete}
if it is \emph{order isomorphic} to a subset of the integers $Z_X \subseteq \mathbb{Z}$,
%and let $\Sigma(X): Z_X \to X$ denote this order isomorphism,
i.e., $\exists{\Sigma(X): Z_X \to X, \Sigma(X)\textrm{ is a \emph{bijection}}}:
 \forall{i,j \in Z_X}: i \le j \iff \Sigma(X)(i) \le \Sigma(X)(j)$.
Intuitively this means, any two elements
$x_1, x_2 \in X$ have only a finite number of other elements between them.

A totally ordered set $X$ is called \emph{one-sided discrete} or \emph{discrete}
if it is \emph{order isomorphic} to a subset of the natural numbers $\mathbb{N}_{|X|}$
and let $\Sigma(X): \mathbb{N}_{|X|} \to X$ denote this order isomorphism,
i.e., $\exists{\Sigma(X): \mathbb{N}_{|X|} \to X, \Sigma(X)\textrm{ is a \emph{bijection}}}:
 \forall{i,j \in \mathbb{N}_{|X|}}: i \le j \iff \Sigma(X)(i) \le \Sigma(X)(j)$.
Intuitively this means,
any two elements $x_1, x_2 \in X$ have only a finite number of other elements
between them and there exists a least element $x_{least}, \forall{x \in X}: x_{least} \le x$.
For example, given the discrete set $X = ['A', 'B', 'C']$ then
$\Sigma(X)(1) = 'A'$,  $\Sigma(X)(2) = 'B'$, and $\Sigma(X)(3) = 'C'$.

Let $X^* = \bigcup_{N \in \mathbb{Z}^+_0} X^N$ denote the set of all
\emph{tuples} of $X$ also called \emph{finite sequences} of $X$ and
$X^{**} = \bigcup_{N \in \mathbb{Z}^{+\infty}_0} X^N$ denote the set of all
finite and infinite \emph{sequences} of $X$. A sequence
$\mathbf{x} = (x_1,x_2,\ldots,x_n) \in X^n, n \in \mathbb{Z}^{+\infty}_0$
can also be thought of as a function $\mathbf{x} : \mathbb{N}_n \to X$.
For example, given the sequence $X = ('A', 'B', 'A', 'C')$ then
$X(1) = 'A'$,  $X(2) = 'B'$, $X(3) = 'A'$, and $X(4) = 'C'$.
Note that a function is also a relation and a relation is also a set, e.g
$\mathbf{x} : \mathbb{N}_n \to X \equiv \{ (i,x_i) \mid x_i = \mathbf{x}(i), i \in \mathbb{N}_n \}$.
Note also that the $\Sigma$ function converts a discrete set to a sequence,
e.g., $\Sigma([1,2,3]) = (1,2,3)$.

\subsection{Events and Signals}

Lee's \emph{tagged signal model} consist of concurrent \emph{processes} which
can only communicate with each other via \emph{signals}.
Before defining a signal, the notion of an event must be introduced first.
Given a partially or totally ordered set of tags $T$ and a set of values $V$:
\begin{definition}\label{tsm-event}
An \emph{event} $e$ is a  tag-value pair, i.e., $e = (t,v) \in T \times V$.
\end{definition}
Events are often called \emph{tokens} which represent the basic communication units.
Tags are used to model time, precedence relationships, synchronization points, or
other key properties of MoCs. The odering of the tags induces ordering of events, i.e.,
given $e_1 = (t_1,v_1)$ and $e_2 = (t_2,v_2)$ then $e_1 < e_2 \iff t_1 < t_2$.
Two Events $e_1$, $e_2$ are called \emph{synchronous} if they contain
the same tag, i.e., $e_1 = (t,v_1)$ and $e_2 = (t,v_2)$. Otherwise they
are called \emph{asynchronous}.

Values represent data which can be manipulated by computations.
For some MoCs the set of values contains the special symbol \emph{bottom} ($\bot$)
which denotes the absence of a value.

A \emph{signal} can be thought of as a subset of the \emph{set of all events} $T \times V$ or as
an element of the \emph{set of all signals} $S$ which is the powerset $S = 2^{T \times V}$.
\begin{definition}\label{tsm-signal}
A \emph{signal} $s$ is defined as a set of events, i.e., $s \subseteq T \times V$.
\end{definition}

A \emph{functional signal} or \emph{proper signal} is a signal $s$ where each tag is unique in $s$,
i.e., $e_1 = (t,v_1) \in s$ and $e_2 = (t,v_2) \in s \implies v_1 = v_2$.
A functional signal can also be thought of as a (possibly partial) function 
from its set of tags to its set of values, i.e, $s: T \to V$.
Intuitively, if tags represent time a functional signal is a signal which has
at most one value at each instance of time. For example, 
given the functional signal $s = \{(t_1,'A'),(t_2,'B'),(t_3,'C')\}$ then
$s(t_1) = 'A'$, $s(t_2) = 'B'$, and $s(t_3) = 'C'$.
Furthermore, $T(s) \subseteq T$ denotes the set of tags in the signal $s$,
i.e., $T(s) = \{t \mid (t,v) \in s\}$. A \emph{discrete signal} is a functional
signal $s$ which has a discrete set of tags $T(s)$.

The $\Sigma$ function can be generalized to discrete signals.
Each discrete signal $s \subseteq T \times V$ has a corresponding \emph{sequence} $\Sigma(s) \in V^{**}$,
where the value $v = \Sigma(s)(i)$ on position $i$ is defined to be the value
of the $i$-th event in the signal $s$, i.e.,  $\Sigma : S \to V^{**}, \Sigma(s) = \{(i,v) \mid (\Sigma(T(s))(i),v) \in s\}$.
For example, given the discrete signal $s = [(t_1,'A'),(t_2,'B'),(t_3,'C')]$ then
$\Sigma(s) = ('A','B','C')$. Note that a sequence $\mathbf{v} \in V^{**}$ is also a discrete signal with tags
$T(\mathbf{v}) = \mathbb{N}_{|\mathbf{v}|}$.

Two signals $s_1$ and $s_2$ are called \emph{sequence equivalent} if they
have the same corresponding sequence, i.e., $\Sigma(s_1) = \Sigma(s_2)$.
Two signals $s_1$ and $s_2$ are called \emph{synchronous} if they contain
the same set of tags, i.e., $T(s_1) = T(s_2)$. Otherwise they are
called \emph{asynchronous}.
Hence, if two signals are synchronous each event in one
signal has a corresponding synchronous event in the other signal and vice versa.
See also Figure~\ref{fig:example-synchronous-signals} for an
example of synchronous and asynchronous signals.

\begin{figure}
\centering
\input{example-synchronous-signals-fig.tex}
\caption{\label{fig:example-synchronous-signals}Example of thress signals
  $s_1$, $s_2$, and $s_3$ where only the two signals $\{s_1,s_2\}$ are synchronous.
  All other subsets of two signals ($\{s_1,s_3\}$ and $\{s_2,s_3\}$) are asynchronous.}
\end{figure}

A tuple of $N \in \mathbb{N}$ signals is denoted $\mathbf{s} = (s_1, s_2, \dots, s_N)$ and the
set of all $N$-tuples of signals will be denoted $S^N$.
The \emph{empty signal} is denoted by $\lambda$. This
signal does not have any events, i.e., $\lambda = \emptyset$. A \emph{tuple
of empty signals} is denoted by $\Lambda$.

The $\Sigma$ function can trivially be extended to tupples of signals
$(s_1,s_2,\ldots,s_N) = \mathbf{s} \in S^N$ by pointwise extension,
i.e., $\Sigma : S^N \to (V^{**})^N, \Sigma(\mathbf{s}) = (\mathbf{v}_1, \mathbf{v}_2,\ldots,\mathbf{v}_N)$,
where $\mathbf{v}_i = \Sigma(s_i), i \in \mathbb{N}_N$.

% The position of a signal in its tuple is equivalent to its name. To
% achieve the equivalent of renaming or hiding signals, the position of
% signals in a tuple must be changed or the signal must be drop from the tuple.
% This is done by applying the \emph{projection} function to a tuple.
\begin{definition}\label{tsm-projection}
A \emph{projection} $\pi{}_I: S^N \to S^M$ is a function which discards and reorders signals according
to the discrete set of indices $I$ in a $N$-tuple of signals
to form a new $M$-tuple of signals, where $M \le N$. In other words, given $\mathbf{s} = (s_1,\ldots,s_N) \in S^N$
and $I = [i_1,\ldots,i_M] \subseteq \mathbb{N}_N$
then $\pi{}_I(\mathbf{s}) = (s_{i_1}, \ldots, s_{i_M})$.
A projection $\pi{}_I$ can be generalized to subsets $\mathbf{P}$ of $S^N$,
i.e., $\pi{}_I(\mathbf{P}) = \{\pi{}_I(\mathbf{s}) \mid \mathbf{s} \in \mathbf{P}\}$.
\end{definition}

As example consider the tuple of signals $\mathbf{s} = (s_1,s_2,s_3,s_4,s_5)$, and the discrete set
$I=[5,4,2,1]$ then the projection is given as $\pi{}_I(\mathbf{s}) = (s_5,s_4,s_2,s_1)$.

\subsection{Processes}

After defining signals, we are able to review the definition of processes \cite{Lee98}.
Later, we will use processes to transform signals.
Processes are described as sets of possible behaviors, where
a \emph{behavior} is a tuple of signals:
\begin{definition}\label{tsm-process}
A process $\mathbf{P}$ is a subset of $S^N$, i.e., $\mathbf{P} \subseteq S^N$.
\end{definition}
Each element $\mathbf{s} \in \mathbf{P}$ of the process $\mathbf{P}$ is
called a \emph{behavior} of the process $\mathbf{P}$. A particular tuple
of signals $\mathbf{s} \in S^N$ is said to \emph{satisfy} the process,
if it is one of its behaviors, i.e., $\mathbf{s} \in \mathbf{P}$.
A process $\mathbf{P}$ is called \emph{synchronous} if
every pair of signals in the behaviour of the process is synchronous, i.e.,
$\forall{\mathbf{s} \in \mathbf{P} \subseteq S^N, i_1, i_2 \in \mathbb{N}_N}:
T(\pi{}_{[i_1]}(\mathbf{s})) = T(\pi{}_{[i_2]}(\mathbf{s}))$.

\begin{definition}\label{tsm-connection}
A \emph{connection process} $\mathbf{C}_I \subseteq S^N$ is a
process where two (or more) of the signals in the $N$-tuple are
constrained to be identical. In other words, given $I \subseteq \mathbb{N}_N$
then $\mathbf{C}_I = \{\mathbf{s} \mid \mathbf{s} \in S^N \wedge \forall{i_1, i_2 \in I}: \pi{}_{[i_1]}(\mathbf{s}) = \pi{}_{[i_2]}(\mathbf{s})\}$.
\end{definition}

If the two signals $s_i$ and $s_{i'}$ in a connection process $\mathbf{C}_{\{i,i'\}}$ are
associated with the same process, e.g., as seen in Figure~\ref{fig:example-self-loop},
then the connection is called a self-loop.

\begin{figure}[htb]
\centering
\input{example-self-loop-fig.tex}
\caption{A process $\mathbf{P}$ with self-loop $\mathbf{C}_{\{2,3\}}$.
         The signals $s_2$ and $s_3$ are constrained to be identical in
         $\mathbf{C}_{\{2,3\}}$.\label{fig:example-self-loop}}
\end{figure}

Two processes $\mathbf{P_1}$ and $\mathbf{P_2}$ can be composed into
a new \emph{composite process} $\mathbf{Q}$, where
each behavior of the composite process is a behavior of its
component processes. Thus, composition can be defined as set intersection of
its component processes, i.e., $\mathbf{Q} = \mathbf{P_1} \cap \mathbf{P_2}$.
However, care has to be taken before forming such an intersection.
Each process to be composed must be defined as a subset of the same
set of signals.
Cross product and projection are syntactic operations
used to transform the processes to achieve this goal. They play no
semantic role in composition.

\begin{figure}[htb]
\centering
\input{example-tsm-composition-fig.tex}
\caption{Composition of two processes $\mathbf{P}_1$, $\mathbf{P}_2$,
         and the connection process $\mathbf{C}_{\{2,5\}}$ between them
         into a new process $\mathbf{Q}' \ni (s'_1,s'_2,s'_3,s'_4)$.
         \label{fig:example-tsm-composition}}
\end{figure}

\begin{example}
Two processes $\mathbf{P}_1$, $\mathbf{P}_2$, and a connection process
$\mathbf{C}_{\{2,5\}}$ will be composed into a new process $\mathbf{Q}'$ according to
Figure~\ref{fig:example-tsm-composition}. However, the processes are
not defined as subsets of the same set of signals
($(s_1,s_2,s_3) \in \mathbf{P}_1$ and $(s_4,s_5,s_6) \in \mathbf{P}_2$).
Thus, both processes will be augmented with the missing signals
($(s_1,s_2,s_3,s_4,s_5,s_6) \in \mathbf{P}'_1 = \mathbf{P}_1 \times S^3$ and
 $(s_1,s_2,s_3,s_4,s_5,s_6) \in \mathbf{P}'_2 = S^3 \times \mathbf{P}_2$).
Afterwards both processes and the connection process can be intersected to form
the new process ($\mathbf{Q} = \mathbf{P}'_1 \cap \mathbf{P}'_2 \cap \mathbf{C}_{\{2,5\}}$).
Finally a projection is used to eliminate signals which are no longer
visible outside of the composite process ($\mathbf{Q}' = \pi{}_{[1,4,3,6]}(\mathbf{Q})$).
Further examples about composition are presented in \cite{Lee98}.
\end{example}

Many processes have a concept of \emph{inputs}. The set of behaviors
a process can show, is constrained by its inputs.
% An input are events or signals which are specified by an external
% constraint and which must therefore be contained in every behaviour
% of a process coupled with this input.
\begin{definition}\label{tsm-input}
An \emph{input} to a process $\mathbf{P}$ is an externally
imposed contraint $\mathbf{I} \subset S^N$ such that
$\mathbf{I} \cap \mathbf{P}$ is the set of acceptable behaviors.
\end{definition}
An input can assert the presence of a certain event $e = (t,v)$ in a signal,
e.g., $\mathbf{I} = \{\mathbf{s} \mid \mathbf{s} \in S^N \wedge e \in \pi{}_{[1]}(\mathbf{s}) \}$.
But generally, an input defines a whole signal or set of signals.
Signals which are entirely defined externally are called \emph{input signals},
e.g., given $\mathbf{I} = \{\mathbf{s} \mid \mathbf{s} \in S^N \wedge s_i = \pi{}_{[1]}(\mathbf{s})\}$ and
$\mathbf{s} = (s_1, s_2)$ then $s_1$ is the input signal which
is constrained to be $s_i$ by the input $\mathbf{I}$.


\begin{example}
For example, given the following process
\label{ex:example-with-process-1}
\begin{displaymath}
\begin{array}{rll}
  \mathbf{P} = \{ & (\emptyset,\emptyset), (\{(1,0),(2,1)\},\{(2,1)\}), (\{(1,1),(2,0)\},\{(1,0)\})&\\
                  & (\{(2,0)\},\emptyset), (\{(1,0)\},\emptyset), (\{(1,1),(2,1)\},\{(1,0),(2,0)\})&\\
                  & (\{(2,1)\},\{(2,0)\}), (\{(1,0),(2,0)\},\emptyset), (\{(1,1)\},\{(1,0)\}) &\} \subset S^2\\
\end{array}
\end{displaymath}
and the input $\mathbf{I} = \{\mathbf{s} \mid  \mathbf{s} \in S^2 \wedge \{(1,0),(2,1)\} = \pi{}_{[1]}(\mathbf{s})\}$
which constrains the first signal of a process to be $\{(1,0),(2,1)\}$ then
the resulting acceptable behaviors of the process $\mathbf{P}$ after being
constrained by $\mathbf{I}$ are as follows:
\begin{displaymath}
  \mathbf{I} \cap \mathbf{P} = \{\mathbf{s} \mid \mathbf{s} \in \mathbf{P} \wedge \{(1,0),(2,1)\} = \pi{}_{[1]}(\mathbf{s})\} =
                               \{(\{(1,0),(2,1)\},\{(2,1)\})\}\\
\end{displaymath}
In other words, if the input is $0$ and $1$ at times $1$ and $2$ respectively,
then the output will be $1$ at time $2$.
\end{example}

%Some characteristics of processes can only be determined in combination with
%its set of possible inputs $\mathbf{B} \subseteq 2^{S^N}$.
%One such characteristic is the \emph{determinancy} of a process.
A process $\mathbf{P}$ is called \emph{determinate} with respect
to its set of possible inputs $\mathbf{B} \subseteq 2^{S^N}$, if after being
constrained by its inputs, it consists of exactly one or exactly
no behaviors for each input $\mathbf{I} \in \mathbf{B}$,
i.e., $\forall{\mathbf{I} \in \mathbf{B}}: |\mathbf{P} \cap \mathbf{I}| \le 1$.
Otherwise the process is called \emph{nondeterminate} with respect
to its set of possible inputs. A process without inputs is called
\emph{determinate} if it consists of exactly one or exactly
no behaviors, i.e., $|\mathbf{P}| \le 1$.

\begin{example}
The process $\mathbf{P}$ given in Example~\ref{ex:example-with-process-1}
is determinate with respect to its set of possible inputs 
$\mathbf{B}_1 = \{ \{\mathbf{s} \mid \mathbf{s} \in S^2 \wedge s_i = \pi{}_{[2]}(\mathbf{s})\} \mid
                  s_i \in \{\{(2,0)\},\{(2,1)\},\{(1,0),(2,0)\}\} \}$
but nondeterminate with respect to its set of possible inputs 
$\mathbf{B}_2 = \{ \{\mathbf{s} \mid \mathbf{s} \in S^2 \wedge s_i = \pi{}_{[2]}(\mathbf{s})\} \mid
                  s_i \in \{\{(1,0)\},\{(2,1)\},\{(1,0),(2,0)\}\} \}$,
because $\mathbf{P} \cap \{\mathbf{s} \mid \mathbf{s} \in S^2 \wedge \{(1,0)\} = \pi{}_{[2]}(\mathbf{s})\} =
\{(\{(1,1),(2,0)\},\{(1,0)\}),(\{(1,1)\},\{(1,0)\})\}$.
\end{example}

A process $\mathbf{P}$ is called \emph{sequence determinate} with respect
to its set of possible inputs $\mathbf{B} \subseteq 2^{S^N}\!\!$, if after being
constrained by its inputs, its behaviors are all sequence equivalent
for each input $\mathbf{I} \in \mathbf{B}$,
i.e., $\forall{\mathbf{I} \in \mathbf{B}, \mathbf{s}_1, \mathbf{s}_2 \in \mathbf{P} \cap \mathbf{I}}: \Sigma(\mathbf{s}_1) = \Sigma(\mathbf{s}_2)$.
A process without inputs is called
\emph{sequence determinate} if its behaviors are all sequence equivalent
i.e., $\forall{\mathbf{s}_1, \mathbf{s}_2 \in \mathbf{P}}: \Sigma(\mathbf{s}_1) = \Sigma(\mathbf{s}_2)$.


\begin{example}
For example, given the following processes
\begin{displaymath}
\begin{array}{rll}
  \mathbf{P}_1 = \{ & ([(1.5,'A'),(1.6,'B')]),([(-3.14,'A'),(16,'B')]) & \} \subseteq S^1\\
  \mathbf{P}_2 = \{ & ([(1.5,'A'),(1.6,'C')]),([(-3.14,'A'),(16,'B')]) & \} \subseteq S^1\\
  \mathbf{P}_3 = \{ & ([(1.5,'B'),(1.6,'A')]),([(-3.14,'A'),(16,'B')]) & \} \subseteq S^1\\
\end{array}
\end{displaymath}
then the process $\mathbf{P}_1$ is sequence determinate, whereas the
processes $\mathbf{P}_2$ and $\mathbf{P}_3$ are not sequence determinate.
\end{example}

So far, a process contains no information which of the signals in its behaviors are
input signals and which are output signals. A \emph{input/output partition}
divides the signals in a behavior of a process into input signals and output signals.
\begin{definition}\label{tsm-input-output-partition}
A \emph{input/output partition} $(I,O) \in \left( 2^{\mathbb{N}_N} \right)^2$
of a process $\mathbf{P} \subseteq S^N$ is a pair of discrete sets,
where $I \cap O = \emptyset$ and $|I \cup O| = N$. The signals in
a behaviour on indeces in $I$ are input signals and the
signals on indeces in $O$ are output signals.
\end{definition}
A Process $\mathbf{P} \subseteq S^N$ is called \emph{functional} with
respect to a input/output partition $(I,O)$ if for each pair of
behaviors of the process where the input signals are equal,
the output signals must be equal as well,
i.e., $\forall{\mathbf{s_1} \in \mathbf{P}, \mathbf{s_2} \in \mathbf{P}}:
\pi{}_I(\mathbf{s_1}) = \pi{}_I(\mathbf{s_2}) \implies
\pi{}_O(\mathbf{s_1}) = \pi{}_O(\mathbf{s_2})$.
Otherwise a process is called \emph{nonfunctional} with respect to a
input/output partition.

\begin{example}
The process given in Example~\ref{ex:example-with-process-1}
is functional with respect to the input/output partition $(I,O) = ([1],[2])$
but nonfunctional for partition $(I,O) = ([2],[1])$. Whereas a connection process
$\mathbf{C}_{\{1,2\}} \subseteq S^2$ is functional for both
input/output partitions $(I,O) = ([1],[2])$ and $(I,O) = ([2],[1])$.
This is due to the constraints imposed on the two signals.
\end{example}

A Process $\mathbf{P} \subseteq S^N$ is called \emph{sequence functional} with
respect to a input/output partition $(I,O)$ if for each pair of
behaviors of the process where the input signals are sequence equivalent,
the output signals must be sequence equivalent as well,
i.e., $\forall{\mathbf{s_1} \in \mathbf{P}, \mathbf{s_2} \in \mathbf{P}}:
\Sigma(\pi{}_I(\mathbf{s_1})) = \Sigma(\pi{}_I(\mathbf{s_2})) \implies
\Sigma(\pi{}_O(\mathbf{s_1})) = \Sigma(\pi{}_O(\mathbf{s_2}))$.

\subsection{Models of Computation}

After defining processes, we are able to review the definitions of some MoCs.

\subsubsection*{Sequential Process}
A \emph{sequential process} is a process $\mathbf{P}$ with a self loop $\mathbf{C}_{\{i,i'\}}$
(As for example shown in Figure~\ref{fig:example-self-loop} on page~\pageref{fig:example-self-loop}) in which
the tags $T(s_i) = T(s_{i'})$ of the connected signals $s_i = s_{i'}$ are totally ordered.
This can be interpreted as the well known \emph{Von Neumann model of computation}, where the
events $e = (t,v) \in s_i$ correspond to the state $v$ of the process $\mathbf{P}$ at a certain
instance of time $t$ and the signal $s_i$ corresponds to the history of states which
have occured during the execution of the process $\mathbf{P}$.
%Below, we will show several ways to construct untimed concurrent systems by composing sequential systems.

\subsubsection*{Communicating Sequential Processes}

\begin{figure}[htb]
\centering
\input{example-csp-tsm-fig.tex}
\caption{Two sequential processes $\mathbf{P}_1$ and $\mathbf{P}_2$
         and a connection $\mathbf{C}_{\{3,4\}}$ used for rendezvous
         communication between these two processes. \label{fig:example-csp-tsm}}
\end{figure}

\emph{Communicating Sequential Processes} is a MoC introduced by Hoare
\cite{csphoare:1985} which consists of sequential processes which communicate
via so-called \emph{rendezvous channels}. Rendezvous means that a sequential
process $\mathbf{P}_1$
reaches a particular state $v_i, (t_i,v_i) \in s_1$ in its program execution
at which point it waits till another sequential processes $\mathbf{P}_2$
reaches a corresponding state $v_j, (t_j,v_j) \in s_6$. If both processes
have reached their rendezvous states they proceed in their execution.

This behavior can be represented in the tagged signal model as shown in
Figure~\ref{fig:example-csp-tsm} where both processes $\mathbf{P}_1$ and
$\mathbf{P}_2$ are modelled as sequential processes by their self loops
$\mathbf{C}_{\{1,2\}}$ and $\mathbf{C}_{\{5,6\}}$. The additional connection
$\mathbf{C}_{\{3,4\}}$ between these two processes is used to capture the
rendezvous behavior by requiring an event $e_r = (v_r,t_r) \in s_3$ for
each pair of states $v_i, (t_i,v_i) \in s_1$ and $v_j, (t_j,v_j) \in s_6$
where the two processes must have a rendezvous.

% Note that CSP and CCS are neither synchronous
% nor even timed. Events directly modeling a rendezvous are synchronous, but
% events that are not associated with rendezvous have only a partial ordering
% relationship with each other. Indeed, this partial ordering is one of the most
% interesting properties of these models of computation, particularly when there
% are more than two processes. In some such models of computation, a process can
% reach a state where it will rendezvous with one of several other processes
% (this sort of behavior is supported, for example, by the  select  statement in
% Ada). In this case, a composition of such processes is often nondeterminate.

\subsubsection*{Kahn Process Network}

\emph{Kahn Process Network} is a MoC introduced by Kahn \cite{kahn:1974}
which consists of processes which communicate with each other via
unidirectional unbounded FIFO \emph{channels} with a  single reader and
a single writer. The FIFO property implies that each signal $s$ in any
behavior $\mathbf{s}$ of any Kahn process in the Kahn Process Network
is discrete. But the set of all tags $T$ is in general only partially ordered.

Before formally defining a Kahn Process, we first need a partial order on
the set $V^{**}$. A set with an associated partial order is called a
\emph{poset}. Let $\sqsubseteq$ called \emph{prefix order} denote the
associated partial order on the set $V^{**}$ of all finite and infinite sequences of $V$.
And let $\mathbf{v}_1 \sqsubseteq \mathbf{v}_2$ denote that
$\mathbf{v}_1$ is a prefix of the sequence $\mathbf{v}_2$, i.e.,
$\mathbf{v}_1 \sqsubseteq \mathbf{v}_2 \iff \forall{n \in T(\mathbf{v}_1)}: \mathbf{v}_1(n) = \mathbf{v}_2(n)$.

An \emph{upper bound} of a subset $X \subseteq V^{**}$ is an element
$\mathbf{v} \in V^{**}$ where every sequence $\mathbf{x}$ in $X$ is a
prefix of $\mathbf{v}$, i.e., $\forall{\mathbf{x} \in X}: \mathbf{x} \sqsubseteq \mathbf{v}$.
A \emph{least upper bound} of a subset $X \subseteq V^{**}$, written $\sqcup X$,
is an upper bound which is a prefix of every other upper bound of $X$.
A \emph{lower bound} and \emph{greatest lower bound} of $X \subseteq V^{**}$,
written $\sqcap X$, are defined respectively.

A \emph{chain} in a poset $X$ is a totally ordered subset of $X$. A
\emph{bottom element} of a poset $X$, if it exists, is an element of the
poset which is also a greatest lower bound of the whole poset $\sqcap X \in X$.
A \emph{complete partial order} is a poset $X$ with a bottom element
in which every chain $Y \subseteq X$ has a least upper bound
$\sqcup Y$. The set $V^{**}$ of all finite and infinite sequences of $V$
is a complete partial order with bottom element $\lambda$, the
empty sequence.

This definitions can be trivially generalized to tupples of sequences
$\upsilon \in (V^{**})^N$, i.e., $\upsilon_1 \sqsubseteq \upsilon_2 \iff
\forall{n \in \mathbb{N}_N}: \upsilon_1(n) \sqsubseteq \upsilon_2(n)$.
With this generalization the set $(V^{**})^N$ of all $N$-tupples of finite and
infinite sequences of $V$ is also a complete partial order with
bottom element $\Lambda = (\lambda, \lambda, \ldots, \lambda)$, the $N$-tupple
of empty sequences $\lambda$.

A function $F: (V^{**})^N \to (V^{**})^M$ is \emph{monotonic} if
adding additional elements to the input sequence tupple $\upsilon_{in} \in (V^{**})^N$
results in additional elements on the output sequence tupple
$\upsilon_{out} = F(\upsilon_{in}) \in (V^{**})^M$,i.e.,
$\forall{\upsilon_{in_1}, \upsilon_{in_2} \in (V^{**})^N}:
\upsilon_{in_1} \sqsubseteq \upsilon_{in_2} \implies F(\upsilon_{in_1}) \sqsubseteq F(\upsilon_{in_2})$.
This can be considered as a untimed notion of causality
where the additional elements to the input sequence correspond
to input tokens and the additional elements on the output sequence
are the tokens produced from the consumption of these input tokens.

A function $F: (V^{**})^N \to (V^{**})^M$ is \emph{continuous} if
for every chain $Y$ in $(V^{**})^N$, $F(Y)$ has a least upper bound
$\sqcup F(Y)$ which is equal to the function $F$ applied to the
upper bound $\sqcup Y$ of the chain $Y$,
i.e., $\forall{Y \subseteq (V^{**})^N, Y\textrm{ is a chain}}: F(\sqcup Y) = \sqcup F(Y)$.
Where $F : 2^{\left( (V^{**})^N \right)} \to 2^{\left( (V^{**})^M \right)}$
is the pointwise extension of $F : (V^{**})^N \to (V^{**})^M$, i.e.,
$F(Y) = \{ F(\upsilon) \mid \upsilon \in Y\}$. Note that
every continuous function is also monotonic but the reverse
is not necessarily true.

Formally a Kahn Process is a  continuous function $F: (V^{**})^N \to (V^{**})^M$
\cite{kahn:1974,stark87concurrent:1987}.
The corresponing process in the tagged signal model is defined by
$\mathbf{P} = \{ \mathbf{s} \mid \mathbf{s} \in S^{N+M},
  \Sigma(\pi{}_{[N+1,N+2,\ldots,N+M]}(\mathbf{s})) =
  F(\Sigma(\pi{}_{[1,2,\ldots,N]}(\mathbf{s}))) \}$.
However the causality represented by the monotonicity of the
Kahn Process must be converted to ordering constraints
between events of different signals of the process $\mathbf{P}$.

For example, let $\mathbf{P} \ni (s_1,s_2)$ be a Kahn Process
represented in the tagged signal model
which reads two input tokens before generating an output token and
let $s_1$ be the input signal and $s_2$ be the output signal then
$\forall{i_1 \in \mathbb{N}_{|s_1|}, i_2 \in \mathbb{N}_{|s_2|}}: i_1 \le 2 \cdot i_2 \implies \Sigma(T(s_1))(i_1) \le \Sigma(T(s_2))(i_2)$.


%Fortunately, this means in practice
%that the function is also \emph{continuous} since practical monotonic
%processes are invariably continuous, at least in the context
%of Kahn process networks \cite{LeeDenotialDF:1997}.
%The read and write actions by a Kahn process are translated into
%ordering constraints on events between different signals of the process.

\section{Actor-Oriented Design}\label{actor-oriented-design}

Instead of a monolithic approach for representing an executable specification
of an embedded system as done using many design languages,
we will use a refinement of \emph{actor-oriented} design.
In actor-oriented design, \emph{actors} only
communicate with each other via \emph{channels} instead of method calls as known
in object-oriented design.

In an actor-oriented design \cite{agha97abstracting:1997}, a model of computation defines
\cite{embsft:2002} the interaction policy between actors.
Actors are objects which execute concurrently. An actor $A$ can only
communicate with the environment (other actors) through its
\emph{actor input and output ports} $A.I$ and $A.O$ respectively.
The actor ports are connected with each other via a communication
infrastructure. This infrastructure is separated into \emph{network graph} and
\emph{channel kind}.

%In our proposed methodology, the specification is more
%detailed than in actor-oriented design in a way that an actor is divided into
%its \emph{node functionality} and its \emph{firing rules}. The
%type of firing rules an actor can show is dependent on its \emph{node interface}.

% The data values, which are communicated over the channels
% are abstracted. Thus, these data are called \emph{tokens} regardless
% of their type or value.

%However, these definition is not sufficient for distinguishing MoCs.
%The communication infrastructure used by actors must be considered as well.

\begin{sdefinition}\label{network-graph}
A network graph is a directed bipartite graph $G_N=(\mathcal{A},C,E)$ containing
a set of actors $\mathcal{A}$, a set of channels $C$, and a set of
directed edges $E \subseteq (C \times \mathcal{P}_I)
\cup (\mathcal{P}_O \times C)$, where
$\mathcal{P}_I = \bigcup{}_{A \in \mathcal{A}} A.I$ and
$\mathcal{P}_O = \bigcup{}_{A \in \mathcal{A}} A.O$
are the sets of actor input and output ports of all actors in the network graph
respectively. Each actor $A \in \mathcal{A}$ can only communicate with other
actors through its dedicated actor input ports $A.I$ and actor output ports $A.O$.
Furthermore, the set of all actor input and actor output ports of all actors in
the network graph is given by $\mathcal{P} = \mathcal{P}_I \cup \mathcal{P}_O$.
\end{sdefinition}

%  However the network graph defined above is still too general. A more
%  constrained form called \emph{nonconflicting network graph} can be
%  defined which still satisfies the requirements for the MoCs presented
%  in this paper. An example of a nonconflicting network graph is shown
%  in Figure~\ref{fig:ng-moc}.
%
%\begin{definition}\label{noconflicting-network-graph}
%  A \emph{nonconflicting network graph} is constrained such that exactly
%  one edge is incident to each actor port and the indegree and outdegree
%  of each channel in the graph is exactly one,
%  i.e., $\forall{p \in \mathcal{P}}: |((\{p\} \times C) \cup (C \times \{p\})) \cap E| = 1$ and
%  $\forall{c \in C}: |(\{c\} \times \mathcal{P}_I) \cap E| = 1 \wedge
%                     |(\mathcal{P}_O \times \{c\}) \cap E| = 1$.
%\end{definition}

The \emph{channel kind} defines the communication semantics of a channel.
Since the communication semantics are not influenced by the
data type communicated, the actual \emph{type} of a communication
channel is derived from the channel kind by parameterizing it with
the actual data type. Examples for channel kinds are
FIFO channels and a rendezvous channels. Channels are used to
transport data values in form of so-called \emph{tokens}.

\begin{figure}[t]
\centering
%\includegraphics[scale=1]{fig:ng-moc.\graphicPostfix}\\
\resizebox{1.0\textwidth}{!}{\input{ng-moc-fig.tex}}
\caption{\label{fig:ng-moc}Example of a \emph{network graph} which belongs
to a model of two instances of an approximation square root algorithm.}
\end{figure}

The network graph shown in Figure~\ref{fig:ng-moc} consists
of two instances of an approximation square root algorithm. Note that the
network graph is symmetric as the actors $A_1$ - $A_6$ and $A'_1$ - $A'_6$
appear in an identical configuration. Each of these subgraphs implements
one instance of the approximation algorithm. The input values for this algorithm
are created in the source actor $A_1$. The input values are transported via
channel $c_1$ to the SqrLoop actor $A_2$ which implements the error bound checking
of the approximation algorithm. If the error bound is not satisfied the input
value will be send to actor $A_3$ via channel $c_2$. This will eventually result in
a new better approximated square root value in channel $c_5$. This iteration repeats
until the error bound is satisfied. When this happens, the approximated
square root value will be sent via channel $c_6$ to actor $A_5$. This actor
will forward the result to one of the two Print actors $A_6$ or $A'_6$
whichever is ready first.

In actor-oriented design the node functionality and the firing rules
are combined into one opaque block, which can in general not be analyzed.
The information in this block would help to reason about communication
patterns, to produce optimized code and to check system properties.
In our methodology, the actor concept is still used,
but we distinguish two different aspects of an actor called
\emph{node functionality} and \emph{firing rules}.

\begin{sdefinition}\label{actor}
An actor is a tuple $A=(\mathcal{F},\mathcal{R},I,O)$ containing
a \emph{node functionality} $\mathcal{F}$, \emph{firing rules} $\mathcal{R}$,
a set of \emph{actor input ports} $I$, and a set of \emph{actor output ports} $O$.
\end{sdefinition}

The  \emph{node functionality} ($A.\mathcal{F}$) is responsible for
transforming the data values which reside inside tokens. The node functionality
will still be regarded as an opaque block. Thus, we do not try to analyze it.

\begin{sdefinition}\label{node-functionality}
  The \emph{node functionality} of an actor $A$ is a tuple $A.\mathcal{F} = (F,Q,q_1)$
  containing a set of \emph{functions} $F$, a set of \emph{functionality states} $Q$
  (possibly infinite), and an \emph{initial functionality state} $q_1$.
\end{sdefinition}

The functions $f \in F$ of the node functionality map a fixed number of
input values $(v_{i1},v_{i2},\ldots,v_{iN}) = \mathbf{v}_i \in V^N$
and a functionality state $q_i \in Q$ to a fixed number of output values
$(v_{o1},v_{o2},\ldots,v_{oM}) = \mathbf{v}_o \in V^M$ and a new
functionality state $q_{i+1} \in Q$, i.e.,  $f: V^N \times Q \to V^M \times Q$.
The input and output values are provided by the firing rules,
as discussed next. For example, the node functionality of the Divide actor
$A_3$ ($A'_3$) in Figure~\ref{fig:ng-moc} is described by $\mathcal{F} = (F,Q,q_1)$,
$F = \{\textrm{divide}\}$, $Q= \{\bot\}$, $q_1 = \bot$, and $\textrm{divide}(\mathbf{v}_i,q) = ((v_{i1}/v_{i2}),q)$.

%\comment{
The input values $v_{i1}, v_{i2}, \ldots$ are provided by the firing rules,
as discussed next, which receive these values from the channels connected to the actor input ports.
The output values $v_{o1}, v_{o2}, \ldots$ produced by the execution of
the node functionality are later written to the actor output ports by
the firing rules. The communication of input and output values between the
node functionality and the firing rules happens via temporary buffers in
the actor ports.
The functions in the node functionality can be implemented by any
programming language. % (E.g. C++ in case of the \SysteMoC{} framework, See Figure~\ref{systemoc-divide-actor})
But the user must guarantee that the functions
(i) terminate and (ii) do not communicate directly with other actors
by avoiding their actor ports.
%}

The second part of an actor $A$ which determines its communication
behavior is called \emph{firing rules} ($A.\mathcal{R}$). The firing rules
determine for each actor port the number of tokens to be receive or to be sent
until the associated node functionality can be invoked.
The firing rules are encoded in form of a finite state machine (FSM)
which together with the network graph and channel kind are
the input information for later analysis and code generation steps.
Some examples of firing rules are shown in Figure~\ref{fig:firing-rules}.

\begin{sdefinition}\label{firing-rules}
  The \emph{firing rules} of an actor $A$ are a 4-tuple $A.\mathcal{R} = (\mathcal{T}, Q, q_1, \delta)$
  containing a set of \emph{firing transitions} $\mathcal{T}$,  a set of \emph{firing states} $Q$,
  an \emph{initial firing state} $q_1$, and a \emph{firing transition function} $\delta: Q \to 2^\mathcal{T}$
  which maps each state $q \in Q$ to the set of transitions
  $\mathcal{T}_q = \delta(q)$.
\end{sdefinition}

An actor is \emph{blocked} in state $q$ until at least one firing transition
$\mathbf{t} \in \mathcal{T}_q$ is enabled, as discussed below. The set of enabled transitions is
given by $\mathcal{T}'_q = \{ \mathbf{t} \mid \mathbf{t} \in \mathcal{T}_q \wedge \mathbf{t} \textrm{ is enabled}\}$.
Exactly one transition $t \in \mathcal{T}'_q$ will be chosen nondeterministically
for execution. For example, if both transitions $\{\mathbf{t}_1, \mathbf{t}_2\} = \delta(S_{start})$
in the firing rules shown in Figure~\ref{fig:firing-rules-print} of the Print Actor $A_6$ from Figure~\ref{fig:ng-moc}
are enabled, one of them is executed nondeterministically.

\begin{sdefinition}\label{firing-transition}
  A \emph{firing transition} is a tuple $\mathbf{t} = (k,J)$ containing
  an \emph{activation pattern} $k$ and an \emph{interface action} $J$.
\end{sdefinition}

A transition $\mathbf{t} = (k,J)$ is enabled if its \emph{activation pattern} $k$
is enabled. The activation pattern of a transition can be seen as
a guard which checks if the transition can be executed.
If a transition $\mathbf{t}$ is enabled and 
part of the transitions $\mathcal{T}_q$ which leave the current state $q$
the transition $\mathbf{t}$ can be executed, i.e.,
$(k,J) = \mathbf{t} \in \mathcal{T}_q \wedge k\textrm{ is enabled} \implies \mathbf{t}\textrm{ can be executed}$.
If a transition $\mathbf{t} = (k,J)$ is executed, the associated
activation pattern $k$ and the \emph{interface action} $J$ are executed consecutively.
The execution of the activation pattern is responsible for the
actor communication via the actor ports. The execution of the
interface action leads to function calls in the node functionality.

\begin{sdefinition}\label{activation-pattern}
  An \emph{activation pattern} is a function
  $k: A.I \cup A.O \to \mathbb{Z}^+_0,\ k \in \mathcal{K}$
  which maps each actor port of the actor $A$ to a nonnegative integer.
\end{sdefinition}

An activation pattern is a predicate on actor ports. It encodes the number of
tokens to be sent (via actor output ports) or to be received (via actor input ports)
when the activation pattern is executed.
For example, the activation pattern $k$ of the transition $\mathbf{t}_4$
in Figure~\ref{fig:firing-rules-divide} is
expressed as $k(i_1) = k(i_2) = 1$ and $k(o_1) = 0$.
However, the specification of an activation pattern by its function
poses a great overhead. Therefore, we will use the shorthand
$k = i_1(1) \& i_2(1)$ to express the same information.

An activation pattern $k$ is enabled if for each actor input port
$p_I \in A.I$ at least $k(p_I)$ tokens can be received and for each
actor output port $p_O \in A.O$ at least $k(p_O)$ tokens can be sent.
If an activation pattern $k$ is executed it receives $k(p_I)$ tokens
via the actor input port $p_I$ and stores them in
temporary buffers in these actor input ports. For actor output ports
$p_O$, $k(p_O)$ tokens in temporary buffers of the actor
output ports are sent via these ports. These temporary buffers are
used to provide the input and output values for the node functionality.

\begin{sdefinition}\label{interface-action}
  An \emph{interface action} is a tuple $J = (f,Q_\mathrm{succ}),\ J \in \mathcal{J}$ containing
  a function $f \in A.\mathcal{F}.F$ of the node functionality $A.\mathcal{F}$
  and a set of possible successor states $Q_\mathrm{succ}$. Where the set of
  possible successor states must contain at least one element, i.e.,
  $|Q_\mathrm{succ}| \ge 1$.
\end{sdefinition}

A transition $\mathbf{t} = (k,J)$ is called a \emph{deterministic transition}
if the associated interface action $J$ has only one successor state, i.e.,
$|J.Q_\mathrm{succ}| = 1$. A transition $\mathbf{t} = (k,J)$ is called a
\emph{conflict transition} if the associated interface action $J$ has more
then one possible successor state, i.e., $|J.Q_\mathrm{succ}| > 1$.
For example the transition $\mathbf{t}_4 = (k,J)$
in Figure~\ref{fig:firing-rules-divide} with $k = i_1(1) \& i_2(1)$,
$J.f = \mathrm{divide}$, and $J.Q_\mathrm{succ} = \{S_2\}$ is deterministic.
But the transition $\mathbf{t}_3 = (k,J)$ from firing state $S_{\mathrm{start}}$
to $S_\mathrm{ok}$ or $S_\mathrm{again}$
in Figure~\ref{fig:firing-rules-sqrloop} with $k = i_1(1) \& i_2(1)$,
$J.f = \mathrm{check}$, and $J.Q_\mathrm{succ} = \{S_\mathrm{ok}, S_\mathrm{again}\}$
is conflicting.

% An example of a
% conflict transition can be seen in Figure~\ref{fig:conflict-transition}.

\begin{figure}[t]
\centering
\subfigure[Firing rules of the Print actor $A_6$ ($A'_6$) in Figure~\ref{fig:ng-moc}
constructed with the \emph{choice node interface}.] {% Prozentzeichen verhindert Leerzeichen!
\begin{minipage}[b]{0.32\textwidth}
\centering \scalebox{0.6}[0.6]{\input{firing-rules-print-fig.tex}}\label{fig:firing-rules-print}
\end{minipage}}
\subfigure[Firing rules of the SqrLoop actor $A_2$ ($A'_2$) in Figure~\ref{fig:ng-moc}
constructed with the \emph{transact node interface}.] {% Prozentzeichen verhindert Leerzeichen!
\begin{minipage}[b]{0.32\textwidth}
\centering \scalebox{0.6}[0.6]{\input{firing-rules-sqrloop-fig.tex}}\label{fig:firing-rules-sqrloop}
\end{minipage}}
\subfigure[Firing rules of the Divide actor $A_3$ ($A'_3$) in Figure~\ref{fig:ng-moc}
constructed with the \emph{fixed transact node interface}.] {% Prozentzeichen verhindert Leerzeichen!
\begin{minipage}[b]{0.32\textwidth}
\centering \scalebox{0.6}[0.6]{\input{firing-rules-divide-fig.tex}}\label{fig:firing-rules-divide}
\end{minipage}}
\caption{\label{fig:firing-rules}Example of firing rules of some actors in Figure~\ref{fig:ng-moc}.}
\end{figure}

The notion of firing rules is similar to the concepts introduced in
SPI~\cite{ZERTT99a} and an extension of the firing rules in FunState~\cite{STZETG00}
by guards for testing available space in output channels.
If a transition $\mathbf{t} = (k,J)$ is executed, the associated
activation pattern $k$ and the function $J.f$ of the node functionality
are executed consecutively. In case of a deterministic transition, the current firing
state is updated to the only successor state $q_\mathrm{succ} \in J.Q_\mathrm{succ}$.
In case of a conflict transition, the successor state actually used is
a runtime decision of the function $J.f$.

As the firing rules determine the communication behavior of an actor, we
can use the firing rules to distinguish five different operations:
(i) \emph{Branch} is an operation which maps a function $f$ of the node functionality and
a none empty set of firing state $Q_B \ne \emptyset$ to an interface action $J$,
i.e., $\textrm{Branch}: A.\mathcal{F}.F \times 2^{A.\mathcal{R}.Q} \to \mathcal{J}$.
If the resulting interface action $J$ is included into a transition
$\mathbf{t}$ it permits to create a conflict transition.
(ii) \emph{Call} is an operation which maps a node functionality $f$ of the node functionality and
a firing state $q$ to an interface action $J$,
i.e., $\textrm{Call}: A.\mathcal{F}.F \times A.\mathcal{R}.Q \to \mathcal{J}$.
If the resulting interface action $J$ is included into a
transition $\mathbf{t}$, it creates a deterministic transition.
(iii) \emph{Transition} is an operation which maps an activation pattern $k$ and
an interface action $J$ to an interface transition $\mathbf{t}$,
i.e., $\textrm{Transition}: \mathcal{K} \times \mathcal{J} \to \mathcal{T}$.
(iv) \emph{Choice} is an operation which maps a set of interface transitions $\mathcal{T}$
to a firing state $q$,
i.e., $\textrm{Choice}: 2^{\mathcal{T}} \to Q$.
The firing state created by this operation can have multiple outgoing
transitions.
(v) \emph{Transact} is an operation which maps an interface transition $T$
to a firing state $s$,
i.e., $\textrm{Transact}: \mathcal{T} \to Q$.
The firing state created by this operation has only one outgoing
transition $\mathbf{t}$.

Together with the network graph and the channel kinds used, these five operations
permit the identification of the underlying MoC. As a MoC is the basis for
analysis and efficient code generation, it is preferable that a design
language provides appropriate language elements to express these aspects.
Next, we will show how this can be done in the system design language SystemC.
For this purpose, we distinguish three separate \emph{node interface types}
by the set of operations available to them:
(i) Choice node interface provides the operations
\emph{Transition}, \emph{Choice}, \emph{Transact}, \emph{Call} and \emph{Branch}
%(See Figure~~\ref{fig:firing-rules-print})
(ii) Transact node interface provides the operations
\emph{Transition}, \emph{Transact}, \emph{Call} and \emph{Branch}
%(See Figure~~\ref{fig:firing-rules-sqrloop})
(iii) Fixed transact node interface provides only the operations
\emph{Transition} and \emph{Call}.
%(See Figure~~\ref{fig:firing-rules-divide}).

\section{Revision of Different MoCs}\label{revision-of-mocs}

The \emph{characteristics} of different MoCs can be separated into two distinct groups.
There are the \emph{execution characteristics} which must be provided by
the programming system otherwise the MoC cannot be implemented.
On the other hand, there are the \emph{analysis characteristics} which
permit the extraction of information needed for MoC-Specific analysis.

In the following subsections, different MoCs are considered and their
characteristics are determined. For each MoC these characteristics are
mapped onto the aspects presented in the previous Section.

\subsection{Communicating Sequential Processes (CSP)}
\emph{Communicating Sequential Processes} \cite{csphoare:1985}
is a MoC which consists of concurrently executing processes
which communicate via unidirectional \emph{rendezvous channels}.
As a difference to the CSP model of Hoare \cite{csphoare:1985}
which allows runtime creation of processes via parallel
composition and recursion, the CSP model considered in this report
is constraint to a fixed predetermined set of processes.
This constraint is required to allow hardware synthesis from this
model.

The following characteristics are the execution characteristics to
implement CSP behavior:

\begin{characteristic}\label{characteristic-csp-rendezvous}
  Rendezvous channel for communication
\end{characteristic}

\begin{characteristic}\label{characteristic-csp-general-choice}
  A communication method for Hoare's so-called \emph{general choice}
  
  General choice written $ce_{1} \to F_1 \Box ce_{2} \to F_2$
  is a operation defined on a set of \emph{channel expressions} $CE$ and
  a function $D: CE \to \mathcal{F}$, which maps each channel expression
  $ce \in CE$ to a function $F \in \mathcal{F}$. A channel
  expression can either send the content of a variable $v$ to
  a channel $c$ which is written $c!v$ or receive a value from
  a channel $c$ and store it in variable $v$ which is written
  $c?v$. A channel expression is ready to communicate when its
  associated channel is ready to communicate.
  The general choice operation postpones the process execution 
  until at least one channel expression $ce \in CE$
  becomes ready to communicate. The set of channel expressions
  ready to communicate is given by $CE_{ready}$.
  Exactly one channel expression $ce \in CE_{ready}$
  will be chosen nondeterministically. After
  finishing the communication for the chosen channel expression $ce$
  the process execution will continue
  with function $F_{continue} = D(ce)$.

\end{characteristic}

\begin{characteristic}\label{characteristic-csp-concurrent-processes}
  Fixed set of concurrently executing processes
  
  The CSP \emph{parallel composition} operation written $F_1 \| F_2$ executes the
  function $F_1$ and $F_2$ in parallel and terminates when both functions
  have terminated. By using recursion and parallel composition
  like $X = F_1 \| X$, CSP enables unlimited runtime creation of processes.
  Our CSP MoC only allows a fixed static number of processes. This
  leads to the constraint that only CSP programs can be represented which
  have a single init function which must not be called recursively. This init
  function creates all processes needed in the CSP program via parallel composition.
  Other functions in the CSP program must not use the parallel composition
  operation.
\end{characteristic}

%\item Sequential composition of functions
%  
%  Sequential composition written $F_1 \to F_2 \to F_3 \to \ldots$
%  is 
% $\to$ is sequential composition

In the following, a CSP program for the well known dining
philosophers problem is demonstrated. To reduce the complexity
of the example the number of philosophers has been reduced
to two. Each philosopher has only two goals in life, namely to think and
to eat. Food is provided by a bowl of spaghetti on the table and
two forks for eating. To eat, each philosopher has to take a seat
at the table and take two forks which he will not release until he
is no longer hungry. As anybody knows this can lead to a deadlock.
This deadlock can can be eliminated by a footman which will only
allow philosopher to take a seat at the table if there are more
forks than philosophers at the table (See Figure~\ref{fig:dining-philosophers}
for the processes and connection topology used in the example).
The implementation demonstrates the use of the general choice operator
in the $Footman$ and the $Fork_{x}$ which are used to react to the first
philosopher requesting something from footman or fork.

\begin{figure}[h]
\centering
\input{dining-philosophers-fig.tex}
\caption{Processes and connection topology used for the ``Dining philosophers'' CSP example}
\label{fig:dining-philosophers}
\end{figure}

\begin{displaymath}
\begin{array}{rcl}
Philosopher_{i}    & := & FootSit_{i}!sit \to ForkReqL_{i}!take \to ForkReqR_{i\oplus1}!take \to \\
                   &    & Eat \to \\
                   &    & ForkReqL_{i}!drop \to ForkReqR_{i\oplus1}!drop \to FootStand_{i}!stand \to \\
                   &        & Philosopher_{i} \\
Fork_{i}           & := & ForkReqR_{i}?req_{r} \to ForkReqR_{i}?req_{r} \to Fork_{i} \Box \\
                   &    & ForkReqL_{i}?req_{l} \to ForkReqL_{i}?req_{l} \to Fork_{i} \\
Footman                   & := & FootSit_{0}?req_{0} \to FootStand_{0}?req_{0} \to Footman \Box \\
                   &    & FootSit_{1}?req_{1} \to FootStand_{1}?req_{1} \to Footman \\
InitFunction       & := & Philosopher_{0} \| Fork_{0} \| \\
                   &    & Philosopher_{1} \| Fork_{1} \| \\
                   &    & Footman \\
\end{array}
\end{displaymath}

Where $\oplus$ is addition modulo 2 and $\to$ has higher precedence than $\Box$.

To facilitate analysis of the CSP MoC, additionally the following
analysis characteristics must be given:
\begin{characteristic}\label{characteristic-csp-communication}
  Parallel executing processes must only communicate over Point-to-Point rendezvous channels.
\end{characteristic}

The characteristics \ref{characteristic-csp-rendezvous} -
\ref{characteristic-csp-communication} of the CSP MoC are mapped in the following way
onto the aspects presented in Section~\ref{actor-oriented-design}:
(i) The rendezvous communication %(Requirement~\ref{characteristic-csp-rendezvous})
used by CSP is provided by the channel kind rendezvous. %(See~\ref{channel-kind-rendezvous})
(ii) Hoare's general choice communication operator %(Requirement~\ref{characteristic-csp-general-choice})
is provided as a operation in the choice node interface. %(See~\ref{choice-node-interface-type})
(iii) The parallel executing processes %(Requirement~\ref{characteristic-csp-concurrent-processes})
created by the init functions are mapped to the concurrently executing actors.
%% (Subsection~\ref{node-functionality} and Subsection~\ref{node-interface})
(iv) The Point-to-Point communication of CSP over rendezvous channels %(Requirement~\ref{characteristic-csp-communication})
is provided by the nonconflicting network graph %(See~\ref{noconflicting-network-graph})
and its contained rendezvous channels, which are the only means of communication in a
actor-oriented design.

\subsection{Kahn Process Network (KPN)}
\emph{Kahn Process Network} \cite{kahn:1974} is a MoC
which consists of a fixed predetermined set of
concurrently executing processes which communicate via unidirectional
unbounded \emph{FIFO channels}. The input and output of a channel
are connected to dedicated processes. The process must implement
a continuous function $F: S^m \to S^n$ regarding a prefix order on
$S^m$ and $S^n$ \cite{kahn:1974,stark87concurrent:1987}.
Where $S^m$ is a $m$-tuple of token sequences on the process input channels
and $S^n$ is a $n$-tuple on token sequences on the process output channels.
If the communication over FIFO channels is realized with blocking
reads and nonblocking writes the previous requirement is automatically
satisfied \cite{stark87concurrent:1987}. However, the next channel
selected for a FIFO read or write operation can dependent on
the data values already read and the state of the actor.

% connected to the process of the process actor input
% port a number of tokens dependent on the port and the state
% of the actor must be available.
% Two closely related
% forms of dataflow are distinguished in the literature \cite{LeeDenotialDF:1997},
% Kahn Process Networks \cite{kahn:1974}, in the following 
% called KPN, and Dennis Dataflow \cite{}, in the following
% called DDF. DDF is an extension of KPN by the notion of
% firing. To enable firing of a DDF process each channel $c \in C$
% used as input by the process must have a certain number of
% tokens 

The following execution characteristics are required to
implement the KPN MoC:

\begin{characteristic}\label{characteristic-kpn-fifo}
  An unbounded FIFO channel for communication
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-fifo-read-write}
  A communication method to read from and write to FIFOs
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-concurrent-processes}
  Fixed set of concurrently executing processes
\end{characteristic}

In the following, an example KPN program for audio coding
is demonstrated. For the audio encoding an algorithm
adapted for multimedia audio or an algorithm adapted for speech
is dynamically selected depending on the input audio stream.
The CodecSelect actor forwards the raw audio stream to the
selected audio codec and gets feedback of the codec quality
via the corresponding CodecQuality channel. If a certain
limit for the codec quality is not satisfied the CodecSelect will
switch to the other audio codec. Additionally the CodecSelect actor
signals the StreamPacketizer via the PacketizerCodecSelect channel
which EncodedAudio channel must be chosen for input data to packetize.
(See Figure~\ref{fig:media-speech-audio-coding}
for the processes and connection topology used in the example):

\begin{figure}[h]
\centering
\resizebox{1.0\textwidth}{!}{\input{media-speech-audio-coding-fig.tex}}
\caption{Processes and connection topology used for the audio encoding KPN example}
\label{fig:media-speech-audio-coding}
\end{figure}

To facilitate analysis of the KPN MoC additionally the following
characteristics must be satisfied:
\begin{characteristic}\label{characteristic-kpn-communication}
  Parallel executing processes must only communicate over Point-to-Point FIFO channels.
\end{characteristic}

\begin{characteristic}\label{characteristic-kpn-determinism}
  The process must implement a continuous function $F: S^m \to S^n$
\end{characteristic}

The characteristics \ref{characteristic-kpn-fifo} -
\ref{characteristic-kpn-determinism} of the KPN MoC are mapped in the following way
onto the aspects presented in Section~\ref{actor-oriented-design}:
(i) The FIFO communication
used by dataflow is provided by the FIFO channel kind.
(ii) The fixed set of concurrently executing processes
are mapped to the concurrently executing actors.
(iii) The Point-to-Point communication of dataflow over FIFO channels
is provided by the nonconflicting network graph
and its contained FIFO channels, which are the only means of communication in a
actor-oriented design.
(iv) Read and write operations on this FIFOs are provided by
the transact operation of the transact node interface.
(v) The requirement for a continuous function is satisfied by using the
transact operation of the transact node interface.
The transact operation consumes and produces
a determined number of tokens on the actor ports
depending on the current state of the actor.
The node functionality must be deterministic, too.
Therefore the actor implements a function regarding the
prefix order on $S^m$ and $S^n$. Because the
transact functions does not allow canceling of already
written output of actor output ports, the functions is
\emph{monotonic}. Fortunately, this means in practice
that the function is also \emph{continuous} since practical monotonic
processes are invariably continuous, at least in the context
of Kahn process networks \cite{LeeDenotialDF:1997}.

\subsection{Synchronous Dataflow (SDF)}
Synchronous Data Flow \cite{Lee87b:1987} is a more constricted form of the
KPN MoC. It has all the characteristic of the KPN MoC and additionally the
following characteristic necessary for MoC analysis.

\begin{characteristic}\label{characteristic-sdf-fixed-rates}
The consumption and production rates of the actor must be constant.
In particular they are independent from the state of the actor.
\end{characteristic}

In the following, an example of a Multiply-Accumulate-Unit for stereo signals is given
as a SDF system. The unit reads two tokens from channel $c_1$,
performs a multiplication for both tokens with a value read from channel $c_2$,
and accumulates the results in the channels $c_4$ and
$c_5$. The accumulated values are written to $c_6$ for each
token pair received on $c_1$.
In Figure~\ref{fig:sdf-mac-unit},
the constant consumption and production rates of the SDF
MoC are annotated at the actor input and output ports
respectively.

\begin{figure}[h]
\centering
\input{sdf-mac-unit-fig.tex}
\caption{Processes and connection topology used for a stereo signal MAC
  unit implemented in the SDF MoC}
\label{fig:sdf-mac-unit}
\end{figure}

The characteristics \ref{characteristic-kpn-fifo} -
\ref{characteristic-sdf-fixed-rates} of the SDF MoC are mapped in the following way
onto the aspects presented in Section~\ref{actor-oriented-design}: (i) - (iii) is identical
to the KPN MoC.
(iv) Read and write operations on the FIFOs are provided by the transact
operation of the fixed transact node interface.
(v) The constant consumption and production rates of the actor are
guaranteed by the fixed transact node interface which does
not allow the alteration of these rates once set.


\section{Software Architecture}\label{software-architecture}

Due to its high abstraction level and its capabilities in both,
hardware and software refinement, we have chosen SystemC
\cite{systemc-lrm:2003,glms:2002} as our platform for system design.
SystemC is an actor-oriented C++-based design language.
% and already allows to easily express dataflow MoCs.
In the following, we propose a library, called \SysteMoC{},
which augments SystemC with additional services as can be seen in
Figure~\ref{fig:systemc-integration} to implement
the concepts presented in the previous section. For this purpose,
\SysteMoC{} provides base classes which define the operations
to construct firing rules. This set of operations restricts
an actors communication behavior. Moreover, channel kinds like
FIFO and rendezvous, and a base class for the network graph are
provided.

%Actors in SystemC are C++ classes which are derived from the base class \code{sc\_module}.
%This analysis is made possible by dividing the actor into its
%node functionality and its node interface.
%The \SysteMoC{} framework provides the execution requirements for each MoC while
%still supporting the extraction of the information needed for analysis.
%Furthermore, the \SysteMoC{} framework provides a way for these
%actors to be connected to each other. This connections
%are provided by the \emph{network graph} and appropriate \emph{channel kinds}.

\begin{figure}[t]
\begin{center}
\scalebox{0.7}[0.7]{\input{systemc-integration--node-interface-hierarchy-fig.tex}}
\caption{\SysteMoC{} is a library built on top of the design language SystemC
which allows easy and efficient construction of well defined MoCs.
The construction is mainly based on the node interface hierarchy.}
\label{fig:systemc-integration}\label{fig:node-interface-hierarchy}
\end{center}
\end{figure}

The problem of extracting the communication behavior of an actor is caused
by the fact, that the communication methods in SystemC are all accessible
to all SystemC modules. Moreover, execution of these methods is controlled
by the Turing complete coding possibilities in the actor. To remedy these
problems, we split the actor into a \emph{node functionality} and a
\emph{firing rules} part, as discussed in Section~\ref{actor-oriented-design}.

\begin{figure}[t]
\begin{center}
\scalebox{0.7}[0.7]{\input{firing-rules-uml-fig.tex}}
\caption{Class hierarchy used for representing firing rules in \SysteMoC{}.}
\label{fig:systemoc-firing-rules-classes}
\end{center}
\end{figure}

Instead of covering the whole \SysteMoC{} library, we will concentrate
on the representation of firing rules in \SysteMoC{}.
The firing rules are mapped to the class hierarchy shown in
Figure~\ref{fig:systemoc-firing-rules-classes}. The class \code{smoc\_root\_port}
is the base class for both templates \code{smoc\_port\_in$<$T$>$} and \code{smoc\_port\_out$<$T$>$}
which represent the actor input and output ports in \SysteMoC{}, respectively.

The \code{smoc\_op\_port} class is used to represent an element of an
activation pattern, e.g., $i_2(2)$.
Instances of this class are generated by the \code{smoc\_op\_port smoc\_root\_port::operator ()( int n )}
operator of the actor ports. The activation pattern is represented by the
\code{smoc\_activation\_pattern} class. The instances of \code{smoc\_op\_port}
are combined into an activation pattern by the $\&$-operators\\
(i) \code{smoc\_activation\_pattern operator \& (smoc\_op\_port p1, smoc\_op\_port p2)} and\\
(ii) \code{smoc\_activation\_pattern operator \& (smoc\_activation\_pattern ap, smoc\_op\_port p)}\\
The C++ syntax, e.g., \code{smoc\_activation\_pattern k = i1(3)\&i2(2)\&o1(7)},
is similar to our shorthand notation for activation patterns, e.g., $k = i_1(3) \& i_2(2) \& o_1(7)$.

The firing states themselves are mapped to the \code{smoc\_firing\_state} class.
A list of firing states (\code{smoc\_state\_list}) can be created analogous
to the creation of activation patterns with the $|$-operators\\
(i) \code{smoc\_state\_list operator | (smoc\_firing\_state s1, smoc\_firing\_state s2)} and\\
(ii) \code{smoc\_state\_list operator | (smoc\_state\_list sl, smoc\_firing\_state s)}.\\
An interface action is represented by the \code{smoc\_interface\_action} class.
Instances of this class are created by the methods\\
(i) \code{template <typename T>\\
smoc\_interface\_action call(void (T::*f)(), smoc\_firing\_state s)} and\\
(ii) \code{template <typename T>\\
smoc\_interface\_action branch(smoc\_firing\_state (T::*f)(), smoc\_state\_list sl)}.

An activation pattern and an interface action are combined by the
\code{smoc\_interface\_transition smoc\_activation\_pattern::operator >> (smoc\_interface\_action)}
operator to an interface transition,
e.g., \code{smoc\_interface\_transition t = (i1(3)\&i2(2)\&o1(7)) >> call(method, s1)}.

A list of interface transitions (\code{smoc\_transition\_list}) can be created analogous
to the creation of activation patterns with the $|$-operators\\
(i)  \code{smoc\_transition\_list smoc\_interface\_transition::operator |} \\
     \code{(smoc\_interface\_transition)} and\\
(ii) \code{smoc\_transition\_list smoc\_transition\_list::operator | (smoc\_interface\_transition)}.
A firing state can be created by the methods\\
(i) \code{smoc\_firing\_state transact(smoc\_interface\_transition)} and\\
(ii) \code{smoc\_firing\_state choice(smoc\_transition\_list)}.\\

Instead of a detailed description for the still uncovered parts of the \SysteMoC{} library we
will use some example implementation of actors with \SysteMoC{} to give a broad overview
of the rest of \SysteMoC{}.
Such an example given in Figure~\ref{systemoc-divide-actor} shows the Divide actor $A_3$ in
Figure~\ref{fig:ng-moc} on Page~\pageref{fig:ng-moc}.
The firing rules are a finite state machine which determines
the communication behavior of an actor.
The node functionality is only used for algorithmic transformations of
data values and any communication with other actors not provided
by the firing rules is prohibited.
Unfortunately, this cannot be strictly enforced because it is generally
impossible to detect if the C++ code communicates with other actors
directly omitting the firing rules which should handle all communication.
Hence, we require the \SysteMoC{} user
to assure that the node functionality does terminate and does only
communicate with other actors via the firing rules.

\begin{figure}[t]
\centering
\begin{verbatim}
// node interface type is 'fixed transact node'
class Divide: public smoc_fixed_transact_node { 
  smoc_port_in<int> i1,i2; smoc_port_out<int> o1; // input port i1,i2, output port o1
  ...
  void divide()        { // A function of the node functionality
    o1[0]=               // update position 0 of the temporary buffer in o1
          i1[0]/i2[0]; } // access position 0 of the temporary buffer in i1 and i2
  ...
  Divide( sc_module_name name ): smoc_fixed_transact_node(name,
     (i1(1)&i2(1)&o1(1)) >> call(divide) /* specification of firing rules */ ) {} };
\end{verbatim}
\caption{\label{systemoc-divide-actor}Node functionality and firing rules of
the Divide actor $A_3$ ($A'_3$) in Figure~\ref{fig:ng-moc} on 
Page~\pageref{fig:ng-moc} encoded in the \SysteMoC{} framework.
As a special exception of the fixed transact node interface the FSM of
the firing rules is not explicitly given but instead only a transition
$\mathbf{t}$ without successor state,
e.g, \code{(i1(1) \& i2(1) \& o1(1)) >> call(divide)}, is provided in
the constructor. This transition $\mathbf{t}$ has the activation pattern
$i_1(1) \& i_2(1) \& o_1(1)$ and the interface action $\mathcal{J}$ with function
$\mathcal{J}.f = \mathrm{divide}$. 
The corresponding FSM which is constructed from this transition by
the fixed transact node interface can be seen in
Figure~\ref{fig:firing-rules-divide} on Page~\pageref{fig:firing-rules-divide}.
The transition $\mathbf{t}_5$ in the FSM corresponds exactly to the
transition $\mathbf{t}$ given in the constructor and the transition
$\mathbf{t}_4$ in the FSM is constructed by the fixed transact node interface
from the transition $\mathbf{t}$ by deleting all actor output ports from
the activation pattern of the transition. This transition corresponds to an
initialization phase where the inputs are acquired which are necessary
before the first outputs can be produced.}
\end{figure}

However, some MoCs, e.g., Kahn Process Networks, need a Turing complete control of their
communication behavior. One example would be the SqrLoop actor $A_2$
in Figure~\ref{fig:ng-moc} which makes an input data dependent decision,
e.g, if the approximated square root value is good enough.
To accommodate this, we again allow the node functionality to indirectly
influence the communication behavior via a conflict transition
created by the \emph{Branch} operation. An example of this is shown in
Figure~\ref{systemoc-firing-rules-sqrloop}.

\begin{figure}[t]
\centering
\begin{verbatim}
class SqrLoop: public smoc_transact_node { // node interface type is 'transact node'
  smoc_port_in<int>  i1,i2; // input  port i1, i2
  smoc_port_out<int> o1,o2; // output port o1, o2
  ...
  smoc_firing_state ok, again;
  const smoc_firing_state &check();
  ...
  smoc_firing_state fireRules() { // function for construction of the firing rules
    smoc_firing_state start = transact( (i1(1)&i2(1)) >> branch(check, ok|again));
                      ok    = transact( (o1(1)&o2(1)) >> call(NULL,start));
                      again = transact( (o1(1)&i2(1)) >> branch(check, ok|again));
    return start; }
  ...
  SqrLoop( sc_module_name name ): smoc_transact_node(name, fireRules() ) {} };
\end{verbatim}
\caption{\label{systemoc-firing-rules-sqrloop}Firing rules
of the SqrLoop actor $A_2$ ($A'_2$) in Figure~\ref{fig:ng-moc} on Page~\pageref{fig:ng-moc} encoded
in the \SysteMoC{} framework. The FSM of the firing rules which corresponds to the code in
method \code{fireRules} can be seen in
Figure~\ref{fig:firing-rules-sqrloop} on Page~\pageref{fig:firing-rules-sqrloop}.
In the \SysteMoC{} framework a firing state is represented by an
\code{smoc\_firing\_state} object,
e.g, \code{smoc\_firing\_state start} for $S_\mathrm{start}$,
\code{smoc\_firing\_state ok} for $S_\mathrm{ok}$, and
\code{smoc\_firing\_state again} for $S_\mathrm{again}$.
In this example because of the transact node interface only one outgoing transition
per firing state is allowed. These firing states are
created via transact method calls,
e.g, \code{start = transact( (i1(1) \& i2(1)) >> branch(check, ok | again) )}.
The previous code snippet creates the state $S_\mathrm{start}$ and its
outgoing conflicting transition $\mathbf{t}_3 = (k,J)$ which has an
activation pattern $k = i_1(1) \& i_2(1)$ (encoded as \code{i1(1) \& i2(1)})
and an interface action $J$ (encoded as \code{branch(check, ok | again)}).
This interface action references the $\mathrm{check} = J.f$ function of the node functionality and has
two possible successor states $J.Q_\mathrm{succ} = \{S_\mathrm{ok}, S_\mathrm{again}\}$
(encoded as \code{ok | again}).}
\end{figure}

Another case is the possibility to distinguish arrival times of tokens on
different ports, e.g., as necessary for a nondeterministic
merge actor like the Print actor $A_6$ in Figure~\ref{fig:ng-moc}.
This is implemented via the \emph{Choice} operation as shown
for example in Figure~\ref{systemoc-firing-rules-print}.

\begin{figure}[t]
\centering
\begin{verbatim}
class Print: public smoc_choice_node { // node interface type is 'choice node'
  smoc_port_in<int> i1,i2; // input  port i1, i2
  ...
  void print();
  ...
  smoc_firing_state fireRules() { // function for construction of the firing rules
    smoc_firing_state start = choice( i1(1) >> call(print,start) |
                                      i2(1) >> call(print,start) );
    return start; }
  ...
  Print( sc_module_name name )
   : smoc_choice_node(name, fireRules() ) {} };
\end{verbatim}
\caption{\label{systemoc-firing-rules-print}Firing rules
of the Print actor $A_6$ ($A'_6$) in Figure~\ref{fig:ng-moc} on Page~\pageref{fig:ng-moc}  encoded
in the \SysteMoC{} framework. The FSM of the firing rules which corresponds to the code in
method \code{fireRules} can be seen in Figure~\ref{fig:firing-rules-print}.}
\end{figure}

\comment{
Clearly this possibilities are undesirable for more
constrained MoCs. Thus, we have to distinguish firing rules into
different categories which allow or disallow such possibilities. We
distinguish firing rules by the operations we
support for constructing them. These operations are provided by the
node interface which is a base class of the actor. Therefore the
type of firing rules possible for an actor is determined by the
node interface type from which the actor is derived.
}
As can be seen from Figure~\ref{systemoc-divide-actor} to Figure~\ref{systemoc-firing-rules-print},
the restricted communication behavior of an actor is established by choosing
an appropriate base class.
In \SysteMoC{}, the set of operations available for each node interface type
are organized in a hierarchy of decreasing execution capabilities and
correspondingly increasing analysis capabilities.
%The choice node interface is the most powerful in this hierarchy.
%Next is the transact node interface, and finally the last powerful is the
%fixed transact node interface. This can also be clearly seen
%by observing the operations available to node interface types.
%Less powerful node interface types provide a strict subset of
%the operations available on higher levels in the hierarchy.
The hierarchy of the node interface types is transformed into
a C++ inheritance hierarchy which can be seen in Figure~\ref{fig:node-interface-hierarchy}
on the right hand side.
%The node interface types are mapped to C++ class types as follows:
%(i) The choice node interface is represented by the \code{smoc\_choice\_node} class.
%(ii) The transact node interface is represented by the \code{smoc\_transact\_node} class.
%(iii) The fixed transact node interface is represented by the \code{smoc\_fixed\_transact\_node} class.
Operations which are no longer available for node interface types
at lower levels in the hierarchy are disabled by declaring them to be private.

Besides the node interface, \SysteMoC{} provides operations to construct the
network graph, and define the \emph{node functionality}.
The node functionality of an actor is defined in certain member functions,
which are called by the firing rules when their requirements for input data
is fulfilled. This member functions are not allowed to call communication
operations. All required input and output data values are kept in temporary buffers
in the actor ports. These buffers are managed by the firing rules which store
new data received via actor input ports in temporary buffers in these
actor input ports and send data in temporary buffers in actor output ports
to the channels connected via these ports. For example, the node functionality
of the the Divide actor $A_3$ from Figure~\ref{fig:ng-moc} on Page~\pageref{fig:ng-moc}
can be seen in Figure~\ref{systemoc-divide-actor}.

The information about the connections of the actors is stored
in the \emph{network graph} which is represented by a user provided
C++ class, in the following called network graph class. This class is derived
from the \SysteMoC{} graph class \code{smoc\_graph}. The network graph is
assembled in the constructor of the network graph class by usage of the normal
SystemC methods. Instead of the normal SystemC channels like
\code{sc\_fifo}, \code{sc\_signal}, etc, the two \SysteMoC{} \emph{channel kinds}
\code{smoc\_fifo\_kind} and \code{smoc\_rendezvous\_kind} are available
to connect the actors to each other.
The channel kind determines the communication semantics of a channel but
makes no assumptions about the data type of the tokens.
Further differences between \SysteMoC{} channels and SystemC channels are the
absence of user callable methods for communicating on the \SysteMoC{} channels.
Providing those communication methods on the channels would contradict the separation
of node interface and channel kind.

Due to space limitations, we only sketch the extraction of the underlying
MoC from a SysteMoC description. Note that it is possible to combine
different MoCs in \SysteMoC{}. To identify the MoC,
in a (partial) \SysteMoC{} description, we must investigate the
node interface of all actors and the channel kind of connected channels.
The following table shows some actor oriented MoCs that can be constructed using
\SysteMoC.\\[5mm]

\begin{tabular}{|c||c|c|c|}
\hline
 Channel kind & \multicolumn{3}{c|}{ Node interface } \\
\hline
              & Choice Node         & Transact Node      & Fixed Transact Node \\
\hline \hline
 Fifo         & No well known name  & KPN                & SDF \\
\hline
 Rendezvous   & CSP                 & No well known name & No well known name \\
\hline
\end{tabular}

\section{Conclusions}\label{conclusions}

We have implemented a framework which restricts
the communication behavior of actors in SystemC in such a way that the identification,
extraction, and analysis of the underlying MoC is permitted.
In actor-oriented design, actors only
communicate with each other via channels instead of method calls as known
in object-oriented design. In our proposed methodology, the specification is
distinguished in four different aspects,
namely \emph{node functionality}, \emph{node interface}, \emph{network graph}, and
\emph{channel kind}. As a result, the SystemC library named \SysteMoC{}
was developed which allows model-based system design on top of the design language SystemC.
% Currently we use SysteMoC to model an industrial relevant application
% to show its benefits.

\clearpage
\appendix
\bibliographystyle{alpha}
\bibliography{literature}

\end{document}
