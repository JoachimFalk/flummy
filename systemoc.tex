%\chapter {SysteMoC V2.0 Aktorbibliothek\label{cha:systemoc}}

\chapter{SysteMoC-Idee}

{\bf FIXME: Translate into English}

Nahezu alle Anwendungen lassen sich auf Basis sog. \emph{Berechnungsmodelle} beschrieben \cite{ells:1997,ls:1998}. 
So werden Signalverarbeitungsalgorithmen oftmals mit Hilfe von \emph{Datenflussmodellen} \cite{lp:1995} beschrieben, während Protokolle oftmals durch \emph{endliche Zustandsautomaten} \cite{harel:1987} modelliert werden.
Beschränkte Berechnungsmodelle bilden die Grundlage zur effizienten Analyse und Implementierung einer Anwendung. 
SystemC \cite{sysc1,glms:2002} bietet die Möglichkeit, beliebige Berechnungsmodelle zu beschreiben. 
Hierin liegt aber auch das Problem, dass das zugrundeliegende (beschränkte) Berechnungsmodell nicht mehr erkannt werden kann.
\par
Um dieses Problem zumindest teilweise lösen zu können, wurde am Lehrstuhl für Hardware-Software-Co-Design eine Aktorbibliothek mit dem Namen \emph{SysteMoC} entwickelt. 
Diese erlaubt es, Informationen über das zugrundeliegende Berechnungsmodell zu erkennen und zu analysieren.
Im Folgenden wird zunächst die Idee der SysteMoC-Bibliothek vorgestellt, bevor auf die Verwendung dieser Bibliothek eingegangen wird. 
Schließlich wird noch beschrieben, wie es mit der SysteMoC-Bibliothek möglich ist, das Zeitverhalten zu modellieren.
Hierzu kommt das am Lehrstuhl entwickelte \emph{Virtual Processing Components} Framework, welches bereits in der vorangegangenen Studie verwendet wurde, zum Einsatz.

Eine Anwendung wird oftmals in verschiedene Module zergliedert, welche meist von den einzelnen Entwicklern noch gut zu überblicken sind.
Die eigentliche Komplexität einer Anwendung ergibt sich aber durch das Kommunikationsverhalten dieser Module miteinander.
Um diesem Phänomen zu begegnen ist eine systematische Beschreibung des Kommunikationsverhalten der Module von essentieller Bedeutung.
Zu diesem Zwecke wird die Anwendung in einzelne sog. \emph{Aktoren} zerlegt, welchen eine Kommunikation untereinander nur über sog. \emph{Kanäle} mittels \emph{Nachrichten} erlaubt ist.
Die zuvor genannten Module entsprechen dabei den Aktoren, welche noch einmal in \emph{Aktivierungsregeln} und \emph{Funktionalität} unterteilt werden.
Die Aktivierungsregeln kodieren dabei das Kommunikationsverhalten des Aktors und sind in Form eines endlichen Zustandsautomaten dargestellt.
Die Zustände dieses Zustandsautomaten werden im folgenden als \emph{Aktivierungszustände} bezeichnet.
Die Funktionalität setzt sich aus einer Menge von \emph{Aktionen} zusammen, welche die
eigentliche Datenverarbeitung durchführen und Nachrichten für die Kommunikation der Aktoren untereinander generieren.
Die Ausführung dieser Aktionen kann den internen Zustand eines Aktors, im Folgenden als \emph{Funktionalitätszustand}
bezeichnet, verändern.
Die Aktivierungszustände und die Funktionalitätszustände sind dabei zwei disjunkte Zustandsmengen, welche zusammen
die möglichen \emph{Aktorzustände} ergeben.
Durch die vorgegebenen Syntax zur Kodierung der Aktivierungsregeln ist es möglich,
die Zustandsautomaten aus den SysteMoC Aktoren zu extrahiert.
Diese extrahierten Aktivierungsregeln erlauben die Zuordnung des Aktors zu einem bestimmten Berechnungsmodell.
Des weiteren sind die hier verwendeten Prinzipien eng mit der Modellierungssprache \emph{FunState} (Functions driven by State machines) verwandt \cite{stgzet:2001}.
In \cite{strehl:2000} wurde gezeigt, wie man symbolische Techniken \cite{kropf:1999} verwenden kann, um FunState-Beschreibungen zu verifizieren und zu synthetisieren.
Die Bestimmung eines gültigen statischen Ablaufplans mit beschränktem Speicher für FunState-Beschreibungen beruht hierbei auf sog.\ \emph{regulären Zustandsmaschinen} \cite{tts:2000}.
Aufgrund der Ähn\-lich\-keiten in den Konzepten von SysteMoC und FunState können die für FunState entwickelten Methoden auf die SysteMoC übertragen werden.

\chapter{SysteMoC-Syntax}

Instead of a monolithic approach for representing an executable specification of an embedded system as done using many design languages, we will use a refinement of \emph{actor-oriented} design.
In actor-oriented design, \emph{actors} only communicate with each other via \emph{channels} instead of method calls as known
in object-oriented design.

The creation of a SysteMoC design can roughly be subdivided into two subtasks:
(i) The creation of a \emph{network graph} for the design, e.g., as displayed in Figure~\ref{fig:ng-sqrroot} for an approximative square root algorithm, and
(ii) the creation of all \emph{actor classes} needed by the design, e.g., \code{SqrLoop} in Figure~\ref{fig:actor-sqrloop}.
The network graph is composed of \emph{actor instances} of these actor classes, e.g., $A_1$ - $A_5$, which are connected via \emph{channels}.

% Der Aufbau einer Anwendung in SysteMoC lässt sich grob in zwei Teilaufgaben untergliedern: (i) Die Definition der \emph{Aktorbeschreibung} und (ii) die Instantiierung und Verknüpfung dieser Aktorbeschreibungen mittels Kanälen zu einem \emph{Netzwerkgraphen}.
% in Beispiel einer Aktorbeschreibung ist in den Abbildungen \ref{systemoc-actor-def} bis \ref{systemoc-bthchk-fsm} dargestellt.
% Diese Beschreibung wird anschließend im Netzwerkgraph des InfiniBand-HCA, dargestellt in Abbildung \ref{fig:ng-sqrroot}, für die \emph{Aktorinstanz} $A_{11}$ verwendet.

\begin{figure}[h]
\centering
%\includegraphics[scale=1]{fig:ng-sqrroot.\graphicPostfix}\\
%\resizebox{\textwidth}{!}{\input{ng-sqrroot-fig.tex}}
\input{ng-sqrroot-fig.tex}
\caption{\label{fig:ng-sqrroot}%
The \emph{network graph} displayed above implements Newton's iteration algorithm to calculate the square roots of an infinite input sequence generated by the \code{Src} actor $A_1$. The square root values are generated by Newton's iteration algorithm $A_2$ - $A_4$, and received by the \code{Sink} actor $A_5$.}
\end{figure}

The approximative square root algorithm in Figure~\ref{fig:ng-sqrroot} is stimulated by an infinite sequence of input values $V^{**}$ generated by the \code{Src} actor $A_1$.
The  These input values are transported via channel $c_1$ to the \code{SqrLoop} actor $A_2$ which implements the error bound checking of the approximation algorithm.
If the error bound is not satisfied the input value will be send to actor $A_3$ via channel $c_2$. This will eventually result in a new better approximated square root value in channel $c_5$.
This iteration repeats until the error bound is satisfied and the approximation is forwarded via the channel $c_6$ to the \code{Sink} actor $A_5$.

\section{Network graph}

In an actor-oriented design \cite{agha97abstracting:1997}, a model of computation defines
\cite{embsft:2002} the interaction policy between actors.
Actors are objects which execute concurrently. An actor $A$ can only
communicate with the environment (other actors) through its
\emph{actor input and output ports} $A.I$ and $A.O$ respectively.
The actor ports are connected with each other via a communication
infrastructure, e.g., \emph{FIFO} channels $c_1$ - $c_6$ in Figure~\ref{fig:ng-sqrroot}.

These actors and their connections to each other are encoded in a \emph{network graph}.
In SysteMoC a \emph{network graph} is represented as a C++ class derived from the base class \code{smoc\_graph}, e.g., as seen in the following example:

\begin{cexample}\label{ex:systemoc-networkgraph}%
Declaration of network graph from Figure~\ref{fig:ng-sqrroot}
\begin{verbatim}
// Declare network graph class SqrRoot
class SqrRoot: public smoc_graph {
protected:
  // Actors are C++ objects
  Src      src;     // Actor A1
  SqrLoop  sqrloop; // Actor A2
  Approx   approx;  // Actor A3
  Dup      dup;     // Actor A4
  Sink     sink;    // Actor A5
public:
  // Constructor of network graph class assembles network graph
  SqrRoot( sc_module_name name )
    : smoc_graph(name),
      src("src", 50),
      sqrloop("sqrloop"),
      approx("approx"),
      dup("dup"),
      sink("sink") {
    // The network graph is instanciated in the constructor
    // a1.o1 -> a2.i1 using FIFO standard size
    connectNodePorts(src.o1,     sqrloop.i1);
    // a2.o1 -> a3.i1 using FIFO standard size
    connectNodePorts(sqrloop.o1, approx.i1);
    // a3.o1 -> a4.i1 using FIFO size 1
    connectNodePorts(approx.o1,  dup.i1,
                     smoc_fifo<double>(1) );
    // a4.o1 -> a3.i2 using FIFO standard size and
    // an initial sequence of 2
    connectNodePorts(dup.o1,     approx.i2,
                     smoc_fifo<double>() << 2 );
    // a4.o2 -> a2.i2 using FIFO standard size
    connectNodePorts(dup.o2,     sqrloop.i2);
    // a2.o2 -> a5.i1 using FIFO standard size
    connectNodePorts(sqrloop.o2, sink.i1);
  }
};
\end{verbatim}
\end{cexample}

% Der Netzwerkgraph wird in einer von \code{smoc\_graph} abgeleiteten Klasse,
% im Folgenden als \emph{Graphenklasse} bezeichnet, zusammengesetzt.
% Die Aktoren des Netzwerkgraph, z.B. $A_{1}$ - $A_{17}$ in Abbildung \ref{fig:ng-sqrroot}
% auf Seite \pageref{fig:ng-sqrroot}, werden in dieser Klasse als Klassenvariablen
% deklariert und im Konstruktor der Graphenklasse parametrisiert und verknüpft, z.B. für die Aktoren
% $A_{10}$, $A_{11}$, $A_{12}$ und $A_{15}$ in Beispiel~\ref{ex:systemoc-networkgraph} dargestellt.

% Ausschnitt aus der Graphenklasse zur Verknüpfung der
% in Abbildung \ref{fig:ng-sqrroot} auf Seite \pageref{fig:ng-sqrroot}
% dargestellten Aktoren.
% Die Aktoren werden als Klassenvariablen deklariert, z.B. \code{mBthChk},
% und im Konstruktor parametrisiert und mittels Kanälen untereinander verbunden.
% Die Verbindungen werden hierbei mittels der \code{connectNodePorts} Funktion
% erstellt. Welche als Parameter den Ausgangsport und Eingangsport von verschiedenen
% Aktoren erhält um diese mittels eines FIFOs zu verbinden.
% Als optionales dritter Parameter der Funktion kann der FIFO mittels
% des '\code{smoc\_fifo<MsgType>(FifoSize) << InitialTokens << ...}'
% Syntaxes genauer parametrisiert werden.

%This infrastructure is separated into \emph{network graph} and \emph{channel kind}.

%In our proposed methodology, the specification is more
%detailed than in actor-oriented design in a way that an actor is divided into
%its \emph{node functionality} and its \emph{firing rules}. The
%type of firing rules an actor can show is dependent on its \emph{node interface}.

% The data values, which are communicated over the channels
% are abstracted. Thus, these data are called \emph{tokens} regardless
% of their type or value.

%However, these definition is not sufficient for distinguishing MoCs.
%The communication infrastructure used by actors must be considered as well.

The actors of the network graph, e.g., $A_1$ - $A_5$ from Figure~\ref{fig:ng-sqrroot}, are member variables.
They can be parameterized via common C++ syntax in the constructor of the \emph{network graph class}, e.g., \code{src("src", 50)}.
The connections of these actors via FIFO channels are assembled in the constructor of the network graph class, e.g., \code{connectNodePorts(src.o1, sqrloop.i1)} to connect $A_1.o_1$ to $A_2.i_1$.
The FIFO channels are created by the \code{connectNodePorts($o$, $i$[, param])} function channel which creates a FIFO channel between output port $o$ and input port $i$.
The optional parameter \code{param} is used to further parameterize the created FIFO channel, e.g., \code{smoc\_fifo<double>(1) $<<$ 2} is used to create a FIFO channel for \code{double} tokens of depth one with initial token two.
This can be condensed into the following definition:

\begin{cdefinition}[General network graph]\label{def:network-graph}
A \emph{general network graph} is a directed bipartite graph $G_N=(\mathcal{A},C,P,E)$ containing
a set of actors $\mathcal{A}$,
a set of channels $C$, 
a channel parameter function $P: C \to \mathbb{N}^{\infty} \times V^*$ which
associates with each channel $c \in C$ its size $n \in \mathbb{N}^{\infty}$ and its initial token sequence $\mathbf{v} \in V^*$,
and a set of directed edges $E \subseteq (C \times \mathcal{P}_I) \cup (\mathcal{P}_O \times C)$,
where $\mathcal{P}_I = \bigcup{}_{A \in \mathcal{A}} A.I$ and $\mathcal{P}_O = \bigcup{}_{A \in \mathcal{A}} A.O$ are the sets of \emph{all actor input ports} and \emph{all actor output ports} in the network graph respectively.
\end{cdefinition}

Each actor $A \in \mathcal{A}$ can only communicate with other
actors through its dedicated actor input ports $A.I$ and actor output ports $A.O$.
Furthermore, the set of all actor input and actor output ports of all actors in
the network graph is given by $\mathcal{P} = \mathcal{P}_I \cup \mathcal{P}_O$.
However the preceding definition still allows multiple readers and writers per FIFO channel.
Therefore we define a more constraint form of network graph called \emph{nonconflicting network graph} or \emph{network graph} for short, which allows only \emph{point to point} FIFO connections.

%  However the network graph defined above is still too general. A more
%  constrained form called \emph{nonconflicting network graph} can be
%  defined which still satisfies the requirements for the MoCs presented
%  in this paper. An example of a nonconflicting network graph is shown
%  in Figure~\ref{fig:ng-moc}.
%
\begin{cdefinition}[Nonconflicting network graph]\label{def:noconflicting-network-graph}
  A \emph{nonconflicting network graph} is constrained such that exactly
  one edge is incident to each actor port and the indegree and outdegree
  of each channel in the graph is exactly one,
  i.e., $\forall{p \in \mathcal{P}}: |((\{p\} \times C) \cup (C \times \{p\})) \cap E| = 1$ and
  $\forall{c \in C}: |(\{c\} \times \mathcal{P}_I) \cap E| = 1 \wedge
                     |(\mathcal{P}_O \times \{c\}) \cap E| = 1$.
\end{cdefinition}

% The \emph{channel kind} defines the communication semantics of a channel.
% Since the communication semantics are not influenced by the
% data type communicated, the actual \emph{type} of a communication
% channel is derived from the channel kind by parameterizing it with
% the actual data type. Examples for channel kinds are
% FIFO channels and a rendezvous channels. Channels are used to
% transport data values in form of so-called \emph{tokens}.

\section{Actor classes}

An \emph{actor} can be thought of as a object which maps sequences of token values on its input ports into sequences of token values on its output ports.
In SysteMoC each actor is represented as an instance of an \emph{actor class}, which is derived from the C++ base class \code{smoc\_actor}, e.g., as seen in the following example for the SqrLoop actor class:

\begin{cexample}\label{ex:systemoc-sqrloop-actor-def}%
Definition of the SqrLoop actor class
\begin{verbatim}
class SqrLoop
  // All actor classes must be derived
  // from the smoc_actor base class
  : public smoc_actor {
public:
  // Declaration of input and output ports
  smoc_port_in<double>  ...
private:
  // Declaration of the actor functionality
  // via member variables and member functions
  ...
  
  // Declaration of states for the firing FSM
  smoc_firing_state start;
  ...
public:
  // Constructor responsible for building the
  // firing FSM and initializing the actor
  SqrLoop(sc_module_name name)
    : smoc_actor( name, start ) {
    ...
  }
};
\end{verbatim}
\end{cexample}

Accordingly each \emph{actor instance}, in the following simply called \emph{actor}, is a C++ object of its corresponding actor class.
Each definition of an actor class can be subdivided into three parts
  (i) Declaration of the actor \emph{input ports} and \emph{output ports},
  (ii) Declaration of the actor \emph{functionality} and
  (iii) Declaration of the actor \emph{communication behavior}, encoded as \emph{firing FSM}.
This can be condensed into the following definition:

\begin{cdefinition}[Actor]\label{def:actor}
An actor is a tuple $A=(I,O,\mathcal{F},\mathcal{R})$ containing
a set of \emph{actor input ports} $I$ and \emph{actor output ports} $O$,
the \emph{actor functionality} $\mathcal{F}$ and the \emph{firing FSM} $\mathcal{R}$.
\end{cdefinition}

The three parts of an actor can also be seen in Figure~\ref{fig:actor-sqrloop}, which displays the actor defined in the Examples~\ref{ex:systemoc-sqrloop-actor-def} - \ref{ex:systemoc-sqrloop-fsm-def}.
In the following the steps to construct these three parts will be explained in detail.

\begin{figure}[h]
\centering
\resizebox{\textwidth}{!}{\input{actor-sqrloop-fig.tex}}
\caption{\label{fig:actor-sqrloop}%
Visual representation of the \code{SqrLoop} actor $A_2$ used in the network graph displayed in Figure~\ref{fig:ng-sqrroot}.
The \code{SqrLoop} actor is composed from \emph{input ports} and \emph{output ports}, its \emph{functionality}, and the \emph{firing FSM} determining the communication behavior of the actor.}
\end{figure}

\subsection{Declaration of the actor input and output ports}

An actor must only communication with other actor via its input and output ports,
as seen in Figure~\ref{fig:ng-sqrroot} where actor $A_2$ is connected via its input ports $[i_1, i_2] = A_2.I$ and output ports $[o_1, o_2] = A_2.O$
to all other actors in the network graph.
The port declaration must be in the \emph{public} part of the actor class to allow a top level to connect all these actors to each other.
An example of a port declaration can be seen in the example below.

\begin{cexample}\label{ex:systemoc-ports-def}%
Port declaration for SqrLoop actor class
\begin{verbatim}
class SqrLoop: public smoc_actor {
public:
  // Declaration of input and output ports
  smoc_port_in<double>  i1, i2;
  smoc_port_out<double> o1, o2;
private:
  ...
};
\end{verbatim}
\end{cexample}

Usage of normal \code{sc\_fifo} channels with \code{sc\_fifo\_in} and \code{sc\_fifo\_out} ports
would weaken the seperation of actor functionality and communication behavior, because the
actor functionality could easily communicate via the provided \code{read} and \code{write} functions on
these fifo ports.
Therefore the SysteMoC library provides its own input and output ports \code{smoc\_port\_in} and \code{smoc\_port\_out}.
These use the same concept of template parameters as standard port from SystemC, e.g., \code{sc\_fifo\_in}, to specify the token type
communicated over these ports, e.g., \code{smoc\_port\_in$<$double$>$} to specify a port which communicates double tokens.

\subsection{Declaration of the actor functionality}
The actor functionality is represented by member variables and member functions of the actor.
These functions manipulate the \emph{functionality state} stored in the member variables of the actor.
Some member functions of the actor are reference by the firing FSM
to calculate token values to be produced on the output ports.
These member functions are called \emph{actions}, e.g.,
\code{copyStore} in Example~\ref{ex:systemoc-functionality-def},
and can manipulate the functionality state.
Other member functions are reference by the firing FSM to decide if
transitions in the FSM are enabled an can be taken.
These member functions are called \emph{guards}, e.g.,
\code{check} in Example~\ref{ex:systemoc-functionality-def},
and must not manipulate the functionality state.
Therefore these member functions are required to be declared as \emph{const member functions}.

\begin{cexample}\label{ex:systemoc-functionality-def}%
Declaration of actor functionality
\begin{verbatim}
class SqrLoop: public smoc_actor {
public:
  ...
private:
  // Declaration of the actor functionality
  // via member variables and member functions
  double tmp_i1;
  
  // action functions triggered by the
  // FSM declared in the constructor
  void copyStore()  { o1[0] = tmp_i1 = i1[0];  }
  void copyInput()  { o1[0] = tmp_i1;          }
  void copyApprox() { o2[0] = i2[0];           }
  
  // guard  functions used by the
  // FSM declared in the constructor
  bool check() const
    { return fabs(tmp_i1-i2[0]*i2[0]) < BOUND; }
  ...
};
\end{verbatim}
\end{cexample}

%The \emph{functionality state} of an actor is stored in its member variables and
%the \emph{actor functionality} is distributed over its \emph{member functions}.
%These member function can be divided into \emph{actions}, \emph{guards} and \emph{helper functions}.
%The actions of an actor are used to calculate token values to be procduced on its output ports.
%These functions can manipulate the functionality state.
%Whereas the \emph{guards} are only used to decide if a transition in the firing FSM is enabled. 
%These functions must not manipulate the functionality state.
%Both actions and guards can use helper functions to accomplish their purpose.

\begin{cdefinition}[Actor functionality]\label{def:actor-functionality}
  The \emph{actor functionality} of an actor $A$ is a tuple $A.\mathcal{F} = (F,Q_\mathrm{func},q_{_0\mathrm{func}})$ containing
  a set of \emph{functions} $F = F_\mathrm{action} \cup F_\mathrm{guard}$ partitioned into \emph{actions} and \emph{guards},
  a set of \emph{functionality states} $Q_\mathrm{func}$ (possibly infinite), and
  an \emph{initial functionality state} $q_{_0\mathrm{func}} \in Q_\mathrm{func}$.
\end{cdefinition}
  
% The actions $f_\mathrm{action} \in F_\mathrm{action}$ of the actor functionality map action dependant number $N$ of input values $(v_1,v_2,\ldots,v_N) = \mathbf{v} \in V^N$ and the current functionality state $q_\mathrm{current} \in Q_\mathrm{func}$ to an action dependant number $M$ of output values $(w_1,w_2,\ldots,w_M) = \mathbf{w} \in V^M$ and the next functionality state $q_\mathrm{next} \in Q_\mathrm{func}$, i.e.,  $f_\mathrm{action}: V^N \times Q_\mathrm{func} \to V^M \times Q_\mathrm{func}$.

The actions $f_\mathrm{action} \in F_\mathrm{action}$ of the actor functionality map sequences of token values $\mathbf{v}_{i_1},\mathbf{v}_{i_2},\ldots,\mathbf{v}_{i_{|A.I|}} \in V^*$ on the $A.I$ actor intput ports into sequences of token values $\mathbf{v}_{o_1},\mathbf{v}_{o_2},\ldots,\mathbf{v}_{o_{|A.O|}} \in V^*$ on the $A.O$ actor output ports additionally modifying the functionality state:

\begin{equation*}
f_\mathrm{action} : V^{N_{i_1}} \times V^{N_{i_2}} \ldots \times V^{N_{i_{|A.I|}}} \times Q_\mathrm{func} \to V^{M_{o_1}} \times V^{M_{o_2}} \ldots \times V^{M_{o_{|A.O|}}} \times Q_\mathrm{func}
\end{equation*}

Whereas the number of tokens $N_i$ consumed on the input port $i$ and the number of tokens $M_o$ produced on output port $o$ depends on the action $f_\mathrm{action}$.

% The guards $f_\mathrm{guard} \in F_\mathrm{guard}$ of the actor functionality map a guard dependant number $N$ of input values $(v_1,v_2,\ldots,v_N) = \mathbf{v} \in V^N$ and the current functionality state $q_{i} \in Q_\mathrm{func}$ to a boolean value, i.e.,  $f_\mathrm{guard}: V^N \times Q_\mathrm{func} \to \{\mathrm{true},\mathrm{false}\}$.

The guards $f_\mathrm{guard} \in F_\mathrm{guard}$ of the actor functionality map sequences of token values $\mathbf{v}_{i_1},\mathbf{v}_{i_2},\ldots,\mathbf{v}_{i_{|A.I|}} \in V^*$ on the $A.I$ actor intput ports and the functionality state to a boolean value:

\begin{equation*}
f_\mathrm{guard} : V^{N_{i_1}} \times V^{N_{i_2}} \ldots \times V^{N_{i_{|A.I|}}} \times Q_\mathrm{func} \to \{\mathrm{true}, \mathrm{false}\}
\end{equation*}

Whereas $N_i$ is a guard dependent number of tokens on the input port $i$ needed for the guard decision.

The input values for the actor functionality are provided by the firing FSM, which retrieves input values from the tokens in the FIFO channels connected to the actor input ports.
Output values from actions $f_\mathrm{action}$ are used by the firing FSM to generate tokens for the FIFO channels connected to the actor output ports.

For example, the mathematical representation of Example~\ref{ex:systemoc-functionality-def} is as follows:
\begin{eqnarray*}
F_\mathrm{action}   & = & \{f_\mathtt{copyStore}, f_\mathtt{copyInput}, f_\mathtt{copyApprox}\} \\
F_\mathrm{guard}    & = & \{f_\mathtt{check}\} \\
Q_\mathrm{func}     & = & \mathbb{R} \\
q_{_0\mathrm{func}} & = & 0% \\
%f_\mathtt{copyStore}    & : & 
\end{eqnarray*}

\subsection{Declaration of the communication behavior}

Consumption and production of tokens is only triggered by transitions in the \emph{firing FSMs}, which are embedded in all actors.
Therefore the communication behavior of an actor is encoded in its firing FSM, e.g., as seen in Figure~\ref{fig:firing-rules-sqrloop}.
The states of a firing FSM are called \emph{firing states}, directed edges between these firing states are called \emph{firing transitions} or \emph{transitions} for short.
Each transition is annotated with an \emph{activation patten}, which decides if the transition can be taken, and an \emph{action} from the \emph{actor functionality} which is executed if the transition is taken.
An \emph{activation pattern} is subdivided into an \emph{input pattern} and an \emph{output pattern}.
Where input and output patterns are responsible for checking conditions on the actor input and actor output ports respectively.
This can be condensed into the following two definitions:

\begin{cdefinition}[Firing FSM]\label{def:firing-fsm}
  The \emph{firing FSM} of an actor $A$ is a tuple $A.\mathcal{R} =$ $(\mathcal{T},$ $Q_\mathrm{firing},$ $q_{_0\mathrm{firing}})$ containing
  a set of \emph{firing transitions} $\mathcal{T}$, % \subseteq Q_\mathrm{firing} \times \mathcal{K} \times A.\mathcal{F}.F_\mathrm{action} \times Q_\mathrm{firing}$,
  a set of \emph{firing states} $Q_\mathrm{firing}$ and
  an \emph{initial firing state} $q_{_0\mathrm{firing}} \in Q_\mathrm{firing}$.
\end{cdefinition}

\begin{cdefinition}[Transition]\label{firing-transition}
  A \emph{firing transition} is a tuple $\mathbf{t} = (q_\mathrm{firing}, k, f_\mathrm{action}, q'_\mathrm{firing}) \in \mathcal{T}$ containing
  the current firing state $q_\mathrm{firing} \in Q_\mathrm{firing}$
  an \emph{activation pattern} $k \in \mathcal{K}$,
  the associated \emph{action} $f_\mathrm{action} \in A.\mathcal{F}.F_\mathrm{action}$,
  and an the next firing state $q'_\mathrm{firing} \in Q_\mathrm{firing}$.
  The activation pattern $k$ is a function which decides if its transition $\mathbf{t}$
  can be taken $k(\mathbf{v}, q_\mathrm{func}) = \mathrm{true}$, or
  can not be taken $k(\mathbf{v}, q_\mathrm{func}) = \mathrm{false}$.
% or more input values are still neccessary to decide $k(\mathbf{v}, q_\mathrm{func}) = \bot$.
% Where $k$ is a function from
% the \emph{input alphabet} $\chi = (V^{**})^{|A.I|} \times \mathbb{Z}^{|A.O|}$ and the \emph{functionality state}
% $A.\mathcal{F}.Q_\mathrm{func}$ to the trinary boolean set $\{\bot, \mathrm{true}, \mathrm{false}\}$, i.e.,
% $k: \chi \times A.\mathcal{F}.Q_\mathrm{func} \to \{\bot, \mathrm{true}, \mathrm{false}\}$.
\end{cdefinition}

\begin{figure}[h]
\centering
\scalebox{1}[1]{\input{firing-rules-sqrloop-fig.tex}}
\caption{\label{fig:firing-rules-sqrloop}%
Visual representation of the \emph{firing FSM} of the \code{SqrLoop} actor $A_2$ from Figure~\ref{fig:ng-sqrroot}.
The \code{SqrLoop} actor controls the number of approximation iterations performed by Newton's square root algorithm.
}
\end{figure}

In preceding figure the firing FSM of the \code{SqrLoop} is displayed.
From the $S_\mathrm{start}$ state only the transition $\mathbf{t}_1$ can be taken, which blocks until at least one token is available on input port $i_1$ and one free space is available on output port $o_1$.
The token on $i_1$ represents the input value for the square root algorithm and is stored and forwarded by action $f_\mathtt{copyStore}$ via port $o_1$ to the approximation loop body $A_3$ - $A_4$ of newtons algorithm.

From the $S_\mathrm{loop}$ state either the transition $\mathbf{t}_2$ can be taken if the approximation satisfies the error bound \code{BOUND}, or the transition $\mathbf{t}_2$ if another approximation step is neccessary.
This termination criteria is check by the guard $f_\mathtt{check}$. % from its actor functionality $A_2.\mathcal{F}$
Furthermore both transitions $\mathbf{t}_2$ and $\mathbf{t}_3$ can only be taken if at least one approximation value is available via port $i_2$.
Also for transition $\mathbf{t}_2$ and $\mathbf{t}_3$ to be taken at least one free space must be available on output port $o_2$ and output port $o_1$ respectively.
Whereas the transition $\mathbf{t}_2$ forwards the square root approximation to the \code{Sink} actor $A_5$ and transition $\mathbf{t}_3$ forwards the input value for the square root algorithm again to the approximation loop body to calculate a refined approximation.

% Die Aktivierungsregeln werden als endliche Zustandsautomaten implementiert,
% welche im Konstruktor der Aktorklasse aufgebaut werden.
% Die Aktivierungszustände werden als Instanzen der \code{smoc\_firing\_state} Klasse deklariert,
% z.B. im obigen Quellcode der \code{start}-Aktivierungszustand.
% Von den deklarierten Aktivierungszuständen wird einer als
% Startzustand selektiert, indem er an die Basisklasse \code{smoc\_actor} übergeben wird.
% Der obig definierte Zustandsautomat,
% auch graphisch dargestellt in Abbildung \ref{fig:firing-rules-sqrloop},
% besteht aus einem Zustand \code{start} und zwei Selbstschleifen,
% den Transitionen $\mathbf{t_1}$ und $\mathbf{t_2}$.

In SysteMoC firing states are represented as instances of the \code{smoc\_firing\_state} class.
The firing FSM of an actor is assembled in the constructor of the corresponding actor class by assigning each firing state its set of leaving transitions.
In the following Example~\ref{ex:systemoc-sqrloop-fsm-def} the SysteMoC representation of the firing FSM of the \code{SqrLoop} actor $A_2$, also seen as visual representation in Figure~\ref{fig:firing-rules-sqrloop}, is given.

\begin{cexample}\label{ex:systemoc-sqrloop-fsm-def}%
Declaration of communication behavior
\begin{verbatim}
class SqrLoop: public smoc_actor {
  ...
  // Declaration of states for the firing FSM
  smoc_firing_state start, loop;
public:
  // Constructor responsible for declaring the
  // firing FSM and initializing the actor
  SqrLoop(sc_module_name name)
    : smoc_actor( name, start /* start state of firing FSM */ ) {
    // Declaration of start state consisting
    // of one leaving transition t1
    start =
      // transition t1
        // with input pattern requiring at least one token
        // in the FIFO connected to input port i1
        i1(1)                               >>
        // with output pattern requiring at least one free space
        // in the FIFO connected to output port o1
        o1(1)                               >>
        // has action SqrLoop::copyStore and next state loop
        CALL(SqrLoop::copyStore)            >> loop
      ;
    // Declaration of loop state consisting of two transitions t2 and t3
    loop  =
      // transition t2
        // with input pattern requiring at least one token
        // in the FIFO connected to input port i2 and
        // that guard SqrLoop::check be true
        (i2(1) &&  GUARD(SqrLoop::check))   >>
        // with output pattern requiring at least one free space
        // in the FIFO connected to output port o2
        o2(1)                               >>
        // has action SqrLoop::copyApprox and next state start
        CALL(SqrLoop::copyApprox)           >> start
      // transition t3
        // with input pattern requiring at least one token
        // in the FIFO connected to input port i2 and
        // that guard SqrLoop::check be false
      | (i2(1) && !GUARD(SqrLoop::check))   >>
        // with output pattern requiring at least one free space
        // in the FIFO connected to output port o1
        o1(1)                               >>
        // has action SqrLoop::copyInput and next state loop
        CALL(SqrLoop::copyInput)            >> loop
      ;
  }
};
\end{verbatim}
\end{cexample}




% (iii) Construction of the \emph{firing state machine} of the actor.
% Aktivierungsregeln, kodiert als endlicher Zustandsautomat,
% beschreiben das Kommunikationsverhalten des Aktors.
% Die Zustände dieses Zustandsautomaten werden als
% \emph{Aktivierungszustände} bezeichnet.
% Die Bedingung der Transitionen des Zustandsautomaten setzen sich
% aus logischen Verknüpfungen über den Füllstand bzw.
% die Anzahl freier Plätze in einem Kanal sowie weiteren
% Ausdrücken (z.B.\ über Datenwerte) zusammen. Die Backus-Naur-Form (\emph{BNF}) für den Aufbau des Zustandsautomaten
% ist in Abbildung \ref{syn:systemoc-fsm-bnf} und \ref{syn:systemoc-fsm-bnf-2} dargestellt. Ein konkretes
% Beispiel, der Aufbau des Zustandsautomaten für den \code{BthChk}-Aktor (Abbildung \ref{systemoc-bthchk-fsm})
% lässt sich in Abbildung \ref{fig:firing-rules-sqrloop} betrachten.

% has two input ports $i_1$ and $i_2$. 
% Der Eingangsport \code{inMStore2BthChk} ist hier als $i_1$,
% wie in Abbildung \ref{fig:ng-sqrroot} verwendet,
% die beiden Ausgangsports \code{outBthChk2RethChk} und \code{outBthChk2AethChk}
% sind als $o_1$ bzw. $o_2$ wiederzufinden.
% Die Schreibweisen $i_1(n)$ bzw. $o_1(m)$
% werden als Abkürzung für
% \code{i1.getAvailableTokens() >= n} bzw.
% \code{o1.getAvailableSpace() >= m} eingesetzt.

\begin{csyntax}\label{syn:systemoc-fsm-bnf}%
Extended Backus-Naur form of the firing FSM declaration
\begin{verbatim}
StateDefinition ::= ActivationState '=' TransitionList ';'

TransitionList  ::= Transition '|' TransitionList |
                    Transition                    ;

Transition      ::= Guard '>>' 'CALL' '(' Action ')' '>>' ActivationState |
                               'CALL' '(' Action ')' '>>' ActivationState |
                    Guard                            '>>' ActivationState ;

Guard           ::= InputGuard '>>' OutputGuard |
                    InputGuard                  |
                                    OutputGuard ;

InputGuard      ::= '(' InputGuard ')'           |
                    InputGuard '&&' InputGuard   |
                    InputExpr                    |
                    Expr                         ;

InputExpr       ::= InputPort '.getAvailableTokens()' '>=' Expr |
                    InputPort '.getAvailableTokens()' '>'  Expr |
                    InputPort '(' Integer ')'                   ;

OutputGuard     ::= '(' OutputGuard ')'          |
                    OutputGuard '&&' OutputGuard |
                    OutputExpr                   ;

OutputExpr      ::= OutputPort '.getAvailableSpace()'  '>=' Expr |
                    OutputPort '.getAvailableSpace()'  '>'  Expr |
                    OutputPort '(' Integer ')'                   ;
\end{verbatim}
\end{csyntax}

% Der Zustandsautomat wird durch die Definition (\code{StateDefinition}) aller
% seiner Aktivierungszustände deklariert.
% Diese Aktivierungszustände sind in der \emph{BNF} durch die
% \code{ActivationState}-Terminale repräsentiert, welche C++-Variablen
% vom Typ \code{smoc\_firing\_state} entsprechen.
% Ein Aktivierungszustand ist durch die ihn verlassenden Transitionen
% \code{TransitionList} definiert.
% Eine Transition setzt sich dabei aus zwei Bedingungen,
% der \emph{Eingangsbedingung} (\code{InputGuard}) und
% der \emph{Ausgangsbedingung} (\code{OutputGuard}),
% gefolgt von einer \emph{Aktion} und dem \emph{Folgezustand} zusammen.
% Diese Aktionen sind in der \emph{BNF} durch \code{Action}-Terminale
% repräsentiert, welche C++-Methoden der Aktorklasse entsprechen.
% Die Eingangs- bzw. Ausgangsbedingung setzen sich dabei aus
% Bedingungen zur Überprüfung der Kanalfüllstände \code{InputExpr} bzw.
% \code{OutputExpr} und allgemeinen Ausdrücken \code{Expr} zusammen, welche
% den Funktionalitätszustand und die Tokenart überprüfen können.
% Diese sind in Beispiel~\ref{syn:systemoc-fsm-bnf-2} weiter erläutert.

\begin{csyntax}\label{syn:systemoc-fsm-bnf-2}%
Extended Backus-Naur form of transition guard expressions
\begin{verbatim}
Expr            ::= Expr '+'  Expr | Expr '-'  Expr |
                    Expr '*'  Expr | Expr '/'  Expr |
                    Expr '==' Expr | Expr '!=' Expr |
                    Expr '<'  Expr | Expr '<=' Expr |
                    Expr '>'  Expr | Expr '>=' Expr |
                    Expr '^'  Expr | Expr '&'  Expr |
                    Expr '|'  Expr | Expr '&&' Expr |
                    Expr '||' Expr | '(' Expr ')'   |
                    '!' Expr       | '~' Expr       |
                    ExprTerminal   ;

ExprTerminal    ::= <Integer>                                          |
                    'var'                       '(' <Variable>    ')'  |
                    'guard'                     '(' <GuardMethod> ')'  |
                    'isType'    '<' <Type> '>'  '(' Expr ')'           |
                    <InputPort> '.getValueAt'   '(' <Integer> ')'      ;
\end{verbatim}
\end{csyntax}

% Allgemeine Ausdrücke zur Überprüfung des Funktionalitätszustandes
% und der empfangenen Tokenart können mittels der obig aufgeführten
% Operatoren verknüpft werden. Die Operatoren haben dabei C++-Präzedenz und
% Bedeutung, z.B. ist '\code{\^}' das bitweise exklusive Oder.
% Die Ausdrücke werden dabei aus folgenden Terminalen aufgebaut:
% (i)   Das \code{Integer}-Terminal represäntiert einen C++-Ausdruck der
%       zur Instantiierungszeit in einen Integer umgewandelt werden kann,
%       z.B. 5, abs(-5), sqr(a+b),
% (ii)  das \code{Variable}-Terminal represäntiert eine C++-Klassenvariablen,
%       welche bei jeder Auswertung der Eingangsbedingung neu ausgelesen wird,
% (iii) das \code{GuardMethod}-Terminal represäntiert eine konstante C++-Methode der Aktorklasse,
%       welche bei jeder Auswertung der Eingangsbedingung neu aufgerufen wird,
% (iv)  das \code{isType}-Terminal erlaubt die Überprüfung ob ein Ausdruck
%       vom Typ \code{Type} ist,
% (v)   der \code{InputPort '.getValueAt'}-Terminal erlaubt es ein Token
%       aus dem Eingangsport zu überprüfen.
% Guard Methoden müssen konstante Methoden sein,
% da sie den Funktionalitätszustand nicht verändern dürfen.

%An actor is \emph{blocked} in state $q$ until at least one firing transition
%$\mathbf{t} \in \mathcal{T}_q$ is enabled, as discussed below. The set of enabled transitions is
%given by $\mathcal{T}'_q = \{ \mathbf{t} \mid \mathbf{t} \in \mathcal{T}_q \wedge \mathbf{t} \textrm{ is enabled}\}$.
%Exactly one transition $t \in \mathcal{T}'_q$ will be chosen nondeterministically
%for execution. For example, if both transitions $\{\mathbf{t}_1, \mathbf{t}_2\} = \delta(S_{start})$
%in the firing FSM shown in Figure~\ref{fig:firing-rules-print} of the Print Actor $A_6$ from Figure~\ref{fig:ng-moc}
%are enabled, one of them is executed nondeterministically.

% A transition $\mathbf{t} = (k,J)$ is enabled if its \emph{activation pattern} $k$
% is enabled. If a transition $\mathbf{t}$ is enabled and 
% part of the transitions $\mathcal{T}_q$ which leave the current state $q$
% the transition $\mathbf{t}$ can be executed, i.e.,
% $(k,J) = \mathbf{t} \in \mathcal{T}_q \wedge k\textrm{ is enabled} \implies \mathbf{t}\textrm{ can be executed}$.
% If a transition $\mathbf{t} = (k,J)$ is executed, the associated
% activation pattern $k$ and the \emph{interface action} $J$ are executed consecutively.
% The execution of the activation pattern is responsible for the
% actor communication via the actor ports. The execution of the
% interface action leads to function calls in the node functionality.
% 
% \begin{cdefinition}\label{activation-pattern}
%   An \emph{activation pattern} is a function
%   $k: A.I \cup A.O \to \mathbb{Z}^+_0,\ k \in \mathcal{K}$
%   which maps each actor port of the actor $A$ to a nonnegative integer.
% \end{cdefinition}
% 
% An activation pattern is a predicate on actor ports. It encodes the number of
% tokens to be sent (via actor output ports) or to be received (via actor input ports)
% when the activation pattern is executed.
% For example, the activation pattern $k$ of the transition $\mathbf{t}_4$
% in Figure~\ref{fig:firing-rules-divide} is
% expressed as $k(i_1) = k(i_2) = 1$ and $k(o_1) = 0$.
% However, the specification of an activation pattern by its function
% poses a great overhead. Therefore, we will use the shorthand
% $k = i_1(1) \& i_2(1)$ to express the same information.
% 
% An activation pattern $k$ is enabled if for each actor input port
% $p_I \in A.I$ at least $k(p_I)$ tokens can be received and for each
% actor output port $p_O \in A.O$ at least $k(p_O)$ tokens can be sent.
% If an activation pattern $k$ is executed it receives $k(p_I)$ tokens
% via the actor input port $p_I$ and stores them in
% temporary buffers in these actor input ports. For actor output ports
% $p_O$, $k(p_O)$ tokens in temporary buffers of the actor
% output ports are sent via these ports. These temporary buffers are
% used to provide the input and output values for the node functionality.
% 
% \begin{cdefinition}\label{interface-action}
%   An \emph{interface action} is a tuple $J = (f,Q_\mathrm{succ}),\ J \in \mathcal{J}$ containing
%   a function $f \in A.\mathcal{F}.F$ of the node functionality $A.\mathcal{F}$
%   and a set of possible successor states $Q_\mathrm{succ}$. Where the set of
%   possible successor states must contain at least one element, i.e.,
%   $|Q_\mathrm{succ}| \ge 1$.
% \end{cdefinition}
% 
% A transition $\mathbf{t} = (k,J)$ is called a \emph{deterministic transition}
% if the associated interface action $J$ has only one successor state, i.e.,
% $|J.Q_\mathrm{succ}| = 1$. A transition $\mathbf{t} = (k,J)$ is called a
% \emph{conflict transition} if the associated interface action $J$ has more
% then one possible successor state, i.e., $|J.Q_\mathrm{succ}| > 1$.
% For example the transition $\mathbf{t}_4 = (k,J)$
% in Figure~\ref{fig:firing-rules-divide} with $k = i_1(1) \& i_2(1)$,
% $J.f = \mathrm{divide}$, and $J.Q_\mathrm{succ} = \{S_2\}$ is deterministic.
% But the transition $\mathbf{t}_3 = (k,J)$ from firing state $S_{\mathrm{start}}$
% to $S_\mathrm{ok}$ or $S_\mathrm{again}$
% in Figure~\ref{fig:firing-rules-sqrloop} with $k = i_1(1) \& i_2(1)$,
% $J.f = \mathrm{check}$, and $J.Q_\mathrm{succ} = \{S_\mathrm{ok}, S_\mathrm{again}\}$
% is conflicting.
% 
% % An example of a
% % conflict transition can be seen in Figure~\ref{fig:conflict-transition}.
% 
% The notion of a firing FSM is similar to the concepts introduced in
% SPI~\cite{ZERTT99a} and FunState~\cite{STZETG00}.
% If a transition $\mathbf{t} = (k,J)$ is executed, the associated
% activation pattern $k$ and the function $J.f$ of the node functionality
% are executed consecutively. In case of a deterministic transition, the current firing
% state is updated to the only successor state $q_\mathrm{succ} \in J.Q_\mathrm{succ}$.
% In case of a conflict transition, the successor state actually used is
% a runtime decision of the function $J.f$.



\chapter{Actor behavior}

An actor $A$ can be thought of as a relation $\mathbb{A}$ which maps sequences of token values $V^{**}$ on its input ports $A.I$ into sequences of token values on its output ports $A.O$, i.e., $\mathbb{A} \subseteq (V^{**})^{|A.I|} \times (V^{**})^{|A.O|}$.

\begin{eqnarray}
\mathrm{Fire}(v, q_\mathrm{firing}, q_\mathrm{func}) = \{ w_\mathrm{prod}.w_\mathrm{tail} %
 & |      & (q_\mathrm{firing}, k, f_\mathrm{action}, q'_\mathrm{firing}) \in \mathcal{T} \\
 & \wedge & k(v_\mathrm{cons}) \\
 & \wedge & \forall{v_\mathrm{prefix} \sqsubset v_\mathrm{cons}}: \neg k(v_\mathrm{prefix}) \\
 & \wedge & (w_\mathrm{prod}, q'_\mathrm{func}) = f_\mathrm{action}(v_\mathrm{cons},q_\mathrm{func}) \\
 & \wedge & v = v_\mathrm{cons}.v_\mathrm{tail} \\
 & \wedge & w_\mathrm{tail} = \mathrm{Fire}(v_\mathrm{tail}, q'_\mathrm{firing}, q'_\mathrm{func}) \}
\end{eqnarray}

$\mathbb{A} = \{ (v,w) | w \in \mathrm{Fire}(v, q_{_0\mathrm{firing}}, q_{_0\mathrm{func}}), v \in (V^{**})^{|A.I|} \}$

% \section{Kopplung zwischen SysteMoC und VPC}
% \label{sec:smoc-vpc}
% Die SysteMoC-Bibliothek ermöglicht es, einzelne Aktoren in Form von Zustandsmaschinen, die Funktionen aufrufen, zu beschreiben.
% Eine Anwendung, z.B. der InfiniBand-HCA besteht in der Regel aus einem Netzwerk solcher Aktoren.
% Ein solches Netzwerk kann durch Simulation bezüglich der Funktionalität untersucht werden.
% Das \emph{Virtual Processing Components} Framework~\cite{streubuehr:2005} ermöglicht die zusätzliche Simulation des Zeitverhaltens unter Ressourcenbeschränkung.
% Hierfür wird für jede Aktivierung eines Aktors eine dynamisch ermittelte Ausführungszeit abgewartet.
% Diese Ausführungszeit wird durch die Bindung an eine Ressource, sowie durch eine Schedulingstrategie bestimmt.
% Einzig notwendig hierfür sind zwei Funktionsaufrufe (\code{getResource}, \code{compute}) aus der Anwendung heraus (vgl.~\cite{streubuehr:2005, fghsst:2005}).
% \par
% Zusammen mit einer Aktorbibliothek, wie der SysteMoC, können diese Aufrufe vollständig transparent für den Nutzer eingefügt werden.
% %Zusammen mit der SysteMoC-Bibliothek gestaltet sich die Kopplung wie folgt:
% Jedes mal wenn in einem Aktor eine Transition ausgeführt wird, entspricht dieses einer Aktivität.
% Bevor diese Funktionalität ausgeführt wird, werden die Funktionsaufrufe \code{getResource} und \code{compute} ausgeführt und somit die simulierte Zeit verbraucht.
% %\textbf{TODO: globales scheduling bzw. dessen Effekte erwähnen??}
% \par
% Weiterhin zeichnen sich die SysteMoC Aktoren durch ihre funktionsakkurate Aus\-führ\-ungs\-sem\-an\-tik aus:
% Ein Aktor besitzt ausdrücklich modellierte Zustände und Transitionen, wobei Transitionen die Aktivitäten darstellen und Zustandswechsel verursachen.
% Das VPC wurde dahingehend erweitert, dass die Ausführungszeit auch in Abhängigkeit zur ausgeführten Transition steht.
% Dementsprechend wurde die \code{compute}-Funktion um einen weiteren Parameter für die auszuführende Transition ergänzt.
% Während die Bindung an Ressourcen weiterhin aktorakkurat stattfindet, wird die Ausführungszeit funktionsakkurat modelliert.
% Wie schon bei der vorangegangenen Studie wird das VPC durch eine Konfiguration parametrisiert, und ermöglicht somit flexible Tests der Architektur.
% Durch die funktionsgetreue Zeitmodellierung, ist die Zahl der Konfigurationsparameter gewachsen.
% Dementsprechend wurde ein neues Konfigurationsformat auf XML Basis eingeführt, dargestellt und beschrieben in
% Abbildung \ref{resource-config}.
% 
% \begin{figure}
% \centering
% {\footnotesize
% \verbatiminput{mapping-demo.xml}}
% \caption{\label{resource-config}%
% Beispiel des neuen XML Konfigurationsformates, welches wie
% folgend aufgebaut ist:
% Innerhalb des \code{configuration}-Top-Level-Elements befinden sich die zwei Elemente
% (i) \code{resources}, innerhalb dessen die \code{component}-Elemente die virtuellen Komponenten spezifizieren,
% und (ii) \code{mappings}, welches \code{mapping}-Elemente enthält zur Abbildung aller Prozesse
% auf genau eine Komponente.
% Sowohl die \code{component}- als auch die \code{mapping}-Elemente werden mittels eingeschachtelter
% \code{attribute}-Elemente weiter Parametrisiert. Diese Parametrisierung bestimmt bei den
% \code{component}-Elementen den zu verwendenden Scheduler und bei den \code{mapping}-Elementen
% die Ausführungszeiten der Aktionen auf der ausgewählten Komponente.
% %Beispielhaft definiert \code{<attribute type="ib\_m\_atu::forward\_mfetch" value="2"/>}
% %eine Ausführungszeit von 2 $\mathrm{ns}$ für die \code{ib\_m\_atu::forward\_mfetch}
% %Aktion auf der gewählten Komponente.
% %Eine Standardausführungszeit kann ebenfalls mittels \code{<attribute type="delay" value="2"/>} angegeben werden,
% %diese wird verwendet falls die ausgeführte Aktion nicht im \code{mapping}-Element
% %parametrisiert ist.
% }
% \end{figure}

% LocalWords:  SysteMoC
