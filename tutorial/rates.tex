%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\mode<presentation>{\frametitle{\insertsubsection\ -- Objectives}}
\begin{itemize}
\item former examples consume/produce (read/write) only single tokens
\item consumption and production rates may be different from one
\end{itemize}
\begin{itemize}
\item You will learn to ...
\item ... use consumption and production rates.
\end{itemize}
\end{frame}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile=singleslide]
\mode<presentation>{\frametitle{\insertsubsection\ -- Source Actor }}
\begin{lstlisting}
static const char MESSAGE []   = "0123456789";
class Source: public smoc_actor {
public:
  smoc_port_out<char> out;
  Source(sc_module_name name) : smoc_actor(name, start),
    count(0), size(strlen(MESSAGE)), message(MESSAGE) {
    start = 
      GUARD(Source::hasToken)  >>
      out(2)                   >>
      CALL(Source::src)        >> start;
  }
private:
  smoc_firing_state start;
  unsigned int count, size;  // variables (functional state)
  const char* message;       //

  bool hasToken() const{ return count<size; } // guard
  void src() {                                // action
    out[0] = message[count++];
    out[1] = message[count++];
  }};
\end{lstlisting}
\end{frame}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile=singleslide]
\mode<presentation>{\frametitle{\insertsubsection\ -- Source Actor}}
\begin{itemize}
\item the Source actor shall produce two data tokens at once
\item we declare to produce $X$ data tokens in a transition  using \lstinline!out(!$X$\lstinline!)!
\begin{lstlisting}
    start = 
      GUARD(Source::hasToken)  >>
      out(2)                   >>
      CALL(Source::src)        >> start;
\end{lstlisting}
\item use the array operator (\lstinline![]!) to write two data tokens
\begin{lstlisting}
  void src() {
    out[0] = message[count++];
    out[1] = message[count++];
  }
\end{lstlisting}
\item similar to arrays addressing range is $0, \dots, X-1$
\end{itemize}
\end{frame}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile=singleslide]
\mode<presentation>{\frametitle{\insertsubsection\ -- Simulation}}
\begin{itemize}
\item simulation output (using Sink actor from previous example)
\end{itemize}
\begin{lstlisting}
             SystemC 2.2.0 --- Dec 15 2008 11:10:07
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
SystemC: simulation stopped by user.
\end{lstlisting}
\begin{itemize}
\item Oh oh, nothing happens!
\item writing two tokens requires a free space for (at least) two tokens
\item we need to increase the queue size (implicit size was ``1'')
\begin{lstlisting}
    connectNodePorts<4>(source.out, sink.in);
\end{lstlisting}
\item minimum size of $2$ is mandatory (but actor would run in lockstep)
\item using larger sized queues may decouple execution of actors
\end{itemize}
\end{frame}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile=singleslide]
\mode<presentation>{\frametitle{\insertsubsection\ -- Simulation}}
\begin{itemize}
\item simulation output (using Sink actor from previous example)
\item and increased queue size
\end{itemize}
\begin{lstlisting}
             SystemC 2.2.0 --- Dec 15 2008 11:10:07
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
top.Sink recv: "0"
top.Sink recv: "1"
top.Sink recv: "2"
top.Sink recv: "3"
top.Sink recv: "4"
top.Sink recv: "5"
top.Sink recv: "6"
top.Sink recv: "7"
top.Sink recv: "8"
top.Sink recv: "9"
SystemC: simulation stopped by user.
\end{lstlisting}
\end{frame}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile=singleslide]
\mode<presentation>{\frametitle{\insertsubsection\ -- Queue Access}}
\begin{center}
\resizebox{0.95\columnwidth}{!}{\input{queue-fig.tex}}
\end{center}
\begin{itemize}
\item a transition refers to $X$ input port $i$ using \lstinline!i(!$X$\lstinline!)!
\item enough tokens $\Rightarrow$ transition may be fired $\Rightarrow$ action executed once
\item access data in FIFO order using \lstinline!i[!$n$\lstinline!]!; $n \in {0, \dots, X-1}$
\item you can write/read data more than once (overwrite/re-read)
\item writing data is similar (using output ports)
\item \lstinline!o[0]! / \lstinline!i[0]! refers first free position / first available token in a queue
\end{itemize}
\end{frame}





