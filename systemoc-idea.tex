\section{SysteMoc Idea}

{\bf FIXME: Translate into English}

Nahezu alle Anwendungen lassen sich auf Basis sog. \emph{Berechnungsmodelle} beschrieben \cite{ells:1997,ls:1998}. 
So werden Signalverarbeitungsalgorithmen oftmals mit Hilfe von \emph{Datenflussmodellen} \cite{lp:1995} beschrieben, während Protokolle oftmals durch \emph{endliche Zustandsautomaten} \cite{harel:1987} modelliert werden.
Beschränkte Berechnungsmodelle bilden die Grundlage zur effizienten Analyse und Implementierung einer Anwendung. 
SystemC \cite{sysc1,glms:2002} bietet die Möglichkeit, beliebige Berechnungsmodelle zu beschreiben. 
Hierin liegt aber auch das Problem, dass das zugrundeliegende (beschränkte) Berechnungsmodell nicht mehr erkannt werden kann.
\par
Um dieses Problem zumindest teilweise lösen zu können, wurde am Lehrstuhl für Hardware-Software-Co-Design eine Aktorbibliothek mit dem Namen \emph{SysteMoC} entwickelt. 
Diese erlaubt es, Informationen über das zugrundeliegende Berechnungsmodell zu erkennen und zu analysieren.
Im Folgenden wird zunächst die Idee der SysteMoC-Bibliothek vorgestellt, bevor auf die Verwendung dieser Bibliothek eingegangen wird. 
Schließlich wird noch beschrieben, wie es mit der SysteMoC-Bibliothek möglich ist, das Zeitverhalten zu modellieren.
Hierzu kommt das am Lehrstuhl entwickelte \emph{Virtual Processing Components} Framework, welches bereits in der vorangegangenen Studie verwendet wurde, zum Einsatz.

Eine Anwendung wird oftmals in verschiedene Module zergliedert, welche meist von den einzelnen Entwicklern noch gut zu überblicken sind.
Die eigentliche Komplexität einer Anwendung ergibt sich aber durch das Kommunikationsverhalten dieser Module miteinander.
Um diesem Phänomen zu begegnen ist eine systematische Beschreibung des Kommunikationsverhalten der Module von essentieller Bedeutung.
Zu diesem Zwecke wird die Anwendung in einzelne sog. \emph{Aktoren} zerlegt, welchen eine Kommunikation untereinander nur über sog. \emph{Kanäle} mittels \emph{Nachrichten} erlaubt ist.
Die zuvor genannten Module entsprechen dabei den Aktoren, welche noch einmal in \emph{Aktivierungsregeln} und \emph{Funktionalität} unterteilt werden.
Die Aktivierungsregeln kodieren dabei das Kommunikationsverhalten des Aktors und sind in Form eines endlichen Zustandsautomaten dargestellt.
Die Zustände dieses Zustandsautomaten werden im folgenden als \emph{Aktivierungszustände} bezeichnet.
Die Funktionalität setzt sich aus einer Menge von \emph{Aktionen} zusammen, welche die
eigentliche Datenverarbeitung durchführen und Nachrichten für die Kommunikation der Aktoren untereinander generieren.
Die Ausführung dieser Aktionen kann den internen Zustand eines Aktors, im Folgenden als \emph{Funktionalitätszustand}
bezeichnet, verändern.
Die Aktivierungszustände und die Funktionalitätszustände sind dabei zwei disjunkte Zustandsmengen, welche zusammen
die möglichen \emph{Aktorzustände} ergeben.
Durch die vorgegebenen Syntax zur Kodierung der Aktivierungsregeln ist es möglich,
die Zustandsautomaten aus den SysteMoC Aktoren zu extrahiert.
Diese extrahierten Aktivierungsregeln erlauben die Zuordnung des Aktors zu einem bestimmten Berechnungsmodell.
Des weiteren sind die hier verwendeten Prinzipien eng mit der Modellierungssprache \emph{FunState} (Functions driven by State machines) verwandt \cite{stgzet:2001}.
In \cite{strehl:2000} wurde gezeigt, wie man symbolische Techniken \cite{kropf:1999} verwenden kann, um FunState-Beschreibungen zu verifizieren und zu synthetisieren.
Die Bestimmung eines gültigen statischen Ablaufplans mit beschränktem Speicher für FunState-Beschreibungen beruht hierbei auf sog.\ \emph{regulären Zustandsmaschinen} \cite{tts:2000}.
Aufgrund der Ähn\-lich\-keiten in den Konzepten von SysteMoC und FunState können die für FunState entwickelten Methoden auf die SysteMoC übertragen werden.

% LocalWords:  SysteMoC
