%\vspace{-8mm}
%\begin{center}\parbox{12cm}
{\itshape
Actor-based design is based on composing a system of communicating processes called \emph{actors}, which can only communicate with each other via channels.
% Thus, it constraints the communication infrastructure of concurrent system to message passing over a predefined network graph of channels enabling XXX.
However, actor-based design does not constrain the communication behavior of its actors therefore making analyses of the system in general impossible.
Models of computation (MoCs) are predefined types of communication behavior between actors and strategies for scheduling them.
%They are comparable to design patterns as used in software engineering and the basis for model-based design. %, which is a methodology for creating executable specifications which only use predefined patterns for communication which correspond to different MoCs.
%Moreover, MoCs represent well known trade-offs between expressiveness and analyzability.
In this paper, we propose a library based on the design language SystemC called \SysteMoC{} which provides a simulation environment for model-based designs.
We will introduce the syntax and semantics supported by \SysteMoC{} as well as discuss the simulation environment and present first results from using \SysteMoC{} for modeling and simulation of signal processing applications.
% \SysteMoC{} defines a coding style for specifying the communication behavior of actors as finite state machines and the communication infrastructure as a network graph of communicating actors, as well as functionality to extract this information from the executable specification.
% Therefore we provide the basis for model-based design in SystemC enabling automatic extraction and classification of the communication behavior of actors.
% Thus later enabling us to use analysis for optimized code generation as well as efficient system property checks by automatic verification tools.
}
%\end{center}

\section{Introduction}\label{sec:intro}

Due to rising design complexity, it is necessary to increase the level of abstraction at which systems are designed.
This can be achieved by model-based design which makes extensive use of so-called \emph{models of computation} \cite{embsft:2002} (MoCs).
MoCs are comparable to design patterns known from the area of software design \cite{gamma:1995}.
On the other hand, industrial embedded system design is still based on design languages like C, C++, Java, VHDL, SystemC, and SystemVerilog which allow unstructured communication.
Even worse, nearly all design languages are Turing complete making analyses in general impossible.
This precludes the automatic identification of communication patterns out of the many forms of interactions, e.g, shared variables and various ways of message passing, between processes.
To make industry benefit from the best of both worlds, engineers must restrict themselves to use certain coding styles and subsets of a design language.
This results in a model-based design methodology that permits automatic analysis, identification, and and extraction of MoCs at the source code level.

%\begin{figure}[t]
%\centering
%\resizebox{\columnwidth}{!}{\input{SysteMoC-Goals-fig.tex}}
%\caption{\label{fig:SysteMoC-Goals}The Goal of the \SysteMoC{}-framework
%  is the identification and extraction of models of computation
%  from a subset of SystemC. Later the extracted MoC can be used
%  in a model-based design methodology, e.g, in design space exploration
%  and for code generation.
%}
%\end{figure}

% The overall methodology is depicted in Figure~\ref{fig:SysteMoC-Goals}.

In this paper, we focus on the \SysteMoC{}-framework, which provides such a coding style on top of SystemC.
This coding style specifies a \emph{machine analyzable encoding} for the \emph{communication behavior} of actors as finite state machines as well as a style for the specification of the communication network connecting these actors.
Using this coding style enables later analysis stages, not described in this paper, to assess the communication behavior of all actors in the communication network by triggering the framework to automatically extract this information from the executable specification.
The rest of this paper is structured as follows:
In Section~\ref{sec:related-work}, we discuss related work.
In Section~\ref{sec:systemoc-syntax}, we present our coding style on top of SystemC as well as the mathematical model of our actors.
In Section~\ref{sec:systemoc-implementation}, a SystemC implementation of our framework called \SysteMoC{} is presented,
and we conclude the present paper in Section~\ref{sec:conclusions}.

\section{Related Work}\label{sec:related-work}

The advantages of using a model-based approach has been shown by many examples, e.g, in protocol design \cite{SDL-92} and in the signal processing domain \cite{bhattacharyya,bb:2000a}.
SystemC \cite{glms:2002,systemc-lrm:2003} permits the modeling of many different MoCs.
Unfortunately, there is no unique representation of a given MoC in SystemC.
Moreover, the use of unstructured communication makes the automatic analysis of a SystemC design nearly impossible.
The SystemC Transaction Level Modeling (TLM) standard \cite{SystemC-TLM05} does not alleviate these problems because it is not concerned with defining representations of MoCs in SystemC.
Instead the TLM standard defines transaction level interfaces via method calls, therefore improving simulation efficiency and providing the foundation for platform-based design in SystemC.

% In this paper, we will propose a library, called \SysteMoC{}, that provides classes allowing the easy expression of MoCs in SystemC.

The facilities for implementing MoCs in SystemC have been extended by Herrera et al.~\cite{herrerasystemc:2004} who have implemented a custom library of channel types like rendezvous on top of the SystemC discrete event simulation kernel.
But no constraints have been imposed how these new channels types are used by an actor.
Consequently, no information about the communication behavior of an actor can be automatically extracted from the executable specification.
Implementing these channels on top of the SystemC discrete event simulation kernel curtails the performance of such an implementation.
Therefore, Patel et al.~\cite{PS:2005, PS:2004} have extended SystemC itself with different simulation kernels for \emph{Communicating Sequential Processes} and \emph{Finite State Machine MoCs} to improve the simulation efficiency of their approach.

% Moreover, they have implemented hierarchical composition of MoCs following the approach of Ptolemy~II.
Ptolemy~II \cite{ptolemyII} is a simulation framework for MoCs implemented in Java.
Its aim is the exploration of different MoCs and the semantic of hierarchical composition of these MoC with each other.
However, its Java implementation limits the ease of integration of this framework with the arising design flow centered on SystemC used by industry for system level modeling.

% But in our approach we go one step further by restricting the behavior of an actor, too.
In contrast to the approaches discussed above, our methodology divides an actor into its \emph{functionality} responsible for \emph{data processing} and a \emph{firing FSM} responsible for the communication behavior of this actor.
This enables us to automatically extract this communication behavior from the executable specification for later analysis steps.
The MoC underlying our methodology is a generalization of \emph{FunState} (Functions driven by State machines) \cite{stgzet:2001}, which allows all function of an actor to share a state.
The basis of the analysis steps we will perform with the extracted communication behavior have been detailed by Strehl et al.~\cite{strehl:2000} which uses symbolic techniques \cite{kropf:1999} based on regular state machines \cite{tts:2000} to schedule FunState models.
%Aufgrund der Ähn\-lich\-keiten in den Konzepten von \SysteMoC{} und FunState können die für FunState entwickelten Methoden auf die \SysteMoC{} übertragen werden.

% LocalWords: SysteMoC
