\chapter{SysteMoC semantic}

\section{Actor behavior}

As known from Kahn \cite{Kahn:1974} and Lee \cite{Lee98,LeeDenotialDF:1997} we use the sequence of tokens $\mathbf{v} \in V^{**}$ transmitted via a FIFO to mathematical describe it.
In order to simplify this description we will replace a bounded FIFO with two unbounded FIFOs.
Therefore each actor port is connected to a pair of FIFOs $z = (\mathbf{v}, \mathbf{f}) \in Z$ containing
a \emph{value FIFO} $\mathbf{v} \in V^{**}$ and
a \emph{free space FIFO} $\mathbf{f} \in \{\circ\}^{**}$, where each \emph{free space symbol} $\circ$ represents an available slot in the value FIFO to store a token. % as known from PETRI-nets \cite{XXXX}.
Accordingly an actor not only consumes sequences of tokens $V^{**}$ on its input ports $I$ and produce them on its output ports $O$ but also produce sequences of free space symbols $\{\circ\}^{**}$ on its input ports and consume them on its output ports, respectively.

These sequences are combined into a tuple $\mathbf{s} \in (V_\circ^{**})^{|\mathcal{P}|}$ of input and output sequences, where $V_\circ$ denotes the set of all values including the free space symbol, i.e., $V_\circ = V \cup \{\circ\}$, and $\mathcal{P}$ denotes all ports of this actor, i.e., $\mathcal{P} = I \cup O$.
The position of a signal in its tuple is equivalent to its name.
To achieve the equivalent of renaming or hiding signals, the position of signals in a tuple must be changed or the signal must be drop from the tuple.
This is done by applying the \emph{projection} function to a tuple.
\begin{definition}\label{tsm-projection}
A \emph{projection} $\pi{}_I: S^N \to S^M$ is a function which discards and reorders signals according
to the discrete set of indices $I$ in a $N$-tuple of signals
to form a new $M$-tuple of signals, where $M \le N$. In other words, given $\mathbf{s} = (s_1,\ldots,s_N) \in S^N$
and $I = [i_1,\ldots,i_M] \subseteq \mathbb{N}_N$
then $\pi{}_I(\mathbf{s}) = (s_{i_1}, \ldots, s_{i_M})$.
A projection $\pi{}_I$ can be generalized to subsets $\mathbf{P}$ of $S^N$,
i.e., $\pi{}_I(\mathbf{P}) = \{\pi{}_I(\mathbf{s}) \mid \mathbf{s} \in \mathbf{P}\}$.
\end{definition}

As example consider the tuple of signals $\mathbf{s} = (s_1,s_2,s_3,s_4,s_5)$, and the discrete set
$I=[5,4,2,1]$ then the projection is given as $\pi{}_I(\mathbf{s}) = (s_5,s_4,s_2,s_1)$.




%For notational simplicity we will assume that the free space symbol is contained in the set of all values, i.e., $\circ \in V$.

The execution of an actor is divided into atomic \emph{firing steps}, where each step corresponds to the execution of a transition $t \in \mathcal{R}.T$ of the firing FSM.
To decide if a transition can be taken its associated \emph{activation pattern} must be evaluated.

\begin{definition}[Activation pattern]\label{def:activation-pattern}
  An \emph{activation pattern} $k$ of an actor $a \in A$ is a is a boolean function depending on the available input token sequences $\mathbf{S}_\mathrm{in}$ and the \emph{functionality state} $\mathcal{F}.S_\mathrm{func}$ of the actor, i.e., $k: \mathbf{S}_\mathrm{in} \times \mathcal{F}.S_\mathrm{func} \to \{\mathrm{true}, \mathrm{false}\}$.
  The activation pattern is used to decide if its associated transition can be taken $(\mathrm{true})$ or not $(\mathrm{false})$.
\end{definition}

Each firing step of an actor consumes a tuple of finite sequences $\mathbf{s}_\mathrm{cons} \in (V_\circ^*)^{|\mathcal{P}|}$, which is a prefix $\mathbf{s}_\mathrm{cons} \sqsubseteq \mathbf{s}_\mathrm{in}$ of the tuple of possibly infinite input sequences $\mathbf{s}_\mathrm{in} \in \mathbf{S}_\mathrm{in} \subseteq (V_\circ^{**})^{|\mathcal{P}|}$.
Consequently a tuple of output sequences $\mathbf{s}_\mathrm{prod} \in \mathbf{S}_\mathrm{prod} \subseteq (V_\circ^*)^{|\mathcal{P}|}$ is produced.
The tuple of input sequences $\mathbf{s}_\mathrm{in}$ is further constraint to be devided into sequences containing only value tokens $\pi{}_{I}(\mathbf{s}_\mathrm{in}) \in (V^{**})^{|I|}$, each sequence associated with an actor input port, and  sequences containing only free space symbols $\pi{}_{O}(\mathbf{s}_\mathrm{in}) \in (\{\circ\}^{**})^{|O|}$, each sequence associated with an actor output port.
The tuple of produced output sequences $\mathbf{s}_\mathrm{prod}$ is similarly devided into sequences containing only value tokens $\pi{}_{O}(\mathbf{s}_\mathrm{prod}) \in (V^{**})^{|O|}$, each sequence associated with an actor output port, and sequences containing only free space symbols $\pi{}_{I}(\mathbf{s}_\mathrm{prod}) \in (\{\circ\}^{**})^{|I|}$, each sequence associated with an actor input port.
Furthermore each firing step transforms the \emph{actor state} $s \in S = \mathcal{F}.S_\mathrm{func} \times \mathcal{R}.S_\mathrm{firing}$, i.e., $\mathrm{Fire}: \mathbf{S}_\mathrm{in} \times S \to 2^{\mathbf{S}_\mathrm{prod} \times S}$.
\footnote{We use $2^X$ to denote the powerset of $X$, the set of all subsets of $X$, i.e., $2^X = \bigcup_{X_\mathrm{subset} \subseteq X} \{X_\mathrm{subset}\}$.}

\begin{eqnarray}
\mathrm{Fire}(\mathbf{s}_\mathrm{in}, (s_\mathrm{func}, s_\mathrm{firing})) = \{%
 &        & (\mathbf{s}_\mathrm{prod}, (s'_\mathrm{func}, s'_\mathrm{firing})) \\
 & |      & (s_\mathrm{firing}, k, f_\mathrm{action}, s'_\mathrm{firing}) \in T \\
 & \wedge & \mathbf{s}_\mathrm{cons} \sqsubseteq \mathbf{s}_\mathrm{in} \\
 & \wedge & k(\mathbf{s}_\mathrm{cons}, s_\mathrm{func}) \\
 & \wedge & \forall{\mathbf{s}_\mathrm{prefix} \sqsubset \mathbf{s}_\mathrm{cons}}: \neg k(\mathbf{s}_\mathrm{prefix}) \\
 & \wedge & (\pi{}_{O}(\mathbf{s}_\mathrm{prod}), s'_\mathrm{func}) = f_\mathrm{action}(\pi{}_{I}(\mathbf{s}_\mathrm{cons}), s_\mathrm{func}) \\
 & \wedge & \#\pi{}_{I}(\mathbf{s}_\mathrm{prod}) = \#\pi{}_{I}(\mathbf{s}_\mathrm{cons})
\end{eqnarray}


% sequence of tokens $\mathbf{v} \in V^{**}$ for each actor input port $i \in I$ and sequences of free space tokens $\mathbf{f} \in \{\circ\}^{**}$ for each actor output port $o \in O$,

%$z = (\mathbf{v}, \mathbf{f}) \in Z$, the data FIFO $z.\mathbf{v} \in V^{**}$ and the free space FIFO $z.\mathbf{s} \in \{\circ\}^{**}$.


%$a.\mathcal{P}' = [i_1, i'_1, i_2, i'_2, \ldots, i_{|a.I|}, i'_{|a.I|}, o_1, o'_1, o_2, o'_2, \ldots, o_{|a.O|}, o'_{|a.O|}]$
%$a.\mathcal{I}' = \{i_1, i_2, \ldots, i_{|a.I|}, o'_1, o'_2, \ldots, o'_{|a.O|}\}$
%$a.\mathcal{O}' = \{i'_1, i'_2, \ldots, i'_{|a.I|}, o_1, o_2, \ldots, o_{|a.O|}\}$
$\mathbf{z} \in Z^{|\mathcal{P}|}$ actor ports $\mathcal{P}$
$\mathrm{IN}(\mathbf{z}) = \pi{}_{I}(\mathbf{z}).\mathbf{v} \times \pi{}_{O}(\mathbf{z}).\mathbf{f}$
$\mathrm{OUT}(\mathbf{z}) = \pi{}_{I}(\mathbf{z}).\mathbf{v} \times \pi{}_{O}(\mathbf{z}).\mathbf{f}$





%\begin{eqnarray}
%\mathrm{Fire}(\mathbf{z}, s_\mathrm{firing}, s_\mathrm{func}) = \{ (\mathbf{z}', s'_\mathrm{firing}, s'_\mathrm{func}) %
% & |      & (s_\mathrm{firing}, k, f_\mathrm{action}, s'_\mathrm{firing}) \in T \\
% & \wedge & k(\mathbf{v}_\mathrm{cons}) \\
% & \wedge & \forall{\mathbf{v}_\mathrm{prefix} \sqsubset \mathbf{v}_\mathrm{cons}}: \neg k(\mathbf{v}_\mathrm{prefix}) \\
% & \wedge & (\mathbf{w}_\mathrm{prod}, s'_\mathrm{func}) = f_\mathrm{action}(\mathbf{v}_\mathrm{cons},s_\mathrm{func}) \\
%\end{eqnarray}

An actor $a$ can be thought of as a relation $\mathbb{A}$ which maps sequences of token values $V^{**}$ on its input ports $a.I$ into sequences of token values on its output ports $a.O$, i.e., $\mathbb{A} \subseteq (V^{**})^{|a.\mathcal{P}|}$.

\begin{eqnarray}
\mathrm{Fire}(\mathbf{v}, s_\mathrm{firing}, s_\mathrm{func}) = \{ \mathbf{w}_\mathrm{prod}\concat\mathbf{w}_\mathrm{tail} %
 & |      & (s_\mathrm{firing}, k, f_\mathrm{action}, s'_\mathrm{firing}) \in T \\
 & \wedge & k(\mathbf{v}_\mathrm{cons}) \\
 & \wedge & \forall{\mathbf{v}_\mathrm{prefix} \sqsubset \mathbf{v}_\mathrm{cons}}: \neg k(\mathbf{v}_\mathrm{prefix}) \\
 & \wedge & (\mathbf{w}_\mathrm{prod}, s'_\mathrm{func}) = f_\mathrm{action}(\mathbf{v}_\mathrm{cons},s_\mathrm{func}) \\
 & \wedge & \mathbf{v} = \mathbf{v}_\mathrm{cons}\concat\mathbf{v}_\mathrm{tail} \\
 & \wedge & \mathbf{w}_\mathrm{tail} = \mathrm{Fire}(\mathbf{v}_\mathrm{tail}, s'_\mathrm{firing}, s'_\mathrm{func}) \}
\end{eqnarray}

$\mathbb{A} = \{ (\mathbf{v},\mathbf{w}) | \mathbf{w} \in \mathrm{Fire}(\mathbf{v}, s_{_0\mathrm{firing}}, s_{_0\mathrm{func}}), \mathbf{v} \in (V^{**})^{|A.I|} \times (\{\circ\}^{**})^{|a.O|} \}$

% \section{Kopplung zwischen SysteMoC und VPC}
% \label{sec:smoc-vpc}
% Die SysteMoC-Bibliothek ermöglicht es, einzelne Aktoren in Form von Zustandsmaschinen, die Funktionen aufrufen, zu beschreiben.
% Eine Anwendung, z.B. der InfiniBand-HCA besteht in der Regel aus einem Netzwerk solcher Aktoren.
% Ein solches Netzwerk kann durch Simulation bezüglich der Funktionalität untersucht werden.
% Das \emph{Virtual Processing Components} Framework~\cite{streubuehr:2005} ermöglicht die zusätzliche Simulation des Zeitverhaltens unter Ressourcenbeschränkung.
% Hierfür wird für jede Aktivierung eines Aktors eine dynamisch ermittelte Ausführungszeit abgewartet.
% Diese Ausführungszeit wird durch die Bindung an eine Ressource, sowie durch eine Schedulingstrategie bestimmt.
% Einzig notwendig hierfür sind zwei Funktionsaufrufe (\code{getResource}, \code{compute}) aus der Anwendung heraus (vgl.~\cite{streubuehr:2005, fghsst:2005}).
% \par
% Zusammen mit einer Aktorbibliothek, wie der SysteMoC, können diese Aufrufe vollständig transparent für den Nutzer eingefügt werden.
% %Zusammen mit der SysteMoC-Bibliothek gestaltet sich die Kopplung wie folgt:
% Jedes mal wenn in einem Aktor eine Transition ausgeführt wird, entspricht dieses einer Aktivität.
% Bevor diese Funktionalität ausgeführt wird, werden die Funktionsaufrufe \code{getResource} und \code{compute} ausgeführt und somit die simulierte Zeit verbraucht.
% %\textbf{TODO: globales scheduling bzw. dessen Effekte erwähnen??}
% \par
% Weiterhin zeichnen sich die SysteMoC Aktoren durch ihre funktionsakkurate Aus\-führ\-ungs\-sem\-an\-tik aus:
% Ein Aktor besitzt ausdrücklich modellierte Zustände und Transitionen, wobei Transitionen die Aktivitäten darstellen und Zustandswechsel verursachen.
% Das VPC wurde dahingehend erweitert, dass die Ausführungszeit auch in Abhängigkeit zur ausgeführten Transition steht.
% Dementsprechend wurde die \code{compute}-Funktion um einen weiteren Parameter für die auszuführende Transition ergänzt.
% Während die Bindung an Ressourcen weiterhin aktorakkurat stattfindet, wird die Ausführungszeit funktionsakkurat modelliert.
% Wie schon bei der vorangegangenen Studie wird das VPC durch eine Konfiguration parametrisiert, und ermöglicht somit flexible Tests der Architektur.
% Durch die funktionsgetreue Zeitmodellierung, ist die Zahl der Konfigurationsparameter gewachsen.
% Dementsprechend wurde ein neues Konfigurationsformat auf XML Basis eingeführt, dargestellt und beschrieben in
% Abbildung \ref{resource-config}.
% 
% \begin{figure}
% \centering
% {\footnotesize
% \verbatiminput{mapping-demo.xml}}
% \caption{\label{resource-config}%
% Beispiel des neuen XML Konfigurationsformates, welches wie
% folgend aufgebaut ist:
% Innerhalb des \code{configuration}-Top-Level-Elements befinden sich die zwei Elemente
% (i) \code{resources}, innerhalb dessen die \code{component}-Elemente die virtuellen Komponenten spezifizieren,
% und (ii) \code{mappings}, welches \code{mapping}-Elemente enthält zur Abbildung aller Prozesse
% auf genau eine Komponente.
% Sowohl die \code{component}- als auch die \code{mapping}-Elemente werden mittels eingeschachtelter
% \code{attribute}-Elemente weiter Parametrisiert. Diese Parametrisierung bestimmt bei den
% \code{component}-Elementen den zu verwendenden Scheduler und bei den \code{mapping}-Elementen
% die Ausführungszeiten der Aktionen auf der ausgewählten Komponente.
% %Beispielhaft definiert \code{<attribute type="ib\_m\_atu::forward\_mfetch" value="2"/>}
% %eine Ausführungszeit von 2 $\mathrm{ns}$ für die \code{ib\_m\_atu::forward\_mfetch}
% %Aktion auf der gewählten Komponente.
% %Eine Standardausführungszeit kann ebenfalls mittels \code{<attribute type="delay" value="2"/>} angegeben werden,
% %diese wird verwendet falls die ausgeführte Aktion nicht im \code{mapping}-Element
% %parametrisiert ist.
% }
% \end{figure}

\section{Network graph behavior}



% LocalWords:  SysteMoC
