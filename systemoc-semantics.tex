\chapter{SysteMoC semantic}

\section{Actor behavior}

An actor $a$ can be thought of as a relation $\mathbb{A}$ which maps sequences of token values $V^{**}$ on its input ports $a.I$ into sequences of token values on its output ports $a.O$, i.e., $\mathbb{A} \subseteq (V^{**})^{|a.I|} \times (V^{**})^{|a.O|}$.

\begin{eqnarray}
\mathrm{Fire}(\mathbf{v}, s_\mathrm{firing}, s_\mathrm{func}) = \{ \mathbf{w}_\mathrm{prod}.\mathbf{w}_\mathrm{tail} %
 & |      & (s_\mathrm{firing}, k, f_\mathrm{action}, s'_\mathrm{firing}) \in T \\
 & \wedge & k(\mathbf{v}_\mathrm{cons}) \\
 & \wedge & \forall{\mathbf{v}_\mathrm{prefix} \sqsubset \mathbf{v}_\mathrm{cons}}: \neg k(\mathbf{v}_\mathrm{prefix}) \\
 & \wedge & (\mathbf{w}_\mathrm{prod}, s'_\mathrm{func}) = f_\mathrm{action}(\mathbf{v}_\mathrm{cons},s_\mathrm{func}) \\
 & \wedge & \mathbf{v} = \mathbf{v}_\mathrm{cons}.\mathbf{v}_\mathrm{tail} \\
 & \wedge & \mathbf{w}_\mathrm{tail} = \mathrm{Fire}(\mathbf{v}_\mathrm{tail}, s'_\mathrm{firing}, s'_\mathrm{func}) \}
\end{eqnarray}

$\mathbb{A} = \{ (\mathbf{v},\mathbf{w}) | \mathbf{w} \in \mathrm{Fire}(\mathbf{v}, s_{_0\mathrm{firing}}, s_{_0\mathrm{func}}), \mathbf{v} \in (V^{**})^{|A.I|} \}$

% \section{Kopplung zwischen SysteMoC und VPC}
% \label{sec:smoc-vpc}
% Die SysteMoC-Bibliothek ermöglicht es, einzelne Aktoren in Form von Zustandsmaschinen, die Funktionen aufrufen, zu beschreiben.
% Eine Anwendung, z.B. der InfiniBand-HCA besteht in der Regel aus einem Netzwerk solcher Aktoren.
% Ein solches Netzwerk kann durch Simulation bezüglich der Funktionalität untersucht werden.
% Das \emph{Virtual Processing Components} Framework~\cite{streubuehr:2005} ermöglicht die zusätzliche Simulation des Zeitverhaltens unter Ressourcenbeschränkung.
% Hierfür wird für jede Aktivierung eines Aktors eine dynamisch ermittelte Ausführungszeit abgewartet.
% Diese Ausführungszeit wird durch die Bindung an eine Ressource, sowie durch eine Schedulingstrategie bestimmt.
% Einzig notwendig hierfür sind zwei Funktionsaufrufe (\code{getResource}, \code{compute}) aus der Anwendung heraus (vgl.~\cite{streubuehr:2005, fghsst:2005}).
% \par
% Zusammen mit einer Aktorbibliothek, wie der SysteMoC, können diese Aufrufe vollständig transparent für den Nutzer eingefügt werden.
% %Zusammen mit der SysteMoC-Bibliothek gestaltet sich die Kopplung wie folgt:
% Jedes mal wenn in einem Aktor eine Transition ausgeführt wird, entspricht dieses einer Aktivität.
% Bevor diese Funktionalität ausgeführt wird, werden die Funktionsaufrufe \code{getResource} und \code{compute} ausgeführt und somit die simulierte Zeit verbraucht.
% %\textbf{TODO: globales scheduling bzw. dessen Effekte erwähnen??}
% \par
% Weiterhin zeichnen sich die SysteMoC Aktoren durch ihre funktionsakkurate Aus\-führ\-ungs\-sem\-an\-tik aus:
% Ein Aktor besitzt ausdrücklich modellierte Zustände und Transitionen, wobei Transitionen die Aktivitäten darstellen und Zustandswechsel verursachen.
% Das VPC wurde dahingehend erweitert, dass die Ausführungszeit auch in Abhängigkeit zur ausgeführten Transition steht.
% Dementsprechend wurde die \code{compute}-Funktion um einen weiteren Parameter für die auszuführende Transition ergänzt.
% Während die Bindung an Ressourcen weiterhin aktorakkurat stattfindet, wird die Ausführungszeit funktionsakkurat modelliert.
% Wie schon bei der vorangegangenen Studie wird das VPC durch eine Konfiguration parametrisiert, und ermöglicht somit flexible Tests der Architektur.
% Durch die funktionsgetreue Zeitmodellierung, ist die Zahl der Konfigurationsparameter gewachsen.
% Dementsprechend wurde ein neues Konfigurationsformat auf XML Basis eingeführt, dargestellt und beschrieben in
% Abbildung \ref{resource-config}.
% 
% \begin{figure}
% \centering
% {\footnotesize
% \verbatiminput{mapping-demo.xml}}
% \caption{\label{resource-config}%
% Beispiel des neuen XML Konfigurationsformates, welches wie
% folgend aufgebaut ist:
% Innerhalb des \code{configuration}-Top-Level-Elements befinden sich die zwei Elemente
% (i) \code{resources}, innerhalb dessen die \code{component}-Elemente die virtuellen Komponenten spezifizieren,
% und (ii) \code{mappings}, welches \code{mapping}-Elemente enthält zur Abbildung aller Prozesse
% auf genau eine Komponente.
% Sowohl die \code{component}- als auch die \code{mapping}-Elemente werden mittels eingeschachtelter
% \code{attribute}-Elemente weiter Parametrisiert. Diese Parametrisierung bestimmt bei den
% \code{component}-Elementen den zu verwendenden Scheduler und bei den \code{mapping}-Elementen
% die Ausführungszeiten der Aktionen auf der ausgewählten Komponente.
% %Beispielhaft definiert \code{<attribute type="ib\_m\_atu::forward\_mfetch" value="2"/>}
% %eine Ausführungszeit von 2 $\mathrm{ns}$ für die \code{ib\_m\_atu::forward\_mfetch}
% %Aktion auf der gewählten Komponente.
% %Eine Standardausführungszeit kann ebenfalls mittels \code{<attribute type="delay" value="2"/>} angegeben werden,
% %diese wird verwendet falls die ausgeführte Aktion nicht im \code{mapping}-Element
% %parametrisiert ist.
% }
% \end{figure}

\section{Network graph behavior}



% LocalWords:  SysteMoC
